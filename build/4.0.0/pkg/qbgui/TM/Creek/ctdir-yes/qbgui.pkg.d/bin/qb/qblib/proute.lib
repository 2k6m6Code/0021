############################################################################################################
#                    Policy Routing and Policy-based Filter for QoS Config
############################################################################################################

#########################   About  Policy Routing   ###################################
sub showPolicyTitle
{
    my (%action)=@_;
    my $viewpoint=$action{viewpoint};
    my %titleWidth=(Enabled=>'80', Source=>'150', Service=>'120', Destination=>'150', 'NAT Status'=>'90', Pool=>'100', Schedule=>'120', Status=>'50', QoS=>'80', 'Quota D/U'=>'80', Edit=>'30',Action=>'100');
    #my %titleWidth=(Source=>'18%', Service=>'11%', Destination=>'13%', 'NAT Status'=>'10%', Pool=>'22%', Schedule=>'8%', Status=>'3%', QoS=>'5%', Edit=>'2%');
    my @titleList=('Schedule', 'Pool', 'NAT Status', 'Status', 'Edit');
    if ( $action{showqos} eq '1' )
    {
		@titleList=('Schedule', 'Pool', 'NAT Status', 'Status', 'QoS', 'Edit');
		if ( $action{viewpoint} eq 'nat' )
		{
			@titleList=('Schedule', 'Pool', 'NAT Status', 'Status', 'QoS', 'Quota D/U', 'Edit');
		}
		if ( $action{viewpoint} eq 'app' )
		{
			@titleList=('Schedule', 'Action', 'Status', 'QoS', 'Edit');
		}
    }
    if ( $action{viewpoint} eq 'nat' && $action{showqos} ne '1')
    {
	@titleList=('Schedule', 'Pool', 'NAT Status', 'Status', 'Edit');
    }
    if ( $action{viewpoint} eq 'app' && $action{showqos} ne '1')
    {
	@titleList=('Schedule', 'Action', 'Status', 'Edit');
    }
 
    print qq (<div class="divframe">);
    print qq (<table width="100%" bgcolor="#332211" border="0" align="center"> );
    print qq (<tr>);
#=cut # Gary hide on/off policy 20140319
    if ( $action{viewpoint} eq 'nat' )
    {
        print qq (<td align="center" style="width:$titleWidth{Enabled}">Enabled);
#        print qq (<input type="checkbox" onClick="setAllCheckBoxValue('enabled_policy', this.checked);enabled_disabled_policy('SelectAll',this.status);">);
print qq (<input type="button" class="qb" value="Apply" onclick="AlertApply();" title="Activate your setup for enable or disable.">);
	print qq (</td>);
    }
#=cut
    print qq (<td align="center" width="$titleWidth{'Source'}" ><a href="javascript:sortPolicy('BYSOURCE')" title="Sort by Source" border="0">Source</a></td>);
    print qq (<td align="center" width="$titleWidth{'Destination'}" >Destination</td>);
    my $title = ( $action{viewpoint} eq 'app' ) ? ( 'Application' ) : ( 'Service' );
    print qq (<td align="center" width="$titleWidth{'Service'}" ><a href="javascript:sortPolicy('BYSERVICE')" title="Sort by Service" border="0">$title</a></td>);
    foreach my $title ( @titleList ) { print qq (<td  align="center" width="$titleWidth{$title}"><font color="#ffffff">$title</font></td>); }
    print qq (<td align="center" width="50" ><a href="javascript:delPolicy()"><image src="image/del.gif" title="Delete checked policies" border="0"></a>);
    print qq (<input type="checkbox" title="select or deselect all items" onClick="setAllCheckBoxValue('rule', this.checked)">);
    print qq (</td>);
    print qq (</tr>);
    print qq (</table>);
    print qq (</div>);
}
#showPolicyTitle


#===========================================================================================
sub list_ini_rule 
{
    my (%action)=@_;
    my $viewpoint=$action{viewpoint};
    my $iniroute=XMLread($gPATH."iniroute.xml");
    my $classes=$iniroute->{$viewpoint}->[0]->{class};
    my @sortedClasses;
    my %priority=(1=>'High', 3=>'Medium', 5=>'Low');
    my $sortingKEY=$action{sortingkey};
    #add qos
    my %titleWidth=(Enabled=>'80', Source=>'150', Service=>'120', Destination=>'150', 'NAT Status'=>'90', Pool=>'100', Schedule=>'120', Status=>'50', QoS=>'80', 'Quota D/U'=>'80', Edit=>'30');
    
    my @titleList=('Schedule', 'Pool', 'NAT Status', 'Status', 'QoS', 'Edit');
    #host obj to sort
    my @hostobj;
    my @srcobj;
    foreach my $item ( @$classes )
    {
        if( grep(/^host-/, $item->{source}) )
        {
            push(@hostobj, $item);
        }
        else
        {
            push(@srcobj, $item); 
        }
    }
    @hostobj=sort ini_class_sort_by_hostobj @hostobj;
    
    if ( !$sortingKEY )                     { $sortingKEY='BYSOURCE';}
    #if ( $sortingKEY eq 'BYSOURCE' )        { @sortedClasses=sort ini_class_sort_by_source @$classes; }
    #elsif ( $sortingKEY eq 'BYSERVICE' )    { @sortedClasses=sort ini_class_sort_by_service @$classes;}
    if ( $sortingKEY eq 'BYSOURCE' )        { @sortedClasses=sort ini_class_sort_by_source @srcobj; }
    elsif ( $sortingKEY eq 'BYSERVICE' )    { @sortedClasses=sort ini_class_sort_by_service @srcobj;}
    
    push(@sortedClasses, @hostobj);
    
    #================================================================================================
    # we get all necessary info. here to avoid unacceptable loop-count times access to all this info.
    # data structure all the policy check will use
    
    #======================================================================================================
    # phase 1. prepare some necessary data structure before looping to use for speeding up valid checking ...
    
    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # prepare step 1. get isp id list
    my @ispidlist;
    @ispidlist=maintainBasic( action=>'GETIIDLIST' ); 
    
    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # prepare step 2.  
    # %isppubip is a data structure designed to be loaded on demand
    my %isppubip;
    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # prepare step 3.
    my @sourcelist;
    my %source2isp;
    if ( $viewpoint=~m/dmz|nat/ ) 
    { 
        foreach my $class ( @sortedClasses ) { if ($class->{source} ne 'system') { push(@sourcelist, $class->{source});}}    
    }
    %source2isp=batchFindMyISP( @sourcelist );
    
    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # prepare step 4.
    my %POLICY_USABLE_TABLES;
    if ( $viewpoint=~m/nat/ )
    {
        %POLICY_USABLE_TABLES=maintainRtable( action=>"GETPOLICYUSABLETABLEIDS", viewpoint=>"$viewpoint", source2isp=>\%source2isp );
    }
    else
    {
        %POLICY_USABLE_TABLES=maintainRtable( action=>"GETPOLICYUSABLETABLEIDS", viewpoint=>"$viewpoint" );
    }

    print qq (<div class="divframe" style="height:70%">);
    print qq (<table class="body" id="ruleList" width="100%" border="0">);
    #print qq (<table id="ruleList" width="1000" class="body" border="0" align="center" >);
    
    my $lineCount=0;
    #my @tablelist;
    foreach my $class ( @sortedClasses ) { if ( $class->{table} eq 'system' ) {  next; } push(@tablelist, $class->{table});}
    my @showtable = presentTables(@tablelist);
    foreach my $class ( @sortedClasses ) 
    {
		my $quotaSource='';
		my $quotaDest='';
        #碰到系統保留的那一筆就免了
        if ( $class->{service} eq 'system' ) { next; }
        if ( $class->{enables} eq '1' ) {$lineCount++; next; }
        #Policy of Real Service remove Q-Balancer
        #if ( $class->{source} eq 'localhost') { next; }
        
        #===================================================================      
        # prepare key of Policy
        #my $rulekey=$class->{source}.$class->{service}.':'.$class->{direction}.$class->{destination}.':'.$class->{table};
        #luke 1008
        #20101224 add schedule
        #my $rulekey=$class->{source}.$class->{service}.':'.$class->{direction}.$class->{destination};
        my $rulekey=$class->{source}.$class->{service}.':'.$class->{direction}.$class->{destination}.$class->{schedule};
        my $checkrulekey=$class->{source}.':'.$class->{service}.':'.$class->{direction}.':'.$class->{destination}.':'.$class->{method}.':'.$class->{table};
        
        #===================================================================      
        # prepare display color
        my ( $originalColor, $bgcolor ); $originalColor=$bgcolor=($lineCount%2) ? ( '#556677' ) : ( '#334455' );
        if ( $class->{dirty} ) { $originalColor=$bgcolor='#bb6600' }; 

        print qq (<tr bgcolor="$bgcolor" originalColor="$originalColor" onmouseover="focusedColor(this)" onmouseout="blurColor(this)">);
        
#=cut # Gary hide on/off policy 20140319
        # Gary 20140220 add enabled/disabled function
        if ( $action{viewpoint} eq 'nat' )
        {
            #my $update_or_not=(`/usr/local/apache/qb/setuid/run diff /usr/local/apache/active/iniroute.xml /usr/local/apache/qbconf/iniroute.xml`)?'disabled':'';
            my $update_or_not;
            print qq (<td align="center" style="width:$titleWidth{Enabled}" >);
            my $status=($class->{enabled} eq '0')?'':'checked';
            print qq (<input type="checkbox" $status name="enabled_policy" $update_or_not id="enabled_policy" style="" value="$checkrulekey" onClick="enabled_disabled_policy(this.value,this.checked);"></td>);
        }
#=cut
        #===================================================================      
        if ( $viewpoint eq 'dmz' &&  $class->{source} ne 'system' && !exists($source2isp{$class->{source}}) ) 
        {
            print qq (<td align="center" bgcolor="#aa3311" style="width:$titleWidth{Source} !important">$class->{source} [OBS]</td>);
        }
        else
        {
            my $display=( $class->{source} eq 'system' ) ? ('*') : ( $class->{source} );
            $display=~s/localhost/Q-Balancer/g;
            $display=~s/host-//g;
            my $addresslist=maintainHost( action=>'GETADDRESSLIST', hostname=>$display);
            print qq (<td align="center" style="width:$titleWidth{Source} !important" onmousedown="showHostInfo('$display','$addresslist')" onmouseout="hideHostInfo()">$display</td>);
			$quotaSource=$class->{source};
        }

        #===================================================================      
        my $display=( $class->{destination} eq 'system' ) ? ('Anywhere') : ( $class->{destination} );
        #20101228
        $display =~ s/host-//g;
        my $addresslist=maintainHost( action=>'GETADDRESSLIST', hostname=>$display);
        #print qq (<td class="body"  align="center" width="$titleWidth{Destination}">$display</td>);
        print qq (<td align="center" style="width:$titleWidth{Destination} !important" onmousedown="showHostInfo('$display','$addresslist')" onmouseout="hideHostInfo()">$display</td>);
		if($display eq 'Anywhere'){$quotaDest='0.0.0.0/0';}
		else{$quotaDest=$class->{destination};}
        my $service=$class->{service};
        #$service=~s/sergobj-//g;
        #===================================================================      
        my $display=$class->{service};
        if ( $viewpoint eq 'nat' || $viewpoint eq 'lvs' )
        {
            #my $display=( $class->{service} eq 'system' ) ? ('*') : ( $class->{service} );
            $display=( $display eq 'others' ) ? ( 'ANY' ) : ( $display );
            $display.=':'.$class->{direction};
            $display=~s/:s$/(RPLY)/g; $display=~s/:d$/(RQST)/g;
        }
        print qq (<td align="center" style="width:$titleWidth{Service} !important" onmousedown="showServiceInfo('$service')" onmouseout="hideServiceInfo()">$display</td>);
     
        print qq (<td style="width:$titleWidth{Schedule} !important" align="center">);
        my $showschedule=( $class->{schedule} eq '' ) ? ( 'All Week' ) : $class->{schedule};
        #print qq (<span title="" style="width:$titleWidth{Schedule}">$showschedule</span>);
        print qq ($showschedule);
        print qq (</td>);

        #===================================================================
        #檢查原本走的 Routing Table 是否不能再走了
        my $usable_table_list=$POLICY_USABLE_TABLES{$checkrulekey};
        my $table_obs=1;

        $table_obs=!grep(/^$class->{table}$/, @$usable_table_list );
        
        #my  $showtable=presentTable($class->{table});
        
	#viewpoint app  
        if ( $table_obs && $action{viewpoint} eq 'nat' ) { $showtable.='[OBS]'};
        my $fontColor=( $table_obs && $action{viewpoint} eq 'nat' ) ? ( "#aaffff") : ( "#ffffff" ); 
        my $errColor=( $table_obs && $action{viewpoint} eq 'nat' ) ? ('#aa3311') : ('');
        print qq (<td align="center" bgcolor="$errColor" style="width:$titleWidth{Pool} !important" onmousedown="showTableInfo('$class->{table}')" onmouseout="hideTableInfo()">);
        #print qq (<font color="$fontColor">$showtable</font>);
		if($action{viewpoint} eq 'app' && $showtable[$lineCount] eq 'DROP')
		{
			print qq (<font color="$fontColor">Deny</font>);
		}
		else
		{
			print qq (<font color="$fontColor">$showtable[$lineCount]</font>);
		}
        print qq (</td>);
        
        #===================================================================
        my $siplist=$class->{sip};
        my $natinfo='';
		if($action{viewpoint} eq 'app'){print qq (<td align="center" style="display:none; width:$titleWidth{'NAT Status'} !important">);}
        else{print qq (<td align="center" style="width:$titleWidth{'NAT Status'} !important">);}
        
        if ( $action{viewpoint} eq 'lvs' )                  { print "No NAT"; }
        elsif( $class->{method} eq 'none' )                 { print "No NAT"; }
        elsif( $class->{method} eq 'ls' && @$siplist==0 )   { print "Smart NAT";  }
        else    
        {
            if      ( $class->{method} eq 'ss' )     { $natinfo.="--- Single Source ---"."\n";   }
            elsif   ( $class->{method} eq 'ms' )     { $natinfo.="--- Multi-Source ---"."\n";    }
            elsif   ( $class->{method} eq 'ls' )     { $natinfo.="--- Manual NAT ---"."\n";         }

            foreach my $sip ( @$siplist ) 
            { 
                my $ispexist=(grep(/^$sip->{isp}$/, @ispidlist )) ? 1:0;
                my @natip=split(/,/, $sip->{ip}); 
                foreach my $ip ( @natip )
                {
                    my $message='ISP'.$sip->{isp}."[ $ip ]";
                    if ( !$ispexist ) { $message.="OBS"; }
                    else
                    {
                        # %isppubip is a data structure designed to be loaded on demand
                        my $nownatips;
                        if ( !exists($isppubip{$sip->{isp}}) )
                        {
                            my @pubips=maintainIPBank(action=>'READPUBLICIP', isp=>$sip->{isp});
                            $isppubip{$sip->{isp}}=\@pubips;
                        }
                        
                        my $nownatips=$isppubip{$sip->{isp}};
                        my $ipobs=(!grep(/^$ip$/, @$nownatips))? 1:0;
                        $message.=($ipobs) ? ("OBS") : ('');
                    }
                    
                    $natinfo.=$message."\n";          
                }
            }
            
            if ( $class->{method} eq 'ss' )     { print qq (<span title="$natinfo">- Single Source -</span>);   }
            elsif ( $class->{method} eq 'ms' )  { print qq (<span title="$natinfo">- Multi-Source -</span>);    }
            elsif ( $class->{method} eq 'ls' )  { print qq (<span title="$natinfo">- Manual NAT -</span>);         }
        }
        print qq (</td>);


        #===================================================================      
        my $imgSrc=( $class->{dirty} ) ? ( '/image/alert.gif' ) : ( '/image/ok.gif' );
        print qq (<td align="center" style="width:$titleWidth{Status} !important"><image src="$imgSrc" border="0"></td>);
        
        #Gary 20130904 hide QoS
        if ( $action{showqos} eq '1' )
        {
            my $showqos=($class->{qos} eq '') ? ( 'None' ) : ( $class->{qos} );
            print qq (<td align="center" bgcolor="$errColor" style="width:$titleWidth{QoS} !important" onmousedown="" onmouseout="">);
			#======20131129-JianYu_Qos_Default_view=========================
			my $dfqos = $showqos;
			$dfqos=~s/Pool\d+/Default/;
			#===============================================================
            print qq (<font color="$fontColor">$dfqos</font>);
            print qq (</td>);
        }
        #===================================================================   

		#===================================================================   
		#Quota View
		if($action{viewpoint} eq 'nat' && $action{showqos} eq '1')
		{
			my $quotaref=XMLread($gPATH.'quota.xml');
			my $quotalist=$quotaref->{quota};
			my $max = 'N/A';
			foreach my $quota (@$quotalist)
			{
				if ($quota->{gateway} eq "system"){next;}
				if($quota->{source} eq $quotaSource && $quota->{dest} eq $quotaDest)
				{
					if ($quota->{up})
					{
						my ($num,$oo)=split(":",$quota->{up});
						if ($oo eq "1024"){$maxup = $num."KB";}
						if ($oo eq "1048576"){$maxup = $num."MB";}
						if ($oo eq "1073741824"){$maxup = $num."GB";}
						if ($oo eq "1099511627776"){$maxup = $num."TB";}
					}
					if ($quota->{down})
					{ 
						my ($num,$oo)=split(":",$quota->{down});
						if ($oo eq "1024"){$maxdown = $num."KB";}
						if ($oo eq "1048576"){$maxdown = $num."MB";}
						if ($oo eq "1073741824"){$maxdown = $num."GB";}
						if ($oo eq "1099511627776"){$maxdown = $num."TB";}
					}
					if ($quota->{bs} eq '1')
					{
						$max = $maxdown;
					}
					else
					{
						$max = $maxdown.'/'.$maxup;
					}
				}
			}
			print qq (<td align="center" style="width:$titleWidth{'Quota D/U'} !important">$max</td>);
		}
		#===================================================================   
        #my $key_for_shortcut=$viewpoint.'&'.$class->{isp}.'&'.$class->{source}.'&'. $class->{service}.':'.$class->{direction}.'&'.$class->{advance}.'&'.$class->{destination}.'&'.$class->{table};
        my $key_for_shortcut=$viewpoint.'&'.$class->{isp}.'&'.$class->{source}.'&'. $class->{service}.':'.$class->{direction}.'&'.$class->{advance}.'&'.$class->{destination}.'&'.$class->{table}.'&'.$class->{schedule}.'&'.$action{showqos};
        print qq (<td align="center" style="width:$titleWidth{Edit} !important">);
        #print qq (<a href="javascript:edit_this_rule('$key_for_shortcut','$rulekey');selectedColor(ruleList.rows[$lineCount])" ><image src="image/edit.gif" title="Edit rule properties" border="0"></a></td>);
        print qq (<a href="javascript:edit_this_rule('$key_for_shortcut','$rulekey');selectedColor(ruleList.rows[$lineCount])" ><image src="image/edit.gif" title="Edit rule properties" border="0"></a></td>);
        
        
        #===================================================================      
        #print checkbox and set its value
        print qq (<td style="width:50" align="center">);
        print qq (<input type="checkbox" name="rule" value="$rulekey">);
        print qq (</td>);

        print qq (</tr>\n);
     
        if ( $rulekey eq $action{keyofrule} ) { print qq (<script>initSelect(ruleList.rows[$lineCount]);</script>); }
        
        $lineCount++;
    }
    print qq (</table>);
    print qq (</div>);
}
#list_ini_rule


#==============================================================================================================
sub list_ini_rule_script 
{
    print << "LIST_INI_RULE_SCRIPT";
    
    <div id="ServiceDiv" class="infodiv"></div>
    <div id="TableDiv" class="infodiv"></div>
   
    <div id="HostDiv" class="infodiv"></div>

    <script type="text/javascript" src="grid.js"></script>
    
    <script language="javascript">
    
    var myform;
    function change()
    {
        var tmp = document.getElementById('source');
        var name =tmp.value;
        alert(name);
    
    }
    
    function cgi_dep_onload() 
    { 
        myform=window.document.forms[0];
        setTimeout("informProute()",500);
    }
    
    function sortPolicy(key)
    {
        myform.sortingkey.value=key;
        myform.submit();
    }    
    
    function delPolicy()
    {
        if (!myform.rule) return;
        var setDeleteOn=false;
        if ( !myform.rule.length ) setDeleteOn=myform.rule.checked;
        for(var i=0;i<myform.rule.length;i++) { if (myform.rule[i].checked) { setDeleteOn=true; break; } }
        if (!setDeleteOn) { alert("There is No Policy Rule Checked"); }
        if (setDeleteOn) { if ( qbConfirm(2, 'Confirm Deletion ?') == 1 )  { goSubmit('DELRULES');} }
    }
    
    function informProute()
    {
        var action=myform.action.value;
        if ( action=="DELRULES" )
        {
            window.top.mainFrame.iniroute.document.forms[0].action.value="UPDATEINTERFACE";        
            window.top.mainFrame.iniroute.document.forms[0].submit();
        }          
    }
    
    function enabled_disabled_policy(checkKey,enabled_or_not)
    {
    	var params=checkKey.split(':');
    	if ( enabled_or_not ) enabled_or_not='1';
    	else enabled_or_not='0';
    	if ( checkKey == "SelectAll" ) { enabled_or_not=checkKey+":"+enabled_or_not; }
    	i=(new Date()).getTime();
    	if (window.XMLHttpRequest) {
    	    queryReqHandler=new XMLHttpRequest();
    	}
    	if (window.ActiveXObject) {
    	    queryReqHandler = new ActiveXObject("Microsoft.XMLHTTP");
    	}
    	queryReqHandler.open("GET","enable_disable_policy.cgi?a="+i+"&source="+params[0]+"&service="+params[1]+"&direction="+params[2]+"&destination="+params[3]+"&method="+params[4]+"&table="+params[5]+"&enabled_or_not="+enabled_or_not,true);
    	queryReqHandler.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
    	var str='';
    	queryReqHandler.send(str);
    }
    
    function AlertApply()
    {
	if ( qbConfirm(2, 'Activate all choice ?') == 1 )  { goSubmit('ACTIVATE_ON_OFF');}
    }
    
    function edit_this_rule(rule_key_to_edit, focusedrule)
    {
        document.editpruleform.focusedrule.value=focusedrule;
        var from=document.editpruleform.viewpoint.value;
		var viewpoint=myform.viewpoint.value;
        var qstring='';
        var params=rule_key_to_edit.split('&'); 
        qstring+='iniroute.cgi?';
        qstring+='viewpoint'+'='+params[0]+'&';
        qstring+='isp'+'='+params[1]+'&';
        qstring+='source'+'='+params[2]+'&';
        qstring+='service'+'='+params[3]+'&';
        qstring+='advance'+'='+params[4]+'&';
        qstring+='dest'+'='+params[5]+'&';
        qstring+='table'+'='+params[6]+'&';
        //add schedule
        qstring+='schedule'+'='+params[7]+'&';
		qstring+='showqos'+'='+params[8]+'&';
		if(viewpoint=='lvs')
		{
			window.top.mainFrame.mainframe.iniroute.location.href=qstring;
		}
		else
		{
			window.top.mainFrame.iniroute.location.href=qstring;
		}
    }
    
    function showHostInfo(name, addresslist)
    {
        //if(!name ) { return; }
        if ( addresslist == '' )
        {
            addresslist = (name == 'Anywhere') ? ('0.0.0.0/0') : (name);    
        }
        
        HostDiv.innerText="<table class=infodivtable><tr><td>"+"Host Name:" + name + "</td></tr>";
        HostDiv.innerText += "<tr><td>Address Detail:" + addresslist + "</td></tr>";
        
        with(HostDiv)
        {
            innerText+="</table>";
            innerHTML=innerText;
            style.pixelLeft = document.body.scrollLeft;
            style.pixelTop = document.body.scrollTop; 
			style.left= '30px';
			style.top= '20px';
            style.display="block";
        }
    }

    function showServiceInfo(service)
    {
        var pattern=/\\.|\\*|system|others|\\:d|\\:s|\\:/g; 
        service=service.replace(pattern,'');
        if(!service) { return; }
        var service=eval(service);
        
        ServiceDiv.innerText="<table class=infodivtable><tr><td>"+"Service Name:"+service.info[1]+"</td><td>"+"Type:"+service.info[0]+"</td></tr>";
        
        //if ( service.info[0] != 'group' )    
        //{
        with(service)
        for(count=0;count<port.length;count++)
        {
            //Brian for layer7
            if(service.info[0]=="layer7")
            {
              ServiceDiv.innerText+="<tr><td>Protocol:"+port[count].protocol+"</td><td>Info:"+port[count].port+"</td></tr>";
            }
            else
            { 
	    ServiceDiv.innerText+="<tr><td>Protocol:"+port[count].protocol+"</td><td>Port:"+port[count].port+"</td></tr>";
            }
        }
        //}
        
        with(ServiceDiv)
        {
            innerText+="</table>";
            innerHTML=innerText;
            style.pixelLeft = document.body.scrollLeft;
            style.pixelTop = document.body.scrollTop; 
			style.left= '30px';
			style.top= '20px';
            style.display="block";
        }
    }
   
    function showTableInfo(Table)
    {
        if(Table=='$gDROP' || Table=='$gALLPATH' || Table=='$gRRG' || !Table ) { return; } 
        
        var table=eval('T'+Table); 
        
        with(TableDiv)
        {
            innerText="<table class=infodivtable><tr><td>"+"Pool ID:"+Table+"</td><td>";
            //20100223 Brian To show the note of the pool
            innerText+="<td>Pool Name:"+table.I[4]+"</td><td>";
            innerText+="<td>By Packet:"+table.I[0]+"</td><td>";
            innerText+="<td>Mode:"+table.I[1]+"</td><td>";
            innerText+="<td>Truely Aggregate:"+table.I[2]+"</td><td>";
            innerText+="<td>Redirect Host:"+table.I[3]+"</td></tr>";
        }
            
        with(eval('T'+Table))
        for(count=0;count<P.length;count++)
        {
	    TableDiv.innerText+="<tr><td>ISP ID:"+P[count].a+"</td><td>Name:"+P[count].b+"</td><td>Weight:"+P[count].c+"</td><td>DSIP:"+P[count].d+"</td></tr>";
        }
        
        with(TableDiv)
        {
            innerText+="</table>";
            innerHTML=innerText;
            style.pixelLeft = document.body.scrollLeft;
            style.pixelTop = document.body.scrollTop; 
			style.left= '30px';
			style.top= '20px';
            style.display="block";
        }
    }

    function hideTableInfo(){TableDiv.style.display="none";}
    function hideServiceInfo(){ServiceDiv.style.display="none";}
    function hideHostInfo(){HostDiv.style.display="none";}
    
  </script>
    
LIST_INI_RULE_SCRIPT
}
#list_ini_rule_script

#==============================================================================================================
sub show_iniroute 
{
    my (%action)=@_;
    my $fwmark=XMLread($gPATH."fwmark.xml");
    my $fwviewpoint=( $action{viewpoint} eq 'app') ? ( 'nat' ) : ( $action{viewpoint} );
    my $temp=$fwmark->{$fwviewpoint}->[0]->{mark};
    #my $temp=$fwmark->{$action{viewpoint}}->[0]->{mark};
    my $hostref=XMLread($gPATH."host.xml");
    my $hostlist=$hostref->{host};
    my $service=XMLread($gPATH.'service.xml');
    my $servicelist=$service->{service};
    my @hosobj;
    my @destarray;
    
    my $iniroute=XMLread( $gPATH.'iniroute.xml');
    if ( $action{viewpoint} eq 'app' )
    {
        my $temp=$iniroute->{app};
        if ( !$temp )
        {
            runCommand(command=>'/usr/local/apache/qb/setuid/do_qbaddapp.pl', params=>'');
        }
    }
    
    foreach my $host ( @$hostlist )
    {
        if ($host->{hostname} eq 'system' ) { next; }
    	if ($host->{hosttype} ne 'fqdnlist' && $host->{hosttype} ne 'weburl' )
    	{
            push(@hostobj, $host->{hostname});   
        }
        if ($host->{hosttype} ne 'weburl')
        {
            push(@destarray,  $host->{hostname});
        }
    }
    
    #如果是變換視角，就清除介面傳下來的查詢條件參數
    if ( $action{action}=~m/^SWITCHVIEWPOINT$/ ) 
    {
        $action{isp}='';
        $action{source}='';
        $action{service}='';
        $action{advance}='0';
        $action{destination}='';
    }
    elsif ( $action{action}=~m/^SWITCHISP$/ ) 
    {
        $action{source}='';
        $action{service}='';
        $action{advance}='0';
        $action{destination}='';
    }
    elsif ( $action{action}=~m/^SWITCHSOURCE$/ )
    {
        $action{service}='';
        $action{advnace}='0';
        $action{destination}='';
    }
    
    print qq (<table border="0" width="100%" cellspacing="0" cellpadding="0">);
    
    #**************************************************************************************
    # 1. ViewPoint
    #**************************************************************************************
    print qq (<input name="viewpoint" type="hidden" value="$action{viewpoint}">);
    print qq (<input name="showqos" type="hidden" value="$action{showqos}">);
    
    
    #**************************************************************************************
    # 2.1 lvs or nat -> source
    #**************************** list nat->source(s) or lvs->source(s) ****************************
    if ( $action{viewpoint}=~m/^nat$|^lvs$|^app$/ ) 
    {
        #**************************** list nat->source(s) ****************************
        my %source;

        foreach my $mark ( @$temp ) { if ( $mark->{source_type} eq '' ) { $source{ $mark->{source} }=1; } }
        #foreach my $mark ( @$temp ) 
        #{ 
        #    #Policy of Real Service remove Q-Balancer
        #    if ( $action{viewpoint} =~m/^lvs$/ && $mark->{source} eq "localhost" ) { next; }
        #    $source{ $mark->{source} }=1; 
        #}  
        if ( $action{viewpoint} eq "nat" || $action{viewpoint} eq 'app' ) { $source{'0.0.0.0/0'}=1; }

        my @allsources=sort subnet_sort keys %source;
        #show host object
        push(@allsources, @hostobj);
        
        if ( !$action{source} ) { $action{source}=$allsources[0]; }
        
        print qq (<td class="body" colspan="8" valign="top" align="center" >);
        print qq (<select class="qbopt" size="1" name="source"  style="WIDTH:130">);
        foreach my $sourceitem ( @allsources ) 
        { 
            if ( $sourceitem eq "system" ) { next; }
            my $status=( $action{source} eq $sourceitem ) ? ( 'selected' ):( '' ); 
            my $displaysource=( $sourceitem eq "localhost" ) ? ('Q-Balancer') : ($sourceitem) ;
            $displaysource=~s/host-//g;
            my $addresslist=maintainHost( action=>'GETADDRESSLIST', hostname=>$displaysource);
            print qq (<option value="$sourceitem" title="$addresslist" $status>$displaysource</option>); 
        }
        print qq (</select><br>Source</td>); 
    }

    #**************************************************************************************
    # 2.2 dmz->source
    #**************************************************************************************
    if ( $action{viewpoint}=~m/^dmz$/ ) 
    {
        #**************************** list isp id(s) ************************************
        my %isphash=maintainBasic( action=>'GETNORMALISPNAMEHASH' );
        my @iidlist=sort keys %isphash;
        if ( !$action{isp} ) { $action{isp}=$iidlist[0]; }
        
        print qq (<tr>);
        print qq (<td class="body"  colspan="8" valign="top" align="center" >);
        print qq (DMZ Zone:<select class="qbopt" size="1" name="isp" onChange="goSubmit('SWITCHISP');" style="WIDTH: 200">);
        foreach my $ispitem ( @iidlist ) 
        {
            my $status=( $action{isp} eq $ispitem ) ? ( 'selected' ):( '' ); 
            print qq (<option value="$ispitem" $status>$isphash{$ispitem} [ ISP $ispitem ]</option>); 
        }    
        print qq (</select><hr size="1"></td>);
        print qq (</tr>);
        
        
        print qq (<tr>);
        
        #**************************** list dmz(isp)->source(s) ****************************
        my %source;
        foreach my $mark ( @$temp ) 
        {
            if ( $mark->{dirty} ) { next; } 
            if ( $action{isp} ne maintainBasic( action=>'GETBELONGIID', subnet=>$mark->{source} ) ) { next; }
            $source{ $mark->{source} }=1; 
        }
        
        my @allsources=keys(%source);
        if ( !$action{source} ) { $action{source}=$allsources[0]; }
              
        print qq (<td class="body"  valign="top" align="center" >);
        print qq (<select class="qbopt" size="1" name="source" onChange="goSubmit('SWITCHSOURCE')" style="WIDTH:130">);
        foreach my $sourceitem ( sort subnet_sort @allsources ) 
        { 
            my $status=( $action{source} eq $sourceitem ) ? ( 'selected' ) : ( '' ); 
            print qq (<option $status value="$sourceitem" >$sourceitem</option>);
        }
        print qq (</select><br>Source</td>);
    }
=cut
    #****** judge if it is in advance mode *******************************  
    if ( !$action{advance} ) { $action{destination}='system'; }
    
    #*********************************************************************
    my @destarray=maintainOverview(action=>'GETDESTINATION');
    
    my $event=( @destarray > 0 ) ? ( 'onChange' ) : ( 'onClick' );
    
    my $status=( $action{advance} ) ? ('checked') : ('');

    print qq (<td class="body" valign="top" align="center">);
    print qq (<select class="qbopt" size="1" name="dest" disabled $event="dest_on_change()" style="width:120">);
    foreach my $dest ( sort @destarray ) 
    {
      
        my $status=( $action{destination} eq $dest ) ? ( 'selected' ):( '' ); 
        ( $dest eq 'edit' ) ? ( print qq (<option $status value="$dest">-- Edit --</option>) ) : ( print qq (<option $status value="$dest">$dest</option>) ); 
    }
    print qq (<option value="edit">-- Edit --</option>);
    print qq (</select><br>);
    print qq (<input type="checkbox" name="advance" $status onClick="advance_action()">);
    print qq (Destination);
    print qq (</td>);
=cut
    #*********************************************************************
    print qq (<td class="body" valign="top" align="center">);
    print qq (<select class="qbopt" size="1" name="dest"  style="width:120">);
    my $status=( $action{destination} eq $dest ) ? ( 'selected' ):( '' ); 
    print qq (<option $status value="system">0.0.0.0/0</option>);
    foreach my $dest ( sort @destarray ) 
    {
    	my $showdest = $dest; 
        my $status=( $action{destination} eq $dest ) ? ( 'selected' ):( '' ); 
        $showdest =~ s/host-//g;
        my $addresslist=maintainHost( action=>'GETADDRESSLIST', hostname=>$showdest);
        if ($addresslist =~ m/([a-fA-F0-9]{2}):([a-fA-F0-9]{2}):([a-fA-F0-9]{2}):([a-fA-F0-9]{2}):([a-fA-F0-9]{2}):([a-fA-F0-9]{2})/){next;}
        print qq (<option value="$dest" title="$addresslist" $status>$showdest</option>); 
        #print qq (<option $status value="$dest">$showdest</option>);
    }
    my @destarray=maintainOverview(action=>'GETDESTINATION');
    foreach my $dest ( sort @destarray )
    {
        my $status=( $action{destination} eq $dest ) ? ( 'selected' ):( '' );
        print qq (<option $status value="$dest">$dest</option>);
    }
    print qq (</select><br>);
    print qq (Destination);
    print qq (</td>);
    #20101228 
    $action{advance} = ( $action{destination} eq 'system' ) ? ( '0' ) : ( '1' );
    
    #**************************************************************************************
    # 3.1  dmz | nat | lvs -> service(s)
    #**************************************************************************************
    if ( $action{viewpoint}=~m/dmz|nat|lvs/ ) 
    { 
        #**************************** list *->source->service(s)  ****************************
        
        print qq (<td class="body"  valign="top" align="center" >);
        print qq (<select class="qbopt" size="1" name="service" onchange="" style="WIDTH:100;">);
        my $status=( $action{service} eq "others:d" ) ? ( 'selected' ) : ( '' ); 
        print qq (<option $status value="others:d">ANY(RQST)</option>); 
        my $status=( $action{service} eq "others:s") ? ( 'selected' ) : ( '' ); 
        print qq (<option $status value="others:s">ANY(RPLY)</option>); 
	
        foreach my $service (  @$servicelist ) 
        { 
            #if ( $service->{type} ne 'qb' && $service->{type} ne 'layer7' && $service->{type} ne 'system' )
            if ( $service->{type} eq 'known' || $service->{type} eq 'user' || $service->{type} eq 'qb')
            {
                my $status=( $action{service}=~m/^$service->{title}:d$/) ? ( 'selected' ) : ( '' ); 
                print qq (<option $status value="$service->{title}:d">$service->{title}(RQST)</option>); 
                my $status=( $action{service}=~m/^$service->{title}:s$/) ? ( 'selected' ) : ( '' ); 
                print qq (<option $status value="$service->{title}:s">$service->{title}(RPLY)</option>); 
            }
        }
	my $serg=XMLread($gPATH.'sergroup.xml');
	my $serglist=$serg->{sergroup};
        foreach my $serg ( @$serglist )
        { 
            if ( $serg->{sergroup} eq 'system' ) { next; }
            my $status=( $action{service}=~m/^$serg->{sergroup}:d$/ ) ? ( 'selected' ) : ( '' ); 
            print qq (<option $status value="$serg->{sergroup}:d">$serg->{sergroup}(RQST)</option>); 
            my $status=( $action{service}=~m/^$serg->{sergroup}:s$/ ) ? ( 'selected' ) : ( '' ); 
            print qq (<option $status value="$serg->{sergroup}:s">$serg->{sergroup}(RPLY)</option>); 
        }
	
        print qq (</select><br><input type="button" class="qb" value="Service" title="Display detail Info. of selected Service" style="width:100" onmousedown="popUpServiceInfo()" onmouseout="hideServiceInfo()">);
        print qq (</td>);
    }
    elsif ( $action{viewpoint}=~m/app/ ) 
    {
        use File::Find;
        find( { wanted => sub { push(@FileList, $_) }, no_chdir => 1 },'/usr/local/apache/qbconf/l7-object/' );   
        print qq (<td class="body"  valign="top" align="center" >);
        print qq (<select class="qbopt" size="1" name="service" onchange="" value="" style="WIDTH:100;">);
   ####### Gary 2014 0418 for 南藝大標案
        print qq (<option $status value="GoogleBooks">Google Books</option>);
        print qq (<option $status value="GoogleAnalytics">Google Analytics</option>);
        print qq (<option $status value="GoogleCalendar">Google Calendar</option>);
        print qq (<option $status value="GooglePicasa">Google Picasa</option>);
        print qq (<option $status value="GoogleChrome">Google Chrome</option>);
        print qq (<option $status value="GooglePLAY">Google PLAY</option>);
        print qq (<option $status value="Evernote">Evernote</option>);
        print qq (<option $status value="RSS">RSS</option>);

        print qq (<option $status value=""></option>);
        print qq (<option $status value="Niconico">NIconico</option>);
        print qq (<option $status value="NextTV">NextTV</option>);
        print qq (<option $status value="Youtube">Youtube</option>);
        print qq (<option $status value="HiChannel">HiChannel</option>);

        print qq (<option $status value=""></option>);
        print qq (<option $status value="JustinTV">JustinTV</option>);
        print qq (<option $status value="PPStream">PPStream</option>);
        print qq (<option $status value="Qvod">Qvod</option>);
        print qq (<option $status value="BaiduVideo">BaiduVideo</option>);
        print qq (<option $status value="TeamViewer">TeamViewer</option>);
        print qq (<option $status value="GoToMeeting">GoToMeeting</option>);
        print qq (<option $status value=""></option>);

   ####### 2014 0418 end
   
        $action{service}=~s/:d//g;
        $action{service}=~s/:s//g;
        foreach my $service (  @$servicelist ) 
        { 
            if ( $service->{type} eq 'layer7group' )
            {
                my $status=( $action{service}=~m/^$service->{title}$/) ? ( 'selected' ) : ( '' ); 
                print qq (<option $status value="$service->{title}">$service->{title}</option>); 
            }
        }
        
        foreach my $service1 ( @FileList )
        {
           if (!grep(/\.pat/,$service1)){next;}
           $service1 =~ s/\/usr\/local\/apache\/qbconf\/l7-object\///g;
           $service1 =~ s/_UD//g;
		   $service1 =~ s/\.pat//g;
           my $status=( $action{service}=~m/^$service1$/) ? ( 'selected' ) : ( '' );
           print qq (<option $status value="$service1">$service1</option>);
        }
		
		#print qq (<option $status value="">---User_Definition---</option>);
		print qq (<option $status value=""></option>);
        print qq (</select><br><input type="button" class="qb" value="Application" title="Display detail Info. of selected Service" style="width:100" onmousedown="popUpServiceInfo()" onmouseout="hideServiceInfo()">);
        print qq (</td>);
    }
    
    #**************************************************************************************
    # 3.2 lvs -> belongisp(s)
    #**************************** list lvs->source->belongisp(s)****************************
    if ( $action{viewpoint}=~m/^lvs$/ ) 
    {
        my %ispname=maintainBasic(action=>'GETISPNAMEHASH');
        my @belong_isp_list=maintainVS( action=>"GETBELONGISPNUM", service=>$action{service}, rserver=>$action{source} );
        print qq (<span id="obj" class="prompt">);
        print qq (This Virtual Server belongs to:<br>);
        foreach my $belong_isp ( @belong_isp_list ) { print qq ($ispname{$belong_isp} [ ISP $belong_isp ]<br>); }
        print qq (</span>);
    }
    
    #*********************************************************************
    init_class_show(%action);
    
}
#show_iniroute

#=============================================================================
sub init_class_show 
{
    (%action)=@_;
    my $iniroute=XMLread( $gPATH.'iniroute.xml');
    my $schref=XMLread($gPATH.'schedule.xml');
    my $schlist=$schref->{schedule};
    my $qosref=XMLread($gPATH.'qos.xml');
    my $qoslist=$qosref->{qos};
    
    my $target;
    my %desthash;
    
    
    $temp=$iniroute->{$action{viewpoint}}->[0]->{class};
    #**************************** search key: ( source x service x direction x destination x table ) in iniroute in certern ViewPoint *****
    #比對介面傳達的搜尋條件，找出符合條件的 policy rule，若有，則將它show出來
    
    my $target_exist=0;

    if ( $action{viewpoint} eq 'app' )
    {
        $action{service}=~s/:d//g;
        $action{service}=~s/:s//g;
    	foreach my $item ( @$temp ) 
        { 
            #20101227 add schedule
            if ( $item->{source}.$item->{service}.$item->{destination}.':'.$item->{table}.$item->{schedule}  ne $action{source}.$action{service}.$action{destination}.':'.$action{table}.$action{schedule} ) { next; }
            $target_exist=1;
            $target=$item; 
            last; 
        }
    }
    else
    {
    	foreach my $item ( @$temp ) 
        { 
            if ( $item->{source}.$item->{service}.':'.$item->{direction}.$item->{destination}.':'.$item->{table}.$item->{schedule}  ne $action{source}.$action{service}.$action{destination}.':'.$action{table}.$action{schedule} ) { next; }
            $target_exist=1;
            $target=$item; 
            last; 
        }
    }

    #**************************** show schedule list ******************************************
    print qq (<td class="body"  valign="top" align="center" >);
    print qq (<select class="qbopt" size="1" name="schedule" style="width:80">);
    
    #my @seqarray=timesegarray2seqarray( $target->{time} );    
    
    #if ( @seqarray <= 0 ) { @seqarray=(1..144); }

    print qq (<option value="All Week" $status>All Week</option>); 
    foreach my $seq ( @$schlist ) 
    { 
        if ( $seq->{schname} eq "system" ) { next; }
        #my $status=( grep(/^$seq$/,@seqarray) ) ? ( 'selected' ) : ( '' );
        #my $section=timeseq2section( $seq );
        my $status=( $target->{schedule} eq $seq->{schname} ) ? ( 'selected' ) : ( '' );
        print qq (<option $status value="$seq->{schname}" $status>$seq->{schname}</option>); 
    }
    #foreach my $seq ( 1..144 ) 
    #{ 
    #    my $status=( grep(/^$seq$/,@seqarray) ) ? ( 'selected' ) : ( '' );
    #    my $section=timeseq2section( $seq );
    #    print qq (<option value="$seq" $status>$section</option>); 
    #}
    print qq (</select><br>);
    #print qq (<input type="button" name="ALLSCHEDULE" class="qb" value="A" title="Select All" onclick="allSchedule()"   style=" height:20 width:20">);
    #print qq (<input type="button" name="EXPANDSCHEDULE" class="qb" value="E" title="Expand Schedule" onclick="expandSchedule()"   style=" height:20 width:20">);
    print qq (Schedule);
    #print qq (<input type="button" name="SHRINKSCHEDULE" class="qb" value="C" title="Collapse Schedule" onclick="shrinkSchedule()" style="height:20 width:20">);
    #print qq (<input type="button" name="NONESCHEDULE" class="qb" value="N" title="Unselect All" onclick="noneSchedule()" style="height:20 width:20"><br>);
    print qq (</td>);

    #=====================================================================================    
    #  List applicable table(s) and indicate old used table 
    #  Reproduce the message hash %action to %getApplicableTableIDs, and mark the action key as 'GETAPPLICABLETABLEIDS'

    #======== keep sip list ==============================================================
    my $siplist;
    if ( $action{action} ne 'UPDATEINTERFACE' ) { $siplist=$target->{sip}; $action{sip}=$target->{sip}; }
    if ( $action{action} eq 'UPDATEINTERFACE' ) { $siplist=$action{sip}; }

    #==== keep method infomation  ========================================================
    if ( $action{action} ne 'UPDATEINTERFACE' ) { $action{method}=$target->{method}; }
    
    if      ( $action{viewpoint} eq "nat" && !$action{method} && $action{service}=~m/:s$/  )        { $action{method}='none'; }
    elsif   ( $action{viewpoint} eq "nat" && !$action{method} && $action{service}!~m/:s$/  )        { $action{method}='ls'; }
    elsif   ( $action{viewpoint} eq "app" && !$action{method} && $action{service}!~m/:s$/  )        { $action{method}='ls'; }
    elsif   ( $action{viewpoint} eq "dmz" && !$action{method} )                                     { $action{method}='none'; }
    #else { $action{method}='ls'; }
    
    if( $action{method} eq 'ls' && @$siplist > 0 )   { $action{method}="manual_ls"; }
    
    #========================================================================
    # make decision : disable or enable NAT
    my $enableNAT='';
    
    #**************** if View Point is NAT or DMZ, show System IP 
    my ( $source, $direction )=split( /:/,$action{service} );  
    if ( $action{viewpoint}=~m/^nat$|^dmz$|^app$/ )
    {
        my $ispid=findMyISP(subnet=>$action{source}); 
        if ( $ispid ) { $action{isp}=$ispid; }

        if ( $action{source} eq '0.0.0.0/0' ) 
        {
            $enableNAT='disabled';
        }
        elsif ( $action{viewpoint}=~m/^nat$/ && $action{service}=~m/:s$/ ) 
        { 
            # if this NAT source is within ISP public IP range , we should disable NAT, and deal with it as DMZ 
            $enableNAT='disabled';
        }
        elsif ( $action{viewpoint}=~m/^dmz$/ && $action{service}=~m/:s$/ ) 
        { 
            $enableNAT='disabled'; 
        }
    }

    my %getApplicableTableIDs=%action; 
    $getApplicableTableIDs{action}='GETAPPLICABLETABLEIDS';  
    my @tablelist;
    
    if ( $action{viewpoint} eq 'app' )
    {
        my $temp = $action{method};
       
        @tablelist=maintainRtable( %getApplicableTableIDs );
        #@tablelist=maintainIniroute( action=>'GETSRCTABLE', source=>$action{source}, destination=>$action{destination} );
        $action{viewpoint} = 'app';
        $action{method} = $temp;
    }
    else
    {
        @tablelist=maintainRtable( %getApplicableTableIDs ); 
    }
    
    my $original_obsolete;
    if ( $target_exist ) { $original_obsolete=1;}
    if ( grep(/^$target->{table}$/, @tablelist) ) { $original_obsolete=0; } 
    
    print qq (<td class="body"  valign="top" align="center">);
    #print qq (<select class="qbopt" size="1" name="table" style="width:100" onChange="onoffSchedule()">);
    print qq (<select class="qbopt" size="1" name="table" id="table" style="width:100" onChange="IsDrop()">);
    
	if($action{viewpoint} eq 'app' && $action{showqos} eq '')
	{
		print qq (<option value="255">Deny</option>);
	}
	else
	{
    if ( $original_obsolete ) 
    {
        my  $showtable=presentTable($target->{table});
        print qq (<option selected value="$target->{table}">$showtable [OBS]</option>);
    }
    my @showtable = presentTables(@tablelist);
    my $index = 0;
    foreach my $tableitem ( @tablelist ) 
    {
        my  $status=( $tableitem eq $target->{table} ) ? ( 'selected' ) : ( '' ); 
 
        #my $showtable=presentTable($tableitem);

        #print qq (<option $status value="$tableitem">$showtable</option>);
        #if ($action{source}=~m/IPV6/ || $action{source}=~m/\d{1,4}:/ )
        print qq (<option $status value="$tableitem">$showtable[$index]</option>);
        $index++;
    }
	}
    print qq (</select><br>);
	if($action{viewpoint} eq 'app' && $action{showqos} eq ''){print qq (Action);}
	else
	{
    print qq (<input type="button" name="SHOWTABLEINFO" class="qb" value="Pool" title="Display detail Information of selected Routing Pool" onmousedown="popUpTableInfo()"  onmouseout="hideTableInfo()" style="width:100">);
	}
    print qq (</td>);
    
    if ( $action{viewpoint}=~m/^nat$|^dmz$|^app$/ )
    {
        #==== sip infomation  ========================================================
        #my %ispname=maintainBasic(action=>'GETISPNAMEHASH');
        my @iidlist = maintainBasic(action=>'GETGOODIIDLIST');
        my @iidlist = sort { $a <=> $b } @iidlist;
        
		if($action{viewpoint}=~m/^app$/){print qq (<td class="body" style="display:none;" valign="top" align="center" >);}
		else{print qq (<td class="body"  valign="top" align="center" >);}

        if ( !$action{sipstatus} ) { $action{sipstatus}=1; }
        
        print qq (<input type="hidden" name="sipstatus" value="$action{sipstatus}">);
        
        print qq (<select $enableNAT class="qbopt" multiple size="$action{sipstatus}" name="sip" id="sip" style="WIDTH:160"  onchange="filterTable()"> );
       
        my $ref=XMLread($gPATH.'ipbank.xml'); 
        #my $ipbanklist = $ref->{ip};
        #foreach my $ipbank ( @$ipbanklist )
        #{
        #    if ( grep(/*.dmz/, $ipbank->{name}) ) { next; }
        #}
        foreach my $iid ( @iidlist ) 
        {
            my $public=$ref->{ip}->{'isp'.$iid.'public'}->{opt};
            my $system=$ref->{ip}->{'isp'.$iid.'system'}->{opt}[0];
            my @tempip;
            foreach my $ipbank ( @$public ) 
            {
                if ( $ipbank eq $system || $ipbank eq 'system' ) { next; }
                push(@tempip, $ipbank);
            }
            push (@tempip, 'systemip');
            
            my $targetsip;
 
            foreach my $sip ( @$siplist ) { if ( $sip->{isp} eq $iid ) { $targetsip=$sip; } }

            foreach my $natip ( @tempip ) 
            { 
                my $sipip=$iid.'j'.$natip; 
                my $status=( grep(/^$natip$/, $targetsip->{ip}) ) ? ( 'selected' ) : ('');     
                print qq (<option $status value="$sipip">ISP $iid [ $natip ]</option>); 
            }
        }
=cut
        foreach my $iid ( @iidlist) 
        {
            #my @natips=maintainIPBank(action=>'READPUBLICIP', isp=>$iid);
            #my @natips=maintainIPBank(action=>'NEWREADPUBLICIP', isp=>$iid);

            my $targetsip;
 
            foreach my $sip ( @$siplist ) { if ( $sip->{isp} eq $iid ) { $targetsip=$sip; } }

            foreach my $natip ( @natips ) 
            { 
                my $sipip=$iid.'j'.$natip; 
                my $status=( grep(/^$natip$/, $targetsip->{ip}) ) ? ( 'selected' ) : ('');     
                print qq (<option $status value="$sipip">ISP $iid [ $natip ]</option>); 
            }

        }
=cut
        print qq (</select><br>);

        print qq (<input $enableNAT type="button" name="EXPANDNATIP" class="qb" value="E" title="Expand" onclick="expandNATIP()"  style=" height:20 width:20">);
        
        
        #my $byPathStatus=( $action{method} eq 'ls' ) ? ("checked") : ("");
        #print qq (<input $enableNAT type="checkbox" name="method" value="ls" $byPathStatus onClick="filterTable()">Smart NAT);
	
	if ( $gENABLETM )
	{
	    if ($action{source} =~ m/IPv6/ || $action{source} =~ m/\d{1,4}:/) {%methods=( "No NAT" => "none");}
            else{%methods=("No NAT" => "none");}
	}
	else
	{
	    if ($action{source} =~ m/IPv6/ || $action{source} =~ m/\d{1,4}:/) {%methods=( "No NAT" => "none");}
            else{%methods=("Smart NAT" => "ls", "Manual NAT" => "manual_ls", "No NAT" => "none");}
	}
        print qq (<select class="qbopt" size="1" name="method" id="method" style="WIDTH:130"  onchange="filterTable()">);
        foreach my $natkey ( sort keys %methods )
        {
            my $status=( $methods{$natkey} eq $action{method} ) ? ('selected') : ('');
            print qq ( <option $status value="$methods{$natkey}">$natkey</option>);
        }
        print qq (</select>);
        
        print qq (<input $enableNAT type="button" name="SHRINKNATIP" class="qb" value="C" title="Collapse" onclick="shrinkNATIP()"  style="height:20 width:20">);
    }
    # Gary hide QoS 20130905
    if ( $action{showqos} eq '1' )
    {
    	print qq (<td class="body"  valign="top" align="center" >);
    	print qq (<select class="qbopt" size="1" name="qos" id="qos" style="WIDTH:80"  onchange="">);
	$jsqosarray ="";$usdf = 0;
    	my $status=( $target->{qos} eq 'None' ) ? ( 'selected') : ( '' );
    	print qq (<option $status value="None">None</option>); 
    	foreach my $qos ( @$qoslist )
    	{
    	
	    if ( $qos->{qosname} eq 'system' ) { next; }
	    # if ( $qos->{pool} ne $target->{table} && $target->{table} ne "" ) { next; }
            my $status=( $qos->{qosname} eq $target->{qos} ) ? ( 'selected') : ( '' );
            print qq (<option $status value="$qos->{qosname}" id="qosid$qos->{qosname}">$qos->{qosname}</option>); 
	    if($qos->{pool} >=1)
	    {
	    	$jsqosarray.="myqos[".$usdf."]=".'"'.$qos->{pool}.','.$qos->{qosname}.'";';
	    	$usdf = $usdf+1;
	    }
    	}
    	print qq (</select><br>Qos</td>);
    }
	else
	{
		print qq (<select id="sip" name="method" style="display: none;"></select>);
		print qq (<select name="method" id="method" style="display: none;"></select>);
	}
	#**************************************************************************************
	
	my $quota = XMLread($gPATH.'quota.xml');
	my $zonelist = $quota->{quota};
	my $edit;
	my $inDST = $action{destination};
	if ($action{destination} eq 'system'){$inDST='0.0.0.0/0';}
	foreach my $myquota ( @$zonelist )
	{
	    if ( $action{isp} ne '' && $myquota->{source} eq $action{source} && $myquota->{dest} eq $inDST ) { $edit=$myquota; }
	}
	my $rn = $edit->{name};
	my ($dmit,$dbps)=split(/:/,$edit->{down});
	my ($umit,$ubps)=split(/:/,$edit->{up});
	my ($mhr,$msec)=split(/:/,$edit->{date});
	my $bs=$edit->{bs};
	my $ql=$edit->{ql};
	my $lmit=$edit->{lmit};
	
	if($action{viewpoint}=~m/^nat$/ && $action{showqos} eq '1')
	{print qq (<td class="body"  valign="top" align="center" >);}
	else
	{print qq (<td class="body" style="display:none;" valign="top" align="left" >);}
	
    	#print qq (Quota Setting:<br>);
		#print qq (<input type="button" class="qb" value="showhide" onClick="showhide()" style="height:20 width:50"><br>);
    	print qq (<input type="button" class="qb" value="Quota" onclick="quota_setting_window()" style="height:20 width:50">);
	print qq (<span id="show_quota" style="display:none;" >);
	if($rn ne ''){print qq (<input type="hidden" id="rname" style="WIDTH:100px" value="$rn"/>);}
	else{print qq (<input type="hidden" id="rname" style="WIDTH:100px" value=""/>);}
	print qq (<table border="0" class="body" >);
	print qq (<tr><td width="80">Limit Downlink at :</td>);
    	print qq (<td width="100" align="center"><input type="text" class="qbtext" id="dmit" style="WIDTH:45px" maxlength="4" value="$dmit"/>);
    	print qq (<select class="qb" id="dbps" style="WIDTH:60px" value="$dbps"><br>);
	if ($dbps eq '1024')
	{
		print qq (<option value="K" Selected>KB</option>);
		print qq (<option value="M">MB</option>);
		print qq (<option value="G">GB</option>);
		print qq (<option value="T">TB</option>);
	}
	if ($dbps eq '1048576')
	{
		print qq (<option value="K">KB</option>);
		print qq (<option value="M" Selected>MB</option>);
		print qq (<option value="G">GB</option>);
		print qq (<option value="T">TB</option>);
	}
	if ($dbps eq '1073741824')
	{
		print qq (<option value="K">KB</option>);
		print qq (<option value="M">MB</option>);
		print qq (<option value="G" Selected>GB</option>);
		print qq (<option value="T">TB</option>);
	}
	if ($dbps eq '1099511627776')
	{
		print qq (<option value="K">KB</option>);
		print qq (<option value="M">MB</option>);
		print qq (<option value="G">GB</option>);
		print qq (<option value="T" Selected>TB</option>);
	}
	if (!$dbps)
	{
		print qq (<option value="K">KB</option>);
		print qq (<option value="M" Selected>MB</option>);
		print qq (<option value="G">GB</option>);
		print qq (<option value="T">TB</option>);
	}
    print qq (</select></td></tr>);
    print qq (<tr><td>Limit Uplink at : </td>);
    print qq (<td align="center"><input type="text" class="qbtext" id="umit" style="WIDTH:45px" maxlength="4" value="$umit"/>);
    print qq (<select class="qb" id="ubps" style="WIDTH:60px" value="$ubps"><br>);
	if ($ubps eq '1024')
	{
		print qq (<option value="K" Selected>KB</option>);
		print qq (<option value="M">MB</option>);
		print qq (<option value="G">GB</option>);
		print qq (<option value="T">TB</option>);
	}
	if ($ubps eq '1048576')
	{
		print qq (<option value="K">KB</option>);
		print qq (<option value="M" Selected>MB</option>);
		print qq (<option value="G">GB</option>);
		print qq (<option value="T">TB</option>);
	}
	if ($ubps eq '1073741824')
	{
		print qq (<option value="K">KB</option>);
		print qq (<option value="M">MB</option>);
		print qq (<option value="G" Selected>GB</option>);
		print qq (<option value="T">TB</option>);
	}
	if ($ubps eq '1099511627776')
	{
		print qq (<option value="K">KB</option>);
		print qq (<option value="M">MB</option>);
		print qq (<option value="G">GB</option>);
		print qq (<option value="T" Selected>TB</option>);
	}
	if (!$ubps)
	{
		print qq (<option value="K">KB</option>);
		print qq (<option value="M" Selected>MB</option>);
		print qq (<option value="G">GB</option>);
		print qq (<option value="T">TB</option>);
	}
    # print qq (<option value="0" >None</option>);
    # print qq (<option value="K">KB</option>);
    # print qq (<option value="M">MB</option>);
    # print qq (<option value="G">GB</option>);
    # print qq (<option value="T">TB</option>);
    print qq (</select></td></tr>);
    print qq (<tr><td> Cycle : </td><td align="center"><select class="qb" id="cycle" style="WIDTH:90px" onChange="cycleChange();">);
	if ($edit->{cycle} eq '0')
	{
		print qq (<option value="0" Selected>non-cyclic</option>);
		print qq (<option value="1">Daily</option>);
		print qq (<option value="7">Weekly</option>);
		print qq (<option value="30">Monthly</option>);
	}
	elsif ($edit->{cycle} eq '1')
	{
		print qq (<option value="0">non-cyclic</option>);
		print qq (<option value="1" Selected>Daily</option>);
		print qq (<option value="7">Weekly</option>);
		print qq (<option value="30">Monthly</option>);
	}
	elsif ($edit->{cycle} eq '7')
	{
		print qq (<option value="0">non-cyclic</option>);
		print qq (<option value="1">Daily</option>);
		print qq (<option value="7" Selected>Weekly</option>);
		print qq (<option value="30">Monthly</option>);
	}
	elsif ($edit->{cycle} eq '30')
	{
		print qq (<option value="0">non-cyclic</option>);
		print qq (<option value="1">Daily</option>);
		print qq (<option value="7">Weekly</option>);
		print qq (<option value="30" Selected>Monthly</option>);
	}
	elsif (!$edit->{cycle})
	{
		print qq (<option value="0">non-cyclic</option>);
		print qq (<option value="1">Daily</option>);
		print qq (<option value="7">Weekly</option>);
		print qq (<option value="30">Monthly</option>);
	}
    # print qq (<option value="0">non-cyclic</option>);
    # print qq (<option value="1">Daily</option>);
    # print qq (<option value="7">Weekly</option>);
    # print qq (<option value="30">Monthly</option>);
    print qq (</select></td></tr>);
    print qq (<tr><td> Reset at :</td>);
    print qq (<td align="center"><select class="qb" id="hr" style="WIDTH:50px;">);
    foreach my $hr (0..23)
	{
		if($hr < 10)
		{
			$myhr = "0$hr";
			$myhr2 = "$mhr";
			if ($myhr eq $myhr2)
			{
				print qq(<option value="0$hr" Selected>0$hr</option>);
			}
			else
			{
				print qq(<option value="0$hr">0$hr</option>);
			}
		}
		if($hr > 9)
		{
			$myhr = "$hr";
			$myhr2 = "$mhr";
			if ($myhr eq $myhr2)
			{
				print qq(<option value="$hr" Selected>$hr</option>);
			}
			else
			{
				print qq(<option value="$hr">$hr</option>);
			}
		}
	}
    print qq (</select>:<select class="qb" id="sec" style="WIDTH:50px">);
    foreach my $sec (0..59)
	{
		if($sec > 9)
		{
			$mysec = "$sec";
			$mysec2 = "$msec";
			if ($mysec eq $mysec2)
			{
				print qq(<option value="$sec" Selected>$sec</option>);
			}
			else{print qq(<option value="$sec">$sec</option>);}
		}
	
		if($sec < 10)
		{
			$mysec = "0$sec";
			$mysec2 = "$msec";
			if ($mysec eq $mysec2)
			{
				print qq(<option value="0$sec" Selected>0$sec</option>);
			}
			else{print qq(<option value="0$sec">0$sec</option>);}
		}
	}
    print qq (</select></td></tr><tr>);
    my @week=("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat");
	my $weeknum=0;
	print qq (<td id="week" style="display:none;" colspan="2">);
    foreach my $day ( @week )
    {
         print qq (<INPUT type="radio" name="week" id="selectDay" value="$weeknum"/> $day&#32&#32);
		 if($weeknum eq 2){print qq(<br>);}
		 if($weeknum eq 5){print qq(<br>);}
		 $weeknum++;
    }
    print qq (</select></td></tr><tr id="monthly" style="visibility:hidden;">);
	print qq (<td>Day : </td>);
    print qq (<td><select class="qb" id="number" style="WIDTH:50px">);
    foreach my $month (1..30)
    {
        if ($month < 10)
        {
            print qq (<option value="$month">0$month</option>);
        }else
        {
            print qq (<option value="$month">$month</option>);
        }
    }
    print qq (</select></td></tr>);
	print qq (<tr>);
	print qq (<td class="body"  valign="center" align="left" style="height: 1px; width: 100px" colspan="2">);
	print qq (Bandwidth setting :&nbsp; );
	print qq (<select class="qb" id="bs" style="WIDTH:110px">);
	if ($bs eq '0')
	{
		print qq (<option value="0" Selected>by Up/Down</option>);
		print qq (<option value="1">by Total</option>);
	}
	if ($bs eq '1')
	{
		print qq (<option value="0">by Up/Down</option>);
		print qq (<option value="1" Selected>by Total</option>);
	}
	if (!$bs)
	{
		print qq (<option value="0">by Up/Down</option>);
		print qq (<option value="1">by Total</option>);
	}
	print qq (</select></td></tr>);
	print qq (<tr>);
	print qq (<td class="body"  valign="center" align="left" style="height: 1px; width: 100px" colspan="2">);
	print qq (When Quota full :&nbsp; );
	print qq (<select class="qb" id="ql" style="WIDTH:110px">);
	if ($ql eq '0')
	{
		print qq (<option value="0" Selected>Block</option>);
		print qq (<option value="1">Limit speed</option>);
	}
	if ($ql eq '1')
	{
		print qq (<option value="0">Block</option>);
		print qq (<option value="1" Selected>Limit speed</option>);
	}
	if (!$ql)
	{
		print qq (<option value="0">Block</option>);
		print qq (<option value="1">Limit speed</option>);
	}
	print qq (</select></td></tr>);
	print qq (<tr id="show_limit"><td>Limit Speed at : </td>);
    print qq (<td><input type="text" class="qbtext" id="lmit" style="WIDTH:45px" maxlength="4" value="$lmit"/>);
    print qq (</td></tr>);
    print qq (</table>);
	print qq (</span>);
    print qq (</td>);
    #**************************************************************************************
    print qq (<td class="body" align="right" valign="top">);
    print qq (<input type="button" class="qb" value="Add"    title="Add Policy"    onClick="updatePolicy('ADD')" style="height:20 width:25">);
    print qq (<input type="button" class="qb" value="Update" title="Save Changes"  onClick="updatePolicy('UPDATE')" style="height:20 width:35">);
    print qq (</td>);
       
    if ( $action{viewpoint} ne "lvs" ) { print qq (<br>); }
    
    if ( $action{viewpoint} eq "lvs" )
    {
        #print qq (<input type="button" class="qb" value="B"  title="Go Back to Server Mapping"  onClick="goBackToServerMapping()" style="height:20 width:20"><br>);
        #print qq (<input type="button" class="qb" value="Back"  title="Go Back to Server Mapping"  onClick="goBackToServerMapping()" style="height:20 width:20"><br>);
    }

    print qq (</td></tr>);
	
    print qq (</table>);
}
#init_class_show

#===============================================================================================
sub iniroute_script 
{
    print << "INIROUTE_SCRIPT";

    <div id="ServiceDiv" class="infodiv"></div>
    <div id="TableDiv" class="infodiv"></div>

  <script language="javascript">
      
    var dropTable=$gDROP;
    var myform=window.document.forms[0];  

	function showhide()
	{
		//if (document.getElementById("hidden").style.display == 'none')
		//{
		//    document.getElementById("hidden").style.display = 'block';
		//}else
	   // {
		//    document.getElementById("hidden").style.display = 'none';
		//    document.getElementById("cycle").value = '0';
		//}
		if (document.getElementById("show_quota").style.display == 'none')
		document.getElementById("show_quota").style.display = 'block';
		else
		{
			document.getElementById("show_quota").style.display = 'none';
			document.getElementById("cycle").value = '0';
		}
		cycleChange();
	}
	
	function quota_setting_window()
	{
		var dmit = document.getElementById('dmit').value;
		var dbps = document.getElementById('dbps').value;
		var umit = document.getElementById('umit').value;
		var ubps = document.getElementById('ubps').value;
		
		var cycle = document.getElementById('cycle').value;
		var hr = document.getElementById('hr').value;
		var sec = document.getElementById('sec').value;
		var number = document.getElementById('number').value;
		var radio = document.getElementsByName("week");
		var radio_data;
	        for (var i = 0; i < radio.length; i++)
        	{
        		if (radio[i].checked == true)
        		radio_data=radio[i].value;
        	}
		var chose = '0'
		if(cycle==7){chose=radio_data;}
		if(cycle==30){chose=number;}
		var bs = document.getElementById('bs').value;
		var ql = document.getElementById('ql').value;
		var lmit = document.getElementById('lmit').value;
		//alert('quota_add.cgi?dmit='+dmit+'&dbps='+dbps+'&umit='+umit+'&ubps='+ubps+'&cycle='+cycle+'&chose='+chose+'&hr='+hr+'&sec='+sec+'&bs='+bs);
		MM_openBrWindow('quota_add.cgi?dmit='+dmit+'&dbps='+dbps+'&umit='+umit+'&ubps='+ubps+'&cycle='+cycle+'&chose='+chose+'&hr='+hr+'&sec='+sec+'&bs='+bs+'&ql='+ql+'&lmit='+lmit,'Quota_Add','300','345');
	}
	
	function MM_openBrWindow(theURL,winName,win_width,win_height) 
	{
		var PosX = (window.screen.availWidth-10-win_width)/2; 
		var PosY = (window.screen.availHeight-30-win_height)/2; 
		features = "width="+win_width+",height="+win_height+",top="+PosY+",left="+PosX+",status=no,location=no,status=no,menubar=no,toolbar=no,resizable=no,scrollbars=no"; 
		var newwin = window.open(theURL,winName,features); 
	}
	
	function newwindow()
	{
		window.open ('quota_add.cgi', 'Quota_Add', 'height=300,width=300,toolbar=no,menubar=no,scrollbars=no,resizable=no,location=no,status=no');
	}
	
	function U_change()
    {
        var choose = document.getElementById('bs').value;
		var dmit = document.getElementById('dmit');
		var umit = document.getElementById('umit');
		var dbps = document.getElementById('dbps');
		var ubps = document.getElementById('ubps');
		if(choose == '1')
		{			
			umit.value=dmit.value;
			ubps.value=dbps.value;
		}
    }
	
	function bs_change()
	{
		var choose = document.getElementById('bs').value;
		var dmit = document.getElementById('dmit');
		var umit = document.getElementById('umit');
		var dbps = document.getElementById('dbps');
		var ubps = document.getElementById('ubps');
		var tmit = document.getElementById('tmit');
		var tbps = document.getElementById('tbps');
		
		var tview = document.getElementById('tview');
		var dview = document.getElementById('dview');
		var uview = document.getElementById('uview');
		if(choose == '1')
		{
			//tmit.style.display='';
			tview.style.display='';
			//umit.readOnly=true;
			//umit.value=dmit.value;
			//ubps.value=dbps.value;
			//dmit.style.display='none';
			dview.style.display='none';
			//umit.style.display='none';
			uview.style.display='none';
		}
		else
		{
			//umit.readOnly=false;
			//tmit.style.display='none';
			tview.style.display='none';
			//umit.readOnly=true;
			//umit.value=dmit.value;
			//ubps.value=dbps.value;
			//dmit.style.display='';
			dview.style.display='';
			//umit.style.display='';
			uview.style.display='';
		}
	}
	
	function WQFChange()
	{
		var choose = document.getElementById('ql').value;
		var show = document.getElementById('show_limit');
		if(choose == '1')
		{
			show.style.visibility='';
		}
		else{show.style.visibility='hidden';}
	}
	
	function myalert()
	{		
		var dmit = document.getElementById('dmit');
		var dbps = document.getElementById('dbps');
		var umit = document.getElementById('umit');
		var ubps = document.getElementById('ubps');
		var tmit = document.getElementById('tmit');
		var tbps = document.getElementById('tbps');
		
		var cycle = document.getElementById('cycle');
		var hr = document.getElementById('hr');
		var sec = document.getElementById('sec');
		var number = document.getElementById('number');
		
		var radio = document.getElementsByName("week");
        var radio_data='';
        for (var i = 0; i < radio.length; i++)
        {
            if (radio[i].checked == true)
            radio_data=radio[i].value;
        }
		var bs = document.getElementById('bs');
		var ql = document.getElementById('ql');
		var lmit = document.getElementById('lmit');
		
		if(bs.value == '1')
		{
			dmit.value=tmit.value;
			umit.value=tmit.value;
			dbps.value=tbps.value;
			ubps.value=tbps.value;
		}else{tmit.value=dmit.value;tbps.value=dbps.value;}
		
		if(dmit.value > 909 && dbps.value == 'T')
		{
			alert('Limit Downlink must <= 909 TB');
			return;
		}
        if(umit.value > 909 && ubps.value == 'T')
		{
			alert('Limit Uplink must <= 909 TB');
			return;
		}
		if(dmit.value == '' || umit.value == '' || tmit.value =='')
		{
			alert('Must to type limit value');
			return;
		}
		if(cycle.value == '7' && radio_data==''){alert('Must to select days'); return;}
		
		odmit = window.opener.document.getElementById('dmit');
		odbps = window.opener.document.getElementById('dbps');
		oumit = window.opener.document.getElementById('umit');
		oubps = window.opener.document.getElementById('ubps');
		
		ocycle = window.opener.document.getElementById('cycle');
		ohr = window.opener.document.getElementById('hr');
		osec = window.opener.document.getElementById('sec');
		onumber = window.opener.document.getElementById('number');
		oradio = window.opener.document.getElementsByName("week");
		obs = window.opener.document.getElementById("bs");
		oql = window.opener.document.getElementById("ql");
		olmit = window.opener.document.getElementById("lmit");
		//alert('proute windows'+obs.value);
		
		odmit.value = dmit.value;
		odbps.value = dbps.value;
		oumit.value = umit.value;
		oubps.value = ubps.value;
		ocycle.value = cycle.value;
		ohr.value = hr.value;
		osec.value = sec.value;
		onumber.value = number.value;
		for (var i = 0; i < oradio.length; i++)
        {
            if (oradio[i].value == radio_data)
			{
				oradio[i].checked = true;
			}
        }
		obs.value = bs.value;
		oql.value = ql.value;
		olmit.value = lmit.value;
		window.close();
	}

function cycleChange()
{
    if (document.getElementById("cycle").value == '0' )
    {
        document.getElementById("hr").disabled = true;
        document.getElementById("sec").disabled = true;
        document.getElementById("week").style.display = 'none';
        document.getElementById("monthly").style.visibility = 'hidden';
    }else
    {
        document.getElementById("hr").disabled = false;
        document.getElementById("sec").disabled = false;
    }
    
    if (document.getElementById("cycle").value == '7' )
    {
        document.getElementById("week").style.display = 'block';
        document.getElementById("monthly").style.visibility  = 'hidden';
    }else if (document.getElementById("cycle").value == '30' )
    {
        document.getElementById("week").style.display = 'none';
        document.getElementById("monthly").style.visibility  = '';
    }else
    {
        document.getElementById("week").style.display = 'none';
        document.getElementById("monthly").style.visibility  = 'hidden';
    }
}   
	
    function cgi_dep_onload()
    {
    	//20101228 remove
        //onoffdest();
        //onoffSchedule();
        IsDrop();
        //20111117 Brian fix: after updating the lvs policy,the page can not return.
        //IsSip is used to check manual nat or not. lvs policy does not have nat method.
        var viewpoint=myform.viewpoint.value;
        if (viewpoint != 'lvs' || viewpoint != 'a')
        {
        IsSip();
        }
        setTimeout("updateShow()",500);
    }
    
    function IsDrop()
    {
        var table=document.getElementById('table').value;
        var qos=document.getElementById('qos');
        var myqos = new Array();
		$jsqosarray
        //alert(table);
        if ( qos )
        if ( table == '255' ){
			qos.value = "None";
            		qos.disabled = true;
			}
        else{
			
            qos.disabled = false;
			while(qos.firstChild){
				qos.removeChild(qos.firstChild);
			}
			qos.add(new Option("None","None"));
			for(var fjk=0;fjk<myqos.length;fjk++){
			var hhji =myqos[fjk].split(",");
				if(hhji[0]==table) {
					qos.add(new Option(hhji[1],hhji[1]));
				}
			}
			}
    }
    
    function IsSip()
    {
        var method = document.getElementById('method').value;
        var sip = document.getElementById('sip');
        
        if (method != 'manual_ls')
        {
            sip.disabled = true;
        }
        else
        {
            sip.disabled = false;
        }
    }

    function updateShow()
    {
        var action=myform.action.value;
        var viewpoint=myform.viewpoint.value;

        if ( action=='UPDATE' || action=='ADD' )
        {
            var viewpoint=myform.viewpoint.value;
            var keyofrule=myform.keyofrule.value;
			var showqos=myform.showqos.value;
            var qstring='';
            qstring+='editinirule.cgi'+'?'+'viewpoint='+viewpoint+'&';
            qstring+='keyofrule='+keyofrule+'&';
			qstring+='showqos='+showqos;
            if ( viewpoint == "lvs" )
	    window.top.mainFrame.mainframe.editinirule.location.href=qstring;
	    else
	    window.top.mainFrame.editinirule.location.href=qstring;
        }
    }

    function onoffSchedule()
    {
        return; 

        var table=myform.table.value;
        
        if ( table==dropTable ) 
        { 
            myform.schedule.disabled=true; 
            myform.NONESCHEDULE.disabled=true;
            myform.ALLSCHEDULE.disabled=true;
            myform.EXPANDSCHEDULE.disabled=true;
            myform.SHRINKSCHEDULE.disabled=true;
        }
        else
        {
            myform.schedule.disabled=false; 
            myform.NONESCHEDULE.disabled=false;
            myform.ALLSCHEDULE.disabled=false;
            myform.EXPANDSCHEDULE.disabled=false;
            myform.SHRINKSCHEDULE.disabled=false;
        }


    }

    function filterTable()
    {
        goSubmit('UPDATEINTERFACE');
    }

    function onoffdest()
    {
        var myform=document.prouteform;
        //20101228 remove  
        //if(myform.advance.checked) { myform.dest.disabled=false; }
        //else { myform.dest.disabled=true; }
    }
    
    function advance_action()
    { 
        var myform=document.prouteform;
        //if(myform.advance.checked) { myform.dest.disabled=false; }
        //else { myform.dest.disabled=true; }
        goSubmit();  
    }

    function dest_on_change()   
    {
        if(document.prouteform.dest.value=='edit') { editdest=openWin('./editdest.cgi'); }
        else { goSubmit('CHANGEDEST'); }
    }

    function expandSchedule()   { myform.schedule.size="8"; }
    function shrinkSchedule()   { myform.schedule.size="1"; }
    function expandNATIP()      { myform.sipstatus.value=myform.sip.size="8"; }
    function shrinkNATIP()      { myform.sipstatus.value=myform.sip.size="1"; }
    
    function allSchedule()
    {
        var schedule=myform.schedule;
        for(var i=0; i<schedule.options.length; i++) { schedule.options[i].selected=true;}
    }
    
    function noneSchedule()
    {
        var schedule=myform.schedule;
        for(var i=0; i<schedule.options.length; i++) { schedule.options[i].selected=false;}
    }
    
    function updatePolicy(action)
    {
        var report="";
        var okToGo=true;
		
		var quota='';
		var rule_name='';

		rule_name=document.getElementById("rname").value;
		
		if(document.getElementById("dmit").value > 909 && document.getElementById("dbps").value == 'T')
		{
			alert('Limit Downlink must <= 909 TB');
			return;
		}
        if(document.getElementById("umit").value > 909 && document.getElementById("ubps").value == 'T')
		{
			alert('Limit Uplink must <= 909 TB');
			return;
		}
		
        if (document.getElementById("dmit").value != '' && document.getElementById("dbps").value != '0')
        {
            quota += document.getElementById("dmit").value + document.getElementById("dbps").value + '/';
        }else
        {
            quota += '--/';
        
        }
        
        if (document.getElementById("umit").value != '' && document.getElementById("ubps").value != '0')
        {
            quota += document.getElementById("umit").value + document.getElementById("ubps").value ;
        }else
        {
            quota += '--';
        }
        
        if (document.getElementById("cycle").value == 0)
        {
            quota += '<br>-,-,--:--';
        }else if (document.getElementById("cycle").value == 1)
        {
            quota += '<br>D,-,'+ document.getElementById("hr").value + ':' + document.getElementById("sec").value;
        }else if (document.getElementById("cycle").value == 7)
        {
            var radio = document.getElementsByName("week");
            var radio_data;
            for (var i = 0; i < radio.length; i++)
            {
                if (radio[i].checked == true)
                    radio_data=radio[i].value;
            }
            quota += '<br>W,' + radio_data  + ','+ document.getElementById("hr").value + ':' + document.getElementById("sec").value;
        }else if (document.getElementById("cycle").value == 30)
        {
            var day = document.getElementById("number");
            quota += '<br>M,' + day.value + ','+ document.getElementById("hr").value + ':' + document.getElementById("sec").value;
        }
		
		if (document.getElementById("bs").value == '1')
        {
            quota += '<br>1';
        }else
        {
            quota += '<br>0';
        }
		
		if (document.getElementById("ql").value == '1')
        {
            quota += '<br>1';
        }else
        {
            quota += '<br>0';
        }
		
		if (document.getElementById("lmit").value != '')
        {
            quota += '<br>'+document.getElementById("lmit").value;
        }else
        {
            quota += '<br>10';
        }
		
		if (document.getElementById("dmit").value == '' || document.getElementById("dbps").value == '0' || document.getElementById("umit").value == '' || document.getElementById("ubps").value == '0')
        {
            quota = '';
        }
		
		var viewpoint=myform.viewpoint.value;
		
		if (action=='UPDATE') 
		{
			if(viewpoint=='lvs')
			{
				myform.focusedrule.value=window.top.mainFrame.mainframe.editinirule.document.forms[0].focusedrule.value; 
			}
			else
			{
				myform.focusedrule.value=window.top.mainFrame.editinirule.document.forms[0].focusedrule.value; 
			}
		}
		        
        //check source
        if ( !myform.source.value )  { report+="Source is Must"+"\\n"; okToGo=false; }
        
        //check service
        if ( !myform.service.value ) { report+="Service is Must"+"\\n"; okToGo=false; }
        
        //check advance //Brian Mark it for fqdn
        //if ( myform.advance.checked && !isValidIP(myform.dest.value) && !isValidSubnet(myform.dest.value) ) { report+="Destination is a Must in Advance Mode"+"\\n"; okToGo=false; }
        
        //check table
        if ( !myform.table.value ) { report+="Table is Must"+"\\n"; okToGo=false; }
    
        //check schedule
        var schedulePass=false;
        var schedule=myform.schedule;
        for(var i=0; i<schedule.options.length; i++) 
        { 
            schedulePass=schedule.options[i].selected;
            if ( schedulePass ) break;
        }
        
        var table=myform.table.value;
		myform.quota.value = quota ;
		myform.rule_name.value = rule_name ;
        if ( table==dropTable ) { schedulePass=true; }

        if ( !schedulePass ) { report+="Choose at least one time segment"+"\\n"; okToGo=false; }

        if ( !okToGo )  alert(report); 
        if ( okToGo )   goSubmit(action);
    }
    
    function popUpTableInfo()
    {
        var table=myform.table.value;
        showTableInfo(table);
    }

    function popUpServiceInfo()
    {
        var service=myform.service.value;
        showServiceInfo(service);
    }
    
    function showServiceInfo(service)
    {
        var pattern=/\\.|\\*|system|others|\\:d|\\:s|\\:/g; service=service.replace(pattern,'');
        if(!service) { return; }
        var service=eval(service);
        ServiceDiv.innerText="<table class=infodivtable><tr><td>"+"Service Name:"+service.info[1]+"</td><td>"+"Type:"+service.info[0]+"</td></tr>";
        
        
            
        with(service)
        for(count=0;count<port.length;count++)
        {
	    ServiceDiv.innerText+="<tr><td>Protocol:"+port[count].protocol+"</td><td>Port:"+port[count].port+"</td></tr>";
        }
        
        with(ServiceDiv)
        {
            innerText+="</table>";
            innerHTML=innerText;
            style.pixelLeft = document.body.scrollLeft;
            style.pixelTop = document.body.scrollTop; 
			style.left= '30px';
			style.top= '20px';
            style.display="block";
        }
    }
    
    function showTableInfo(Table)
    {
        if( !Table || Table=='$gDROP' || Table=='$gALLPATH' || Table=='$gRRG' ) 
        { 
            alert("no info !!");
            return; 
        } 

        var table=eval('T'+Table);

        with(TableDiv)
        {
            innerText="<table class=infodivtable><tr><td>"+"Pool ID:"+Table+"</td><td>";
            //20100223 Brian To show the note of the pool
            innerText+="<td>Pool Name:"+table.I[4]+"</td><td>";
            innerText+="<td>By Packet:"+table.I[0]+"</td><td>";
            innerText+="<td>Mode:"+table.I[1]+"</td><td>";
            innerText+="<td>Truely Aggregate:"+table.I[2]+"</td><td>";
            innerText+="<td>Redirect Host:"+table.I[3]+"</td></tr>";
        }
            
        with(eval('T'+Table))
        for(count=0;count<P.length;count++)
        {
	    TableDiv.innerText+="<tr><td>ISP ID:"+P[count].a+"</td><td>Name:"+P[count].b+"</td><td>Weight:"+P[count].c+"</td><td>DSIP:"+P[count].d+"</td></tr>";
        }
        
        with(TableDiv)
        {
            innerText+="</table>";
            innerHTML=innerText;
            style.pixelLeft = document.body.scrollLeft;
            style.pixelTop = document.body.scrollTop; 
			style.left= '30px';
			style.top= '20px';
            style.display="block";
        }
    }

    function goBackToServerMapping() { window.top.mainFrame.location.href="vs.cgi"; }

    function hideTableInfo(){TableDiv.style.display="none";}
    function hideServiceInfo(){ServiceDiv.style.display="none";}
    
  </script>
  
  
INIROUTE_SCRIPT
}
#iniroute_script

#===================================================================================================
#maintainIniroute(%action)
sub maintainIniroute 
{
    my (%action)=@_;
    if ( !$action{action} ) { return; }
    my $iniroute=XMLread($gPATH."iniroute.xml");
    my $fwmark=XMLread($gPATH."fwmark.xml");
    my $target;
    my $hostref=XMLread($gPATH.'host.xml');
    my $hostlist=$hostref->{host};
    
    #ex:( action=>'CHANGESOURCE', viewpoint=>'', source=>'', newsource=>'', newisp=>'')
    if ( $action{action}=~m/^CHANGESOURCE$/ ) 
    {
        if ( !$action{newisp} ) { $action{newisp}='*'; }
        my $classes=$iniroute->{$action{viewpoint}}->[0]->{class};
        foreach my $class ( @$classes ) 
        {
            if ( $class->{source} ne $action{source} ) { next; }
            $class->{isp}=$action{newisp};
            $class->{source}=$action{newsource};
        }
    }
    elsif ( $action{action}=~m/^AUTODOS$/ )
    {
        my $qosref=XMLread($gPATH.'qos.xml');
        my $qoslist = $qosref->{qos};
        my $inilist = $iniroute->{nat}->[0]->{class};
        foreach my $init (@$inilist)
        {
            if( $init->{table} > 100 || $init->{qos} ne 'None' || $init->{table} eq 30){next;}
            foreach my $qos (@$qoslist)
            {
                if ($init->{table} ne $qos->{pool}){next;}
                if ($qos->{qosname} eq ""){$init->{qos} = 'None';};
                $init->{qos} = $qos->{qosname};
            }
        }
        XMLwrite($iniroute, $gPATH."iniroute.xml");   
     }
     elsif ( $action{action}=~m/^REPEAT$/ )
    {
         my $rtable = XMLread($gPATH.'rtable.xml');
         my $rtables = $rtable->{table};
         my $ini = $iniroute->{nat}->[0]->{class};
         foreach my $tab (@$rtables)
         {
             my $y = '0';
             foreach my $iniref (@$ini)
             {
                 if($tab->{table_num} ne $iniref->{table}){next;}
                 $y = '1';
                 last;
             }
             if ($y eq '0')
             {
                 my $target = $tab;
                 my $list = $target->{path};
                 foreach my $ref (@$list)
                 {
                     if ($ref->{dsip} ne '' && $ref->{weight} ne '1' && $ref->{subnet} ne ''){next;}
                     my $isp = XMLread($gPATH.'basic.xml');
                     my $isplist = $isp->{isp};
                     foreach my $ispref (@$isplist)
                     {
                         if (!grep(/tunnel/,$ispref->{isptype})){next;}
                         if (grep(/^dtunnel$/,$ispref->{isptype}))
                         {
                             maintainTMV(action=>'SAVE',adp_com=>"$ispref->{adp_com}",alg=>"$ispref->{alg}",alive=>"$ispref->{alive}",allpool=>"$ispref->{allpool}",alltmv=>"$ispref->{alltmv}",download=>"$ispref->{download}",dport=>"$ispref->{dport}",enabled=>"$ispref->{enabled}",enc=>"$ispref->{enc}",gateway=>"$ispref->{gateway}",iid=>"$ispref->{iid}",ipcom=>"0",ispname=>"$ispref->{ispname}",ispnumber=>"$ispref->{ispnumber}",isptype=>"$ispref->{isptype}",local=>"$ispref->{local}",mpv_nat=>"$ispref->{mpv_nat}",mpv_nat_ip=>"$ispref->{mpv_nat_ip}",mss=>"$ispref->{mss}",mss_value=>"$ispref->{mss_value}",mtu=>"$ispref->{mtu}",mtu_value=>"$ispref->{mtu_value}",nic=>"$ispref->{nic}",pkchk=>"$ispref->{pkchk}",poolBuff=>"$ispref->{poolBuff}",poolComp=>"$ispref->{poolBuff}",poolDownUp=>"$ispref->{poolDownUp}",poolEnCmp=>"$ispref->{poolEnCmp}",poolEnc=>"$ispref->{poolEnc}",poolIp=>"$ispref->{poolIp}",poolMss=>"$ispref->{poolMss}",poolMtu=>"$ispref->{poolMtu}",poolPkChk=>"$ispref->{poolPkChk}",poolTxqueue=>"$ispref->{poolTxqueue}",poolnum=>"$ispref->{poolnum}",port=>"$ispref->{port}",remote=>"$ispref->{remote}",remotename=>"$ispref->{remotename}",state=>"$ispref->{state}",systemip=>"$ispref->{systemip}",target=>"$ispref->{target}",tmvbuf=>"$ispref->{tmvbuf}",traversal_port=>"$ispref->{traversal_port}",tunnel_role=>"$ispref->{tunnel_role}",txqueue=>"$ispref->{txqueue}",upload=>"$ispref->{upload}",tmp=>"1");
                         }
                     }
                 }
             }
         }
    }
    elsif ( $action{action}=~m/^CHECK$/ )
    {
        my $rtable = XMLread($gPATH.'rtable.xml');
        my $ini = $iniroute->{nat}->[0]->{class};
        my $rtables = $rtable->{table};
        foreach my $iniref (@$ini)
        {
            if ($iniref->{method} ne 'none' || $iniref->{table} > 99 || $iniref->{table} eq '30'){next;}
            foreach my $tab (@$rtables)
            {
                if($tab->{table_num} ne $iniref->{table} || ($tab->{mode1} ne 'TB' && $tab->{mode} eq 'WLC')){next;}
                my $target = $tab;
                my $list = $target->{path};
                my $x = '0';
                foreach my $ref (@$list)
                {
                    if ($ref->{dsip} ne '' && $ref->{weight} ne '1' && $ref->{subnet} ne ''){next;}
                    $x++;
                }
                if ( $x > 1 )
                {
                    foreach my $ref (@$list)
                    {
                        if ($ref->{dsip} ne '' && $ref->{weight} ne '1' && $ref->{subnet} ne ''){next;}
                        my $isp = XMLread($gPATH.'basic.xml');
                        my $isplist = $isp->{isp};
                        foreach my $ispref (@$isplist)
                        {
                            if (!grep(/tunnel/,$ispref->{isptype})){next;}
                            if ($ref->{isp} ne $ispref->{iid} || $ispref->{ipcom} eq '1'){next;}
                            if (grep(/^tunnel$/,$ispref->{isptype}))
                            {
                            }
                            if (grep(/^dtunnel$/,$ispref->{isptype}))
                            {
                                maintainTMV(action=>'SAVE',adp_com=>"$ispref->{adp_com}",alg=>"$ispref->{alg}",alive=>"$ispref->{alive}",allpool=>"$ispref->{allpool}",alltmv=>"$ispref->{alltmv}",download=>"$ispref->{download}",dport=>"$ispref->{dport}",enabled=>"$ispref->{enabled}",enc=>"$ispref->{enc}",gateway=>"$ispref->{gateway}",iid=>"$ispref->{iid}",ipcom=>"1",ispname=>"$ispref->{ispname}",ispnumber=>"$ispref->{ispnumber}",isptype=>"$ispref->{isptype}",local=>"$ispref->{local}",mpv_nat=>"$ispref->{mpv_nat}",mpv_nat_ip=>"$ispref->{mpv_nat_ip}",mss=>"$ispref->{mss}",mss_value=>"$ispref->{mss_value}",mtu=>"$ispref->{mtu}",mtu_value=>"$ispref->{mtu_value}",nic=>"$ispref->{nic}",pkchk=>"$ispref->{pkchk}",poolBuff=>"$ispref->{poolBuff}",poolComp=>"$ispref->{poolBuff}",poolDownUp=>"$ispref->{poolDownUp}",poolEnCmp=>"$ispref->{poolEnCmp}",poolEnc=>"$ispref->{poolEnc}",poolIp=>"$ispref->{poolIp}",poolMss=>"$ispref->{poolMss}",poolMtu=>"$ispref->{poolMtu}",poolPkChk=>"$ispref->{poolPkChk}",poolTxqueue=>"$ispref->{poolTxqueue}",poolnum=>"$ispref->{poolnum}",port=>"$ispref->{port}",remote=>"$ispref->{remote}",remotename=>"$ispref->{remotename}",state=>"$ispref->{state}",systemip=>"$ispref->{systemip}",target=>"$ispref->{target}",tmvbuf=>"$ispref->{tmvbuf}",traversal_port=>"$ispref->{traversal_port}",tunnel_role=>"$ispref->{tunnel_role}",txqueue=>"$ispref->{txqueue}",upload=>"$ispref->{upload}",tmp=>"1");
                            }
               		}
                    }
                }
            }
        }
    }
    elsif ( $action{action}=~m/^GETSRCTABLE$/ )
    {
        my @tablelist;
        my $addresslist;
        
        my $classes=$iniroute->{nat}->[0]->{class};
        push(@tablelist, '255');
        
        if ( $action{source} eq 'system' ) { $action{source} = '0.0.0.0/0'; }
        #if ( $action{destination} eq '' ) { $action{destiantion} = 'system'; }
        
        if ( grep(/^host-/, $action{source}) )
        {
            my $tmpsource = $action{source};
            $tmpsource =~ s/host-//g;
            $addresslist = maintainHost( action=>'GETADDRESSLIST', hostname=>$tmpsource);
            
        }
        else
        {
            $addresslist = $action{source};
        }
        
        
        foreach my $class ( @$classes )
        {
            #if ( $class->{destination} eq $action{destination} && 
            #   ( $class->{source} eq $action{source} || host_subnet_check($class->{source}, $addresslist) ) ) 
            if ( $class->{source} eq $action{source} || host_subnet_check($addresslist, $class->{source}) )  
            {
                if ( !grep(/^$class->{table}$/, @tablelist) )
                {
                    push(@tablelist, $class->{table});
                }
                
                if( $class->{table} < 100 )
                {
                    my @temptables=maintainRtable( action=>'GETPOOLTABLES', focused_rtable=>$class->{table});
                    foreach my $item ( @temptables )
                    {
                        if ( !grep(/^$item$/, @tablelist) )
                        {
                            push(@tablelist, $item);
                        }
                    }
                }
            }
        }
        #push(@tablelist, '255');
        @tablelist = sort { int($a) <=> int($b) } @tablelist;
        return @tablelist;
    }
    #ex:( action=>'WHENFWMARKUPDATED', viewpoint=>'' ) 
    elsif ( $action{action}=~m/^WHENFWMARKUPDATED$/ ) 
    {
        if ( $action{viewpoint} eq "lvslocalhost" ) { $action{viewpoint}='lvs'; }

        my @class_array_after_del;
        my $classes=$iniroute->{$action{viewpoint}}->[0]->{class};
        my $markarray=$fwmark->{$action{viewpoint}}->[0]->{mark};

        my %markhash;
        
        foreach my $mark ( @$markarray )
        {
            $markhash{$mark->{source}.'**'}=1;
            $markhash{$mark->{source}.'*d'}=1;
            $markhash{$mark->{source}.'*s'}=1;

            
            if ( $action{viewpoint} ne "lvs" ) 
            {
                $markhash{$mark->{source}.'others'.'d'}=1;
                $markhash{$mark->{source}.'others'.'s'}=1;
            }
            
            #$markhash{$mark->{source}.$mark->{service}.$mark->{direction}}=1;
            #add source_type
            $markhash{$mark->{source}.$mark->{service}.$mark->{direction}.$mark->{source_type}}=1;
            #$markhash{$mark->{source}.$mark->{service}.$mark->{direction}.$mark->{source_type}.$mark->{destination}}=1;
        }

        if ( $action{viewpoint} eq "nat" ) 
        { 
            $markhash{'0.0.0.0/0'.'others'.'d'}=1; 
            $markhash{'0.0.0.0/0'.'others'.'s'}=1; 
        }

        foreach my $class ( @$classes ) 
        {
            if( $class->{service} eq 'system' ) { push(@class_array_after_del, $class ); next; }
            my $to_be_deleted=1;
            my $source_type;
            
            # 重要: 對已 Obsolete 的 policy ，仍要保留
            # 重要: 哪些 policy 要保留，由這裡決定
            # 
            # hostobj key translate ( )
            my $sourcekey=$class->{source};
            if ( grep(/^host-/, $class->{source}))
            {
                foreach my $host ( @$hostlist )
                {
                    if ( $sourcekey eq $host->{hostname} ) 
                    {
                        $sourcekey=$host->{hostaddress};
                        $source_type=$host->{hosttype};
                        #if ( $host->{hosttype} eq 'iplist' )
                        if ( $host->{hosttype} eq 'iplist' || $host->{hosttype} eq 'networklist' )
                        {
                            my @iparray=split(/,/, $host->{hostaddress});
                            $sourcekey=$iparray[0];
                        }
                    }
                }
            }
            
	    #hostobj key
            my $inirulekey=$sourcekey.$class->{service}.$class->{direction}.$source_type;
            if ( $markhash{$inirulekey} ) { $to_be_deleted=0; }
            #check destination host object
            if ( grep(/^host-/, $class->{destination}) )
            {
                my $dest = $class->{destination};
                $dest =~ s/host-//g;
                my $address = maintainHost( action=>'GETADDRESSLIST', hostname=>$dest);
                
                if ( $address eq '' ) { $to_be_deleted=1; }
            }
            if ( !$to_be_deleted ) { push( @class_array_after_del, $class ); }
        }
            
        $iniroute->{$action{viewpoint}}->[0]->{class}=\@class_array_after_del;
    }
    elsif ( $action{action}=~m/^JUDGEDIRTYVALUEOFPOLICY$/ ) 
    {
        foreach my $viewpoint ( 'dmz', 'nat', 'lvs' ) 
        {
            my $classes=$iniroute->{$viewpoint}->[0]->{class};
            
            #若只有一筆 "system" 就不管了
            if ( @$classes <= 1 ) { next; }
            
            #======================================================================================================
            # phrase 1. prepare some necessary data structure before looping to use for speeding up valid checking ...
            
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # prepare step 1. get isp id list
            my @ispidlist;
            @ispidlist=maintainBasic( action=>'GETIIDLIST' ); 
            
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # prepare step 2. 
            # ! we will design this data structure to be loaded on demand
            my %isppubip;

            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # prepare step 3.
            my @sourcelist;
            my %source2isp;
            if ( $viewpoint=~m/dmz|nat/ ) 
            { 
                foreach my $class ( @$classes ) { if ($class->{source} ne 'system') { push(@sourcelist, $class->{source}); } }
            }
            %source2isp=batchFindMyISP( @sourcelist );
            
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # prepare step 4.
            my %dmzsrc2dirty;
            %dmzsrc2dirty=maintainDMZ(action=>'GETSUBNET2DIRTY');
            
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # prepare step 5.
            my %POLICY_USABLE_TABLES;
            if ( $viewpoint=~m/nat/ )
            {
                %POLICY_USABLE_TABLES=maintainRtable( action=>"GETPOLICYUSABLETABLEIDS", viewpoint=>"$viewpoint", source2isp=>\%source2isp );
            }
            else
            {
                %POLICY_USABLE_TABLES=maintainRtable( action=>"GETPOLICYUSABLETABLEIDS", viewpoint=>"$viewpoint" );
            }
         
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # here we start our judgement 
            foreach my $class ( @$classes ) 
            {
                #碰到系統保留的那一筆就跳過去
                if ( $class->{service} eq 'system' ) { next; }

                my $DIRTYSTATUS=0;

                #===========================================================================================================
                # Check Point 1. 檢查 dmz 的 source 是否已經過期了
                if ( $viewpoint eq 'dmz' && $dmzsrc2dirty{$class->{source}} ) 
                {
                    $DIRTYSTATUS=1        
                }

                if ( $DIRTYSTATUS )  { $class->{dirty}=1; next; }

                #=================================================================================================================
                # Check Point 2. Automatically correction for 2 conditions
                # 1. NAT source is of ISP public IP, and direction is set to "s", we should disable NAT, and then deal with it as DMZ
                # 2. DMZ source  and service is a reply one, we should disable NAT 

                if ( $viewpoint=~m/^nat$|^dmz$/ )
                {
                    my $ispid=findMyISP(subnet=>$class->{source}); 
                    if ( $viewpoint=~m/^nat$/ && $class->{direction} eq 's' && $ispid=~m/^\d+/ ) 
                    { 
                        #if this NAT source is within ISP public IP range and service is set to "*:s", we should disable NAT, and deal with it as DMZ 
                        if ( $ispid ) { $class->{isp}=$ispid; }
                        $class->{method}='none';
                        $class->{sip}=[];
                    }
                    elsif ( $viewpoint=~m/^dmz$/ &&  $class->{direction} eq 's') 
                    { 
                        $class->{method}='none';
                        $class->{sip}=[]; 
                    }
                }
                elsif ( $viewpoint=~m/^lvs$/ )
                {
                    $class->{method}='none';
                }


                #=================================================
                # Check Point 3 . 針對有 SIP 的 class，若任一 sip 過期，就設 dirty  
                my @ispidlist=maintainBasic( action=>'GETIIDLIST' );
                my $siplist=$class->{sip};
                foreach my $sip ( @$siplist ) 
                { 
                    my $ispexist=(grep(/^$sip->{isp}$/, @ispidlist )) ? 1 : 0;
                    if ( !$ispexist ) { $DIRTYSTATUS=1; last;}
                    
                    my @natip=split(/,/, $sip->{ip});
                    foreach my $ip ( @natip )
                    {
                        # %isppubip is a data structure designed to be loaded on demand
                        my $nownatips;
                        if ( !exists($isppubip{$sip->{isp}}) )
                        {
                            my @pubips=maintainIPBank(action=>'READPUBLICIP', isp=>$sip->{isp});
                            $isppubip{$sip->{isp}}=\@pubips;
                        }
                        
                        $nownatips=$isppubip{$sip->{isp}};
                        my $ipobs=(!grep(/^$ip$/, @$nownatips)) ? 1 : 0;
                        if ( $ipobs ) { $DIRTYSTATUS=1; last;}
                    }

                    if ( $DIRTYSTATUS ) { last; }
                }

                if ( $DIRTYSTATUS )  { $class->{dirty}=1; next; }
                
                #==================================================
                # Check Point 4. 檢查原本走的 Routing Table 是否不能再走了，不能走就設 dirty
                my $rulekey=$class->{source}.':'.$class->{service}.':'.$class->{direction}.':'.$class->{destination}.':'.$class->{method}.':'.$class->{table};
                my $usable_table_list=$POLICY_USABLE_TABLES{$rulekey};

                my $table_obs=( !grep(/^$class->{table}$/, @$usable_table_list) ) ? 1 : 0;
                if ( $table_obs ) 
                { 
                  $DIRTYSTATUS=1;
                  #20130816 Brian for Management port
                  my @tunnelgatewaylist=maintainBasic( action=>'GETTUNNELGATEWAYLIST' );
                  my $checkgatewayip=$class->{source};
                  $checkgatewayip=~s/\/32$//g;
                  my $gwexist=(grep(/^$checkgatewayip$/, @tunnelgatewaylist )) ? 1 : 0;
                  if ( $gwexist ) { $DIRTYSTATUS=0; }
                }
                
                $class->{dirty}=$DIRTYSTATUS;
            }
        }
    }
    #ex:( action=>'DELRULES', rule=>'array 的 reference') 
    elsif ( $action{action}=~m/^DELSUBNETRULES$/ ) 
    {
        my $subnet=$action{source};
        my @class_array_after_del;
        my $classes=$iniroute->{nat}->[0]->{class};
      
        foreach my $class ( @$classes ) 
        {
            if ( !grep(/^$class->{source}/, @$subnet) )
            { 
                push( @class_array_after_del, $class ); 
            }
        }
        $iniroute->{nat}->[0]->{class}=\@class_array_after_del;
    }
    elsif ( $action{action}=~m/^DELRULES$/ ) 
    {
        my $delrulelist=$action{rule};
        my $viewpoint=$action{viewpoint};
        my @class_array_after_del;
        my $classes=$iniroute->{$viewpoint}->[0]->{class};
        foreach my $class ( @$classes ) 
        {
            my $to_be_deleted=0;
            foreach my $delrule ( @$delrulelist )
            {
                if( $class->{source}.$class->{service}.':'.$class->{direction}.$class->{destination}.$class->{schedule}  ne $delrule) { next; }
                LogUserAction( action=>'DELPROUTE', source=>$class->{source}, service=>$class->{service}, destination=>$class->{destination}, schedule=>$class->{schedule}, table=>$class->{table}, type=>$viewpoint, direction=>$class->{direction});
		$to_be_deleted=1;
		last;
	    }
	    if ( !$to_be_deleted ) { push( @class_array_after_del, $class ); }
        }
    
        $iniroute->{$viewpoint}->[0]->{class}=\@class_array_after_del;
    }
    elsif ( $action{action}=~m/^ACTIVATE_ON_OFF$/ )
    {
	`/usr/local/apache/qb/setuid/run /bin/echo 020 > /tmp/fifo.qbserv`;
    }
    elsif ( $action{action}=~m/^DELTMVRULES$/ )
    {
        my $delrulelist=$action{rule};
        my $viewpoint=$action{viewpoint};
        my @class_array_after_del;
        my $classes=$iniroute->{$viewpoint}->[0]->{class};
        foreach my $class ( @$classes )
        {
            my $to_be_deleted=0;
            foreach my $delrule ( @$delrulelist )
            {
                if( $class->{source}.$class->{service}.':'.$class->{direction}.$class->{destination}.$class->{schedule}  ne $delrule) { next; }
                LogUserAction( action=>'DELPROUTE', source=>$class->{source}, service=>$class->{service}, destination=>$class->{destination}, schedule=>$class->{schedule}, table=>$class->{table}, type=>$viewpoint, direction=>$class->{direction});
                $to_be_deleted=1;
                last;
            }
            if ( !$to_be_deleted ) { push( @class_array_after_del, $class ); }
         }       
         $iniroute->{$viewpoint}->[0]->{class}=\@class_array_after_del;
    } #ex:( action=>'DELRULEOFDESTINATION' ) 
    elsif ( $action{action}=~m/^DELRULEOFDESTINATION$/ ) 
    {
        my @destarray=maintainOverview( action=>'GETDESTINATION' );
        
        foreach my $viewpoint ( 'dmz', 'nat', 'lvs' ) 
        {
            my @class_array_after_del;
            my $classes=$iniroute->{$viewpoint}->[0]->{class};
              
            foreach my $class ( @$classes ) 
            {
                  
                if ( $class->{service} eq 'system' ) { push( @class_array_after_del, $class ); next;}
                if ( $class->{destination} eq 'system' ) { push( @class_array_after_del, $class ); next;}
                  
                my $to_be_deleted=1;
                  
                foreach my $dest ( @destarray ) 
                { 
                    if ( $class->{destination} ne $dest ) { next; }
                    $to_be_deleted=0; 
                    last; 
                }
                                    
                if ( !$to_be_deleted ) { push( @class_array_after_del, $class ); }
            }
                
            $iniroute->{$viewpoint}->[0]->{class}=\@class_array_after_del;
        }
    }
    #ex:( action=>'DELRULEOFSERVICE', viewpoint=>'', key=>'source.service.direction') 
    elsif ( $action{action}=~m/^DELRULEOFSERVICE$/ ) 
    {
        my $classes=$iniroute->{$action{viewpoint}}->[0]->{class};
        
        my @class_array_after_del;
        
        foreach my $class ( @$classes ) 
        {
            if ( $class->{source}.$class->{service}.$class->{direction} ne $action{key} ) 
            { 
                  push ( @class_array_after_del, $class );  
            }
        }
            
        # write \@class_array_after_del back into 'iniroute' 
        $iniroute->{$action{viewpoint}}->[0]->{class}=\@class_array_after_del;
            
        #會產生 dep issue
    }
    elsif ( $action{action}=~m/^ADD$|^UPDATE$/ ) 
    {
        $action{advance} = ( $action{destination} eq 'system' ) ? ( '0' ) : ( '1' );
        my ( $service, $direction ); 
        my $classes=$iniroute->{$action{viewpoint}}->[0]->{class};
        #my $classes=$iniroute->{$action{viewpoint}}->{class};
        
        # 以下將介面上蒐集到的時間區段轉換成 XML 中要儲存的時間區段格式
        #luke mark 20100819
        #my @timesegments=timeseqarray2segarray( $action{time} );
        #my @timesegments=timeseqarray2segarray( @allday );
        

        # Check if every MUST field is available, if anyone fails, just return doing nothing
        
        # 1.********************************************************************************
        if ( !$action{source} ) 
        {
            $gMSGPROMPT.=qq ( Select a Source first\\n );
            return; 
        }
        
        # 2.********************************************************************************
        if ( $action{service} ) 
        {
            ( $service, $direction )=split( /:/, $action{service} ) ;
            #service direction always is 'd'
            if ( !$direction ) { $direction=( $action{viewpoint} eq 'lvs' ) ? ( 's' ) : ( 'd' ); }
        }    
        else 
        {
            $gMSGPROMPT.=qq ( Select a Service first\\n );
            return; 
        }
        
        if ( $action{enables} ne '1' && $action{enables} ne '2' )
        {
            $action{enables} = '0';
        }
        
        # 3.********************************************************************************
        #Brian Mark it for fqdn
        #if ( $action{advance} && !isValidIP($action{destination}) && !get_subnet($action{destination}) ) 
        #{ 
        #    $gMSGPROMPT.=qq ( In Advacne Mode, a Destination is a MUST \\n);
        #    return;
        #} 
        
#20101228 
=cut
        # 4.****** judge if it is in advanced mode *****************************************
        if ( !$action{advance} ) 
        { 
              $action{advance}=0;

              $action{destination}='system'; 
        }  
        else 
        { 
              $action{advance}=1; 
        }
=cut
        
        # 5.********************************************************************************
        if ( !$action{table} ) 
        { 
            $gMSGPROMPT.=qq ( Routing Table is necessary\\n);
            return;
        }    
     
        #****** 當沒有傳回 $action{isp} 的值時 *********************************************
        if ( !$action{isp} ) 
        {
             if ( $action{viewpoint} eq 'dmz' ) { return; }
             else {  $action{isp}='system'; } 
        }   

        #============================================================================================================
        # Check if new Policy exists already
        my $target_exist=0; 
        my $target;

        #===== search ( source x service x direction x destination x table ) in iniroute =========================
        if ( $action{viewpoint} eq 'app' )
        {
            $action{focusedrule}=~s/:d//;
            $action{focusedrule}=~s/:s//;
        }
        #my $ruleContentToAddOrUpdate=$action{source}.$action{service}.$action{destination};    
        my $sourcekey = $action{source};
		
        $sourcekey =~ s/host-//g;
		
        if (grep(/\//,$sourcekey))
        {
            $sourcekey = ( get_subnet($sourcekey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$sourcekey) ) : $sourcekey; 
            $sourcekey =~ /\d+.\d+.\d+.\d+\/(\d+)/;
        }
        elsif (grep(/\:/,$sourcekey))
        {
            $sourcekey = ( get_subnet_v6($sourcekey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$sourcekey) ) : $sourcekey;
            #$sourcekey =~ /\d+.\d+.\d+.\d+\/(\d+)/;    
        }
		else {$sourcekey = ( get_subnet($sourcekey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$sourcekey) ) : $sourcekey;}
        my $mask = $1;
        #runCommand(command=>'echo', params=>"$mask >>/tmp/mask");
        if ( $mask ne '' && $action{qos} ne '' && $action{qos} ne 'None' && $mask < 24 )
        {
            my $qosref=XMLread($gPATH.'qos.xml');
            my $qoslist=$qosref->{qos};
            foreach my $qos ( @$qoslist )
            {
                if ( $action{qos} eq $qos->{qosname} )
                {
                    if( $qos->{type} eq 'individual' )
                    {
                        $gMSGPROMPT.=qq(Individual QoS Object Can't Apply Source Networkmask less than 24); 
                        return;
                    }
                    last;
                }
            }
        }
        
        my $destkey = $action{destination};
        $destkey =~ s/host-//g;
        if (grep(/\//,$destkey))
        {
            $destkey = ( get_subnet($destkey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$destkey) ) : $destkey; 
            $destkey =~ /\d+.\d+.\d+.\d+\/(\d+)/;
        }
        elsif (grep(/\:/,$destkey))
        {
            $destkey = ( get_subnet_v6($destkey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$destkey) ) : $destkey;
            #$destkey =~ /\d+.\d+.\d+.\d+\/(\d+)/;    
        }
		else{ $destkey = ( $action{destination} ne 'system' && get_subnet($destkey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$destkey) ) : $destkey;  }
        my $ruleContentToAddOrUpdate=$sourcekey.$action{service}.$destkey.$action{schedule};
		#$gMSGPROMPT.=qq([$sourcekey].[$action{service}].[$destkey].[$action{schedule}] \\n);
	my $target_enabled;
        foreach my $item ( @$classes ) 
        { 
            my $rulekey;
            if ( $item->{service} eq 'system' ) { next; }
            my $direction=( $action{viewpoint} eq 'app' ) ? '' : ':'.$item->{direction};
            #20111117 Brian Fix policy can't be update
            #$rulekey=$item->{source}.$item->{service}.':'.$item->{direction}.$item->{destination}.$item->{schedule};
            $rulekey=$item->{source}.$item->{service}.$direction.$item->{destination}.$item->{schedule};
			
            #$rulekey=$item->{source}.$item->{service}.':'.$item->{direction}.$item->{destination};
            my $sourcekey = $item->{source};
            $sourcekey =~ s/host-//g;
            $sourcekey = ( get_subnet($sourcekey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$sourcekey) ) : $sourcekey; 
            my $destkey = $item->{destination};
            $destkey =~ s/host-//g;
            $destkey = ( $destkey ne 'system' && get_subnet($destkey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$destkey) ) : $destkey; 
            #$iprulekey=$sourcekey.$item->{service}.$direction.$item->{destination}.$item->{schedule};
            $iprulekey=$sourcekey.$item->{service}.$direction.$destkey.$item->{schedule};
            if ( $rulekey eq $action{focusedrule} ) { $target=$item; }
            #if ( $rulekey eq $ruleContentToAddOrUpdate ) { $target=$item; }
            #if ( $rulekey eq $ruleContentToAddOrUpdate ) { $target_exist=1; last; } 
            if ( $iprulekey eq $ruleContentToAddOrUpdate ) { $target_exist=1; $target_enabled=$item->{enabled}; last; } 
            #runCommand(command=>'echo', params=>"$iprulekey >>/tmp/aaa");
        }
		
        #============================================================================================================
        # if new Policy exists when ADDing rules, prompt message to user
        $ruleContentToAddOrUpdate=$action{source}.$action{service}.$action{destination}.$action{schedule};    
        if ( $action{action} eq 'ADD' && $target_exist && $action{enables} ne '1') {   $gMSGPROMPT.=qq(Policy Already Exists); return; }
        if ( $action{action} eq 'UPDATE' && $target_exist &&  $ruleContentToAddOrUpdate ne $action{focusedrule} && $action{enables} ne '1') { $gMSGPROMPT.=qq(Policy Already Exists); return; }
    
        my %newclass;
        #********************** if ViewPoint is DMZ || LVS
        if ( $action{viewpoint}=~m/^lvs$/ ) 
        {
            if ( !$action{table} ) { return; }

            #my %new_LVS_class=( 
            %newclass = (
                    source      =>  $action{source}, 
                    service     =>  $service, 
                    direction   =>  $direction, 
                    destination =>  $action{destination}, 
                    table       =>  $action{table}, 
                    #time        =>  \@timesegments,
                    priority    =>  $action{priority}, 
                    method      =>  'system', 
                    advance     =>  $action{advance}, 
                    isp         =>  $action{isp},
                    schedule    =>  $action{schedule},
                    enables     =>  $action{enables},
                    #luke add qos
                    qos         =>  $action{qos}
            ); 
         
            if ( $action{action} eq "UPDATE" ) 
            {
                #%$target=%new_LVS_class;
                %$target=%newclass;
            }
            elsif ( $action{action} eq "ADD" ) 
            {    
                #push( @$classes, \%new_LVS_class );
                push( @$classes, \%newclass );
            }
        }
        elsif ( $action{viewpoint}=~m/^nat$|^dmz$|^app$/ ) 
        {
            #Check if every MUST field is available, if anyone fails, just return doing nothing
            if ( !$action{table} || !$action{method} ) { return; }

            # in xml we save both manual_ls and ls as ls method
            $action{method}=~s/manual_ls/ls/g; 
            if ( !$action{enabled} ) { $action{enabled}='1'; }
	    if($action{viewpoint}=~m/^app$/){$action{method}='none';}
            
            #%newDMZNATclass=( 
            %newclass=( 
                        source      =>  $action{source}, 
                        service     =>  $service, 
                        direction   =>  $direction, 
                        destination =>  $action{destination}, 
                        isp         =>  $action{isp}, 
                        advance     =>  $action{advance},     
                        method      =>  $action{method}, 
                        sip         =>  $action{sip}, 
                        #time        =>  \@timesegments,
                        table       =>  $action{table}, 
                        priority    =>  $action{priority}, 
                        #luke add schedule
                        schedule    =>  $action{schedule},
                        enables     =>  $action{enables},
                        #luke add qos
                        qos         =>  $action{qos},
                        #Gary add enabled/disabled function
                        enabled     =>  $target_enabled
            ); 
#            if ($action{viewpoint}=~m/^nat$/ && $action{enables} ne '1' &&  $action{enables} ne '2' && $direction ne 's')
#            {
#                $action{enables} = '2';
#            	%newclasss=(
#            		source      =>  $action{source},
#            		service     =>  $service,
#            		direction   =>  's',
#            		destination =>  $action{destination},
#            		isp         =>  $action{isp},
#            		advance     =>  $action{advance},
#            		method      =>  $action{method},
#            		sip         =>  $action{sip},
#            		table       =>  '100',
#            		priority    =>  $action{priority},
#            		schedule    =>  $action{schedule},
#            		enables     =>  $action{enables},
#            		qos         =>  $action{qos}
#            	);
#            }
			
			if ( $action{viewpoint}=~m/^nat$/ && $action{showqos} eq '1') 
			{
				my $quota = $action{quota};
				######################################
				if($quota eq ''){}
				else
				{
					my @quota_list=split(/<br>/,$quota);
					my @limit = split(/\//,$quota_list[0]);
					
					my $text = ($limit[0]=~m/([\d]+)/g);
					my $dmit = $1;
					my $text = ($limit[0]=~m/([\D]+)/g);
					my $dbps = $1;
					
					my $text = ($limit[1]=~m/([\d]+)/g);
					my $umit = $1;
					my $text = ($limit[1]=~m/([\D]+)/g);
					my $ubps = $1;
					my $dbpsv ='';
					my $ubpsv ='';
					if($dbps eq 'K'){$dbps=1024;}
					if($dbps eq 'M'){$dbps=1048576;}
					if($dbps eq 'G'){$dbps=1073741824;}
					if($dbps eq 'T'){$dbps=1099511627776;}
					
					if($ubps eq 'K'){$ubps=1024;}
					if($ubps eq 'M'){$ubps=1048576;}
					if($ubps eq 'G'){$ubps=1073741824;}
					if($ubps eq 'T'){$ubps=1099511627776;}
					my $down = $dmit.':'.$dbps;
					my $up   = $umit.':'.$ubps;
					my @date = split(/,/,$quota_list[1]);
					my $cycle = '';
					my $chose = '';
					my $time = '';
					$time=$date[2];
					if($date[0] eq '-'){$cycle='0';$chose='0';$time='00:00';}
					if($date[0] eq 'D'){$cycle='1';$chose='0';}
					if($date[0] eq 'W')
					{
						$cycle='7';
						if($date[1] eq 'Sun'){$chose='0';}
						if($date[1] eq 'Mon'){$chose='1';}
						if($date[1] eq 'Tue'){$chose='2';}
						if($date[1] eq 'Wed'){$chose='3';}
						if($date[1] eq 'Thu'){$chose='4';}
						if($date[1] eq 'Fri'){$chose='5';}
						if($date[1] eq 'Sat'){$chose='6';}
					}
					if($date[0] eq 'M'){$cycle='30';$chose=$date[1];}
					my $bs = '0';
					if ($quota_list[2] ne ''){$bs=$quota_list[2];}
					my $ql = '0';
					if ($quota_list[3] ne ''){$ql=$quota_list[3];}
					my $lmit = '10';
					if ($quota_list[4] ne ''){$lmit=$quota_list[4];}
					my $DATA = '';
					$password_len = 10;
					$password = '';
					my @word = qw/a b c d e f g h i j k m n p q r s t u v w x y z A B C D E F G H I J K L M N P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9/;
					$len = 58;
					for ($i = 0; $i < $password_len; $i++) {
					 if($i ==0 ){
					  $password .= $word[rand(37)];
					 }else{
					  $password .= $word[rand(58)];
					}
						rand(9999);
					}
					if($action{action} eq 'ADD')
					{
						if($action{destination} eq 'system'){$action{destination} = '0.0.0.0/0'}
						$DATA = ''.','.'policy'.','.''.','.''.','.$down.','.$up.','.$time.','.$cycle.','.''.','.''.','.$chose.','.'1'.','.$password.','.$action{source}.','.$action{destination}.','.''.','.'1'.','.$bs.','.$ql.','.$lmit;
						quotawork(quotaaction=>'SAVEQUOTA', DATA=>$DATA);
					}
					elsif($action{action} eq 'UPDATE')
					{
						if($action{focusedrule} ne '')
						{
							if($action{rule_name} eq '')
							{
								if($action{destination} eq 'system'){$action{destination} = '0.0.0.0/0'}
								#$DATA = ''.','.'policy'.','.''.','.''.','.$down.','.$up.','.$time.','.$cycle.','.''.','.''.','.$chose.','.'1'.','.$password.','.$action{source}.','.$action{destination};
								$DATA = ''.','.'policy'.','.''.','.''.','.$down.','.$up.','.$time.','.$cycle.','.''.','.''.','.$chose.','.'1'.','.$password.','.$action{source}.','.$action{destination}.','.''.','.'1'.','.$bs.','.$ql.','.$lmit;
								quotawork(quotaaction=>'SAVEQUOTA', DATA=>$DATA);
							}
							else
							{
								if($action{destination} eq 'system'){$action{destination} = '0.0.0.0/0'}
								#$DATA = ''.','.'policy'.','.''.','.''.','.$down.','.$up.','.$time.','.$cycle.','.''.','.''.','.$chose.','.'1'.','.$action{rule_name}.','.$action{source}.','.$action{destination};
								$DATA = ''.','.'policy'.','.''.','.''.','.$down.','.$up.','.$time.','.$cycle.','.''.','.''.','.$chose.','.'1'.','.$action{rule_name}.','.$action{source}.','.$action{destination}.','.''.','.'1'.','.$bs.','.$ql.','.$lmit;
								quotawork(quotaaction=>'SAVEQUOTA', DATA=>$DATA);
							}
						}else {$DATA = '';}
					}
					#if($DATA eq ''){}
					#else{quotawork(quotaaction=>'SAVEQUOTA', DATA=>$DATA);}
					#$gMSGPROMPT.=qq ([$DATA]\\n\\n);
					#quotawork(quotaaction=>'SAVEQUOTA', DATA=>$DATA);
				}
			}
			
            #According to the Spec. every sip set of any nat class must contain a 'system' element *********  
            if ( $action{action} eq "UPDATE" ) 
            {
                    #%$target=%newDMZNATclass;
                    %$target=%newclass;
                    LogUserAction( action=>'UPDATEPROUTE', source=>$action{source}, service=>$service, destination=>$action{destination}, schedule=>$action{schedule}, table=>$action{table}, type=>$action{method}, direction=>$direction);
            }
            elsif ( $action{action} eq "ADD" ) 
            {    
                    #push( @$classes, \%newDMZNATclass );
                    push( @$classes, \%newclass );
#                    if ( $action{enables} eq '2' && $direction ne 's' && $action{viewpoint}=~m/^nat$/){push( @$classes, \%newclasss );}
                    LogUserAction( action=>'ADDPROUTE', source=>$action{source}, service=>$service, destination=>$action{destination}, schedule=>$action{schedule}, table=>$action{table}, type=>$action{method}, direction=>$direction);
            }
            
        }
        #add new policy will re-generate fwmark.xml 
        #runCommand(command=>'echo', params=>"$service >>/tmp/kkk");
        if ( ($action{viewpoint} eq 'nat' && $service ne 'others' ) || $action{viewpoint} eq 'lvs' || $action{viewpoint} eq 'app' )
        #if ( ($action{viewpoint} eq 'nat' ) || $action{viewpoint} eq 'lvs' || $action{viewpoint} eq 'app' )
        {
            $newclass{type} = $action{viewpoint};
    	    my $fwviewpoint=( $action{viewpoint} eq 'app') ? ( 'nat' ) : ( $action{viewpoint} );
            # to generate fwmark for policy with service
            XMLwrite($iniroute, $gPATH."iniroute.xml");
            #maintainFwmark(type=>$fwviewpoint, action=>'update');
            maintainFwmark( %newclass );
        }
    }      
    #(viewpoint=>'',source=>'',service=>'', advance=>'0', destination=>'system', method=>'', sip=>'', time=>'', table=>'', priority=>'')
    elsif ( $action{action}=~m/^SMARTADD$/ ) 
    {
        my $classes=$iniroute->{$action{viewpoint}}->[0]->{class};
        
        # 1.****** 當沒有傳回 $action{isp} 的值時 *********************************************
        if ( !$action{isp} ) 
        {
             if ( $action{viewpoint} eq 'dmz' ) { return; }
             else {  $action{isp}='system'; } 
        }   
        

        #============================================================================================================
        # create a hash of rules for all the policies 
        my %rule_key_hash;
        foreach my $item ( @$classes) 
        { 
            my $rulekey=$item->{source}.$item->{service}.':'.$item->{direction}.$item->{destination};
            $rule_key_hash{$rulekey}=1;
        }

        #============================================================================================================
        # Check if new Policy existenct for NAT and DMZ 
        if ( $action{viewpoint}=~m/^nat$|^dmz$/ ) 
        {
            #===== search ( source x service x direction x destination ) in iniroute =========================
            my $ruleContentToAddOrUpdate=$action{source}.'others:d'.'system';   
 
            # if rule has already existed, just return without doing smart-adding
            if ( exists($rule_key_hash{$ruleContentToAddOrUpdate})  ) { return; } 
            if ( $action{source} =~ m/\d{1,3}\./){$bb="$gBALANCE"; $aa="ls";}
            else 
            {
                $aa="none";
                $bb=maintainBasic(action=>'GETIIDBYSUBNET', subnet=>$action{source});
                if($bb != 30 && $bb != 255 && $action{isp} ne 'system'){$bb="10".$action{isp};}
                else{$bb="$gBALANCE";}
            }
=cut
            my %newDMZNATclass=( 
                        source      =>  $action{source}, 
                        isp         =>  $action{isp}, 
                        service     =>  'others', 
                        direction   =>  'd', 
                        advance     =>  '0',     
                        destination =>  'system', 
                        method      =>  'ls', 
                        sip         =>  [], 
                        time        =>  ['0:1439'],
                        table       =>  $gBALANCE, 
                        priority    =>  1 
            ); 
=cut
            my %newDMZNATclass=( 
                        source      =>  $action{source}, 
                        service     =>  'others', 
                        direction   =>  'd', 
                        destination =>  'system', 
                        isp         =>  $action{isp}, 
                        advance     =>  '0',     
                        method      =>  $aa, 
                        sip         =>  [], 
                        table       =>  $bb,
                        priority    =>  1, 
                        #luke add schedule
                        schedule    =>  'All Week',
                        #luke add qos
                        qos         => 'None' 
            ); 
            
            push( @$classes, \%newDMZNATclass );
        }
        elsif ( $action{viewpoint}=~m/^lvs$/ ) 
        {
            my $defaultPool;
            #20130816 Brian for Management port
            if ( $action{isptype}=~m/tunnel/ )
            {
              my $belongiid=maintainBasic( action=>'GETBELONGIID', subnet=>$action{local}.'/32' );
              $defaultPool=$gALLPATH + $belongiid;
            }else{
              $defaultPool=$gALLPATH;
            }
            my $rservers=$action{rservers};
            my $services=$action{service};
            
            foreach my $rserver ( @$rservers )
            {
                if ( $rserver=~m/system/ ) { next; }
                
                my $source=( $rserver=~m/localhost/ ) ? ('localhost') : ($rserver.'/32');
                foreach my $service ( @$services )
                {
                    #maintain policy rrg
            	    #my $defaultPool=( $service eq "maintain" ) ? ($gRRG) : ($gALLPATH);
                    #===== search ( source x service x direction x destination ) in iniroute =========================
                    my $ruleContentToAddOrUpdate=$source.$service.':s'.'system';   

                    if ( exists($rule_key_hash{$ruleContentToAddOrUpdate})  ) { next; } 
=cut
                    my %new_LVS_class=( 
                            source      =>  $source, 
                            isp         =>  $action{isp},
                            service     =>  $service, 
                            direction   =>  's', 
                            advance     =>  '0', 
                            destination =>  'system', 
                            method      =>  'system', 
                            time        =>  ['0:1439'],
                            table       =>  $defaultPool, 
                            priority    =>  1 
                    ); 
=cut
                    my %new_LVS_class=( 
                        source      =>  $source, 
                        service     =>  $service, 
                        direction   =>  's', 
                        destination =>  'system', 
                        isp         =>  $action{isp}, 
                        advance     =>  '0',     
                        method      =>  'system', 
                        table       =>  $defaultPool,
                        priority    =>  1, 
                        #luke add schedule
                        schedule    =>  'All Week',
                        #luke add qos
                        qos         => 'None' 
                    ); 

                    push( @$classes, \%new_LVS_class );
                }
            }
        }
    }      
    elsif ( $action{action} eq "REPORT" )
    {
        print qq (<fieldset><legend><font class="subtitle">Policy Routing Configuration</font></legend>);
        
        foreach my $view ('nat', 'dmz', 'lvs')
        {
            my $classes=$iniroute->{$view}->[0]->{class};
            print qq (<div class="reportdiv">);
            print qq ( | $view | <br>);
            foreach my $class ( @$classes )
            {
                if ( $class->{service} eq 'system' ) { next; }
                foreach my $key ( keys %$class ) { if ( $key=~m/time|sip/ ) { next; } print qq ( [ $key:$class->{$key} ] );  } 
                print qq (<br>);

                my $timeseg=$class->{time};
                foreach my $time ( @$timeseg ) { print qq ( [ $time ] ); }
                print qq (<br>);

                my $sip=$class->{sip};
                foreach my $ip ( @$sip ) { print qq ( [ $ip ] ); }
                print qq (<br>);
            }

            print qq (<hr size="1">);
        }
        print qq (</div>);
        print qq (</fieldset>);
    }
    

    #======== Update iniroute.xml =============================
    XMLwrite($iniroute, $gPATH."iniroute.xml");
}
#maintainIniroute


################################## Method for both Policy Routing and Policy TC ###################################################### 

#===================================================================================================
#maintainProute(%action)
sub maintainProute 
{
    my (%action)=@_;

    if ( !$action{action} ) { return; }
    
    my $proute=XMLread($gPATH."proute.xml");

    if ( $action{action}=~m/^UPDATEQBROUTE$/ ) 
    {
        my @isplist=maintainBasic(action=>'GETGOODIIDLIST');
        my %ispsubnethash=maintainBasic(action=>'GETISPSUBNETHASH');
        my %dmzstatus=maintainZone(action=>'GETALLDMZSTATUS');
        my @allQBRules;

        foreach my $isp ( @isplist )
        {
            my $serviceName='ISP'.$isp;
            my $fwmarkValue='0x'.dec2hex(1000+$isp);
            my $ispTable=100+$isp;
            my %newClass=(fwmark=>$fwmarkValue, service=>$serviceName, route_table=>$ispTable, time=>['0:1439'], natmethod=>'ls', priority=>"4500");
            push( @allQBRules, \%newClass);

            my @systemAndVIP=maintainIPBank(action=>'READSYSTEMANDPUBLICIP', isp=>$isp);
            # nancy 041110
            my @forbiddenip=maintainIPBank(from=>"isp${isp}dmz", action=>'read');
            my @suitableIP;
            get_union_set(\@suitableIP, \@systemAndVIP);
            get_diff_set(\@suitableIP, \@forbiddenip);
	    # foreach my $ip ( @suitableIP) {$gMSGPROMPT.=qq ( suitable $ip \\n); }
            # foreach my $ip ( @systemAndVIP )
            foreach my $ip ( @suitableIP )
            {
                
                my %newClass=( source=>$ip.'/32', route_table=>$ispTable, time=>['0:1439'], priority=>"5000");
                push( @allQBRules, \%newClass );
            }


            #if ( $dmzstatus{$isp} )
            if ( $dmzstatus{$isp} && $ispsubnethash{$isp} ) #20100622 Don't add route to GRE Bridge
            {
                my %newClass=( source=>$ispsubnethash{$isp}, route_table=>$ispTable, time=>['0:1439'], priority=>"30000");
                push( @allQBRules, \%newClass );
            }
        }

        my @internalZones=maintainZone(action=>'GETNATZONES');
        foreach my $izone ( @internalZones )
        {   
            my $ispid=findMyISP(subnet=>$izone);
            my $ispTable=100+$ispid;

            if ( $ispid )  # ??  or this if ( $ispid && $dmzstatus{$ispid} )
            {
                my %newClass=( source=>$izone, route_table=>$ispTable, time=>['0:1439'], priority=>"31000");
                push( @allQBRules, \%newClass );
            }
        }
        
        $proute->{qb}->[0]->{class}=\@allQBRules;
    }
    elsif ( $action{action}=~m/^ADDQBROUTE$/ ) 
    {
        my $isp = $action{isp};
        my $ip = $action{ip};
        #my %ispsubnethash=maintainBasic(action=>'GETISPSUBNETHASH');
        #my %dmzstatus=maintainZone(action=>'GETALLDMZSTATUS');
        #my @allQBRules;
        my $num = 0;
        my $allQBRules = $proute->{qb}->[0]->{class};
        foreach my $qb ( @$allQBRules ) { $num++; }
        
        if ( $action{type} eq 'ISP' )
        {
            my $exist = 0;
            my $table = 100 + $isp;
            foreach my $qbrule ( @$allQBRules )
            {
                if ( $qbrule->{priority} eq '5000' && $qbrule->{route_table} eq $table ) 
                { 
                    $exist = 1;
                    $qbrule->{source} = $ip;
                    last;
                }
            }
            if ( !$exist )
            {
                my @tmparray;
                my $serviceName='ISP'.$isp;
                my $fwmarkValue='0x'.dec2hex(1000+$isp);
                my $ispTable=100+$isp;
                my %newClass=(fwmark=>$fwmarkValue, service=>$serviceName, route_table=>$ispTable, time=>['0:1439'], natmethod=>'ls', priority=>"4500");
                if ( !$num )
                {
                    push( @tmparray, \%newClass);
                }
                else
                {
                    push( @$allQBRules, \%newClass);
                }
                my %newClass=( source=>$ip.'/32', route_table=>$ispTable, time=>['0:1439'], priority=>"5000");
                if ( !$num )
                {
                    push( @tmparray, \%newClass);
                }
                else
                {
                    push( @$allQBRules, \%newClass);
                }
                if ( !$num ) { $proute->{qb}->[0]->{class} = \@tmparray; }
            }
        }
        elsif ( $action{type} eq 'PUBLICIP' )
        {
            my $systemip = maintainBasic(action=>'GTEIPBYID', iid=>$isp);
            foreach my $item ( @$ip )
            {
                if ( $item ne $systemip )
                {
                    my $ispTable=100+$isp;
                    my %newClass=( source=>$item.'/32', route_table=>$ispTable, time=>['0:1439'], priority=>"5000");
                    push( @$allQBRules, \%newClass);
                }
            }
        }
    }
    elsif ( $action{action} =~ m/^DELQBROUTE$/ )
    {
        my $qbclass = $proute->{qb}->[0]->{class};
        my $isp = $action{isp};
        my $table = 100 + $isp;
        my @tmparray;
        
        foreach my $qb ( @$qbclass )
        {
            if ( $qb->{route_table} eq $table ) { next; }
            push(@tmparray, $qb);
        }
        $proute->{qb}->[0]->{class} = \@tmparray;
    }
    elsif ( $action{action} =~ m/^DELQBROUTEIP$/ )
    {
        my $qbclass = $proute->{qb}->[0]->{class};
        my $iip = $action{iip}.'/32';
        my $isp = $action{isp};
        my $table = 100 + $isp;
        my @tmparray;
        foreach my $qb ( @$qbclass )
        {
            if ( $qb->{route_table} eq $table && $qb->{source} eq $iip && $qb->{priority} eq "5000") { next; }
            push(@tmparray, $qb);
        }
        $proute->{qb}->[0]->{class} = \@tmparray;
    }
    elsif ( $action{action} =~ m/^ADDMPV$/)
    {
        my $qbclass = $proute->{qb}->[0]->{class};
        my $isp = $action{isp};
        my $ip = $action{ip};
        
        my $serviceName='ISP'.$isp;
        my $fwmarkValue='0x'.dec2hex(1000+$isp);
        my $ispTable=100+$isp;
        my %newClass=(fwmark=>$fwmarkValue, service=>$serviceName, route_table=>$ispTable, time=>['0:1439'], natmethod=>'ls', priority=>"4500");
        #push( @allQBRules, \%newClass);
        push( @$qbclass, \%newClass);
        my %newClass=( source=>$ip.'/32', route_table=>$ispTable, time=>['0:1439'], priority=>"5000");
        push( @$qbclass, \%newClass);
    }
    elsif ( $action{action} =~ m/^SAVEMPV$/ )
    {
        my $qbclass = $proute->{qb}->[0]->{class};
        my $isp = $action{isp};
        my $ip = $action{ip};
        my $table = 100 + $isp;
        foreach my $qb ( @$qbclass )
        {
            if ( $qb->{priority} ne '5000' ) { next; }
            if ( $qb->{route_table} eq $table )
            {
                $qb->{source} = $ip.'/32';
                last;
            }
        }
    }
    elsif ( $action{action} =~ m/^DELMPV$/ )
    {
        my $qbclass = $proute->{qb}->[0]->{class};
        my $isp = $action{isp};
        my $table = 100 + $isp;
        my @tmparray;
        
        foreach my $qb ( @$qbclass )
        {
            if ( $qb->{route_table} eq $table ) { next; }
            push(@tmparray, $qb);
        }
        $proute->{qb}->[0]->{class} = \@tmparray;
    }
    
    #======== Update proute.xml =============================
    XMLwrite($proute, $gPATH."proute.xml");
}
#maintainProute


#===================================================================================================
sub ini2via 
{
    my $fwmark=XMLread($gPATH."fwmark.xml");
    my $iniroute=XMLread($gPATH."iniroute.xml");
    my $viaroute=XMLread($gPATH."viaroute.xml");
    ############################################################################################
    # 將  subnet x *.*  的 class 展出來
    ############################################################################################
    #foreach my $view ( 'dmz', 'lvs', 'nat' ) 
    #add application 20101124
    foreach my $view ( 'dmz', 'lvs', 'nat', 'app' ) 
    {
        my @via_route_array_of_this_view;
        my $ini=$iniroute->{$view}->[0]->{class};
        my $markarray=$fwmark->{$view}->[0]->{mark};
        
        #先處理 service 不為 * 的
        foreach my $class ( @$ini ) 
        {
            if ( $class->{service} eq '*' ) { next; } 
            
            # ?? need to be confirmed  to forbidden or warn user not to have this policy
            if ( $class->{dirty} ) { next; }

            $class->{subnettype}=$view;
            push( @via_route_array_of_this_view, $class ); 
        }
            
        #再處理 service 為 * 的  
        foreach my $class ( @$ini ) 
        {
            if( $class->{service} ne '*' ) { next;}
    
            # ?? need to be confirmed  to forbidden or warn user not to have this policy
            if ( $class->{dirty} ) { next; }
            
            #========================================================================
            # collect services from fwmark.xml
            my %allservices; 
            foreach my $mark ( @$markarray ) 
            {
                if ( $mark->{dirty} ) {next;}
                if ( $mark->{service}=~m/^system|^others/ ) { next; }
                if ( $mark->{source} ne $class->{source} ) { next; }
                if ( $view=~m/dmz|nat/ && $mark->{direction} ne $class->{direction} && ($class->{direction} ne '*') ) { next; }
   
                $allservices{ $mark->{service}.':'.$mark->{direction} }=1;
            }
        
            foreach my $serviceitem ( keys(%allservices) ) 
            {
                #檢查這筆是否已經存在 @via_route_array_of_this_view 中
                my $target;
                my $target_exist=0;
                foreach my $item ( @via_route_array_of_this_view ) 
                {
                    if ( $item->{source}.$item->{service}.':'.$item->{direction}.$item->{destination} ne $class->{source}.$serviceitem.$class->{destination} ) { next; }
                    $target_exist=1;
                    $target=$item;
                    last;
                }                      
        
                if ( $target_exist)
                {
                    # 比較 priority --> 數字小的表示優先權較高 <-- 
                    if( $target->{priority} > $class->{priority} ) 
                    {
                        $target->{priority}=$class->{priority};
                        $target->{table}=$class->{table};

                        delete( $target->{sip} );
                        delete( $target->{time} );
                        delete( $target->{qos} );

                        if ( $view=~m/^nat$|^dmz$|^app$/ ) 
                        {
                            my $siparrayptr=$class->{sip}; 
                            my @siparray; foreach my $sip ( @$siparrayptr ) { my %newsip=%$sip; push(@siparray, \%newsip); } 
                            $target->{sip}=\@siparray;    
                        }
     
                        my $timearrayptr=$class->{time};
                        my @time=@$timearrayptr;
                        $target->{time}=\@time;

                        my $qosarrayptr=$class->{qos};
                        my @qosarray; foreach my $qos ( @$qosarrayptr ) { my %newqos=%$qos; push(@qosarray, \%newqos); }
                        $target->{qos}=\@qosarray;
                    }                    
                }
                else  #如果不存在，直接push進去，          
                {
                    my ( $service, $direction )=split(/:/, $serviceitem);
                    my %newClass;
                    $class->{service}=$service; 
                    $class->{direction}=$direction;
                    %newClass=%$class;
                    $newClass{subnettype}=$view;

                    delete( $newClass{sip} );
                    delete( $newClass{time} );
                    delete( $newClass{qos} );

                    if ( $view=~m/^nat$|^dmz$|^app$/ ) 
                    {
                        my $siparrayptr=$class->{sip}; 
                        my @siparray; foreach my $sip ( @$siparrayptr ) { my %newsip=%$sip; push(@siparray, \%newsip); } 
                        $newClass{sip}=\@siparray;
                    }

                    my $timearrayptr=$class->{time};
                    my @time=@$timearrayptr;
                    $newClass{time}=\@time;

                    my $qosarrayptr=$class->{qos};
                    my @qosarray; foreach my $qos ( @$qosarrayptr ) { my %newqos=%$qos; push(@qosarray, \%newqos); }
                    $newClass{qos}=\@qosarray;
              
                    push( @via_route_array_of_this_view, \%newClass );   
                }
            }
        }
        
        $viaroute->{$view}->[0]->{class}=\@via_route_array_of_this_view;
    }

    #===========================
    XMLwrite($viaroute, $gPATH."viaroute.xml");
}
#ini2via


#==============================================================================================
sub viaroute_generate_advance_fwmark
{
    maintainFwmark(type=>'from_service_to');
    maintainFwmark(type=>'from_to');
    maintainFwmark(type=>'from');
    maintainFwmark(type=>'to');
    maintainFwmark(type=>'nat');
    maintainFwmark(type=>'lvs');
}
#viaroute_generate_advance_fwmark


#=====================================================================================
sub generate_all_fwmark_value
{
    my $fwmark=XMLread($gPATH."fwmark.xml");
    
    #================================================
    # Fwmark value allocated before Re-fwmarking
    # reserved          => 0-9999
    # from              => 10000-14999
    # from_service_to   => 15000-19999
    # from_to           => 20000-24999
    # dmz               => 25000-29999
    # lvs               => 30000-34999
    # nat               => 40000-44999
    # to                => 45000-49999
    # unused            => 50000-65535
    #================================================

    my $value=$gFWMARKSTARTVALUE;
    foreach my $group ( 'from', 'from_service_to', 'from_to' , 'dmz', 'lvs', 'nat', 'to' )
    {
        my $fwmarkarray=$fwmark->{$group}->[0]->{mark};
        my $markvalue=$value;
        foreach my $mark ( @$fwmarkarray )
        {
            if ( $mark->{service} eq 'system' ) { next; }

            $mark->{value}="0x".dec2hex($markvalue);

            $markvalue+=5;
        }

        $value+=$gFWMARKINTERVAL;
    }
        
    #--------updating fwmark.xml------------------------ 
    XMLwrite($fwmark, $gPATH."fwmark.xml");
}
#generate_all_fwmark_value


#========================================================================================
sub doReFlowMark
{
    #my ( %reFwmarkHash )=@_;
    #add qos
    my ( %reFwmarkHash ) = %{$_[0]};
    my ( %qosHash ) = %{$_[1]};
    
    my $fwmark=XMLread($gPATH."fwmark.xml");
    
    foreach my $group ( 'from', 'from_service_to', 'from_to' , 'dmz', 'lvs', 'nat', 'to')
    {
        my $fwmarkarray=$fwmark->{$group}->[0]->{mark};
        foreach my $mark ( @$fwmarkarray )
        {
            if ( $mark->{service} eq 'system' ) { next; }
            my $newMark=$reFwmarkHash{$mark->{value}};
            $mark->{qos}=$qosHash{$mark->{value}};
            $mark->{value}=( $newMark ) ? ( $newMark ) : ( '' );
        }
    }
        
    #--------updating fwmark.xml------------------------ 
    XMLwrite($fwmark, $gPATH."fwmark.xml");
}
#doReFlowMark

#========================================================================================
sub reFindSafeTable 
{
    my (%action)=@_;
    my $safeTable=$gALLPATH;

    #========================================================================================
    # 1. if $action{subnet} belongs to an ISP, return $gALLPATH + $belongiid  
    my $belongiid=maintainBasic( action=>'GETBELONGIID', subnet=>$action{subnet} ); 

    if ( $belongiid )
    {
        $safeTable=$gALLPATH + $belongiid;
        
        return $safeTable;
    } 
        
    #========================================================================================
    # 2. if $action{subnet} belongs to an Internal ZONE routed via a DMZ gateway of a certain ISP, return $gALLPATH + $dmzisp  
    #  2013-0611 Brian to correct it
    #my $ispid=maintainZone( action=>'GETWANIDOFBELONGNAT',subnet=>$action{subnet} );
    #my $ispid=maintainZone( action=>'GETISPIDOFBELONGNAT',subnet=>$action{subnet} );
    my $ispid="";
    
    if ( $ispid ) 
    {   
        #=========================================================================================
        # 2.1 if $action{subnet} is in well-known private ip range
        my @ipfields=split(/\/|\./, $action{subnet});
        my $isPrivate=0;
        
        if ( $ipfields[0] == 10 ) { $isPrivate=1; }
        elsif ( $ipfields[0] == 172 && ($ipfields[1] >= 16 && $ipfields[1] <= 31) ) { $isPrivate=1; }
        elsif ( $ipfields[0] == 192 && $ipfields[1] == 168 ) { $ispPrivate=1; }

        if ( $isPrivate )
        {
            return $safeTable;
        }
        
        #=========================================================================================
        # 2.2 if $action{subnet} is NOT in well-known private ip range
        if ( $ispid ) 
        { 
            $safeTable=$gALLPATH + $ispid; 
            
            return $safeTable;
        }
    }

    return $safeTable;
}
#reFindSafeTable


#========================================================================================
sub findMyISP 
{
    my (%action)=@_;

    #==========================================================================================
    # 1. if $action{subnet} belongs to an ISP, return $belongiid  
    my $belongiid=maintainBasic( action=>'GETBELONGIID', subnet=>$action{subnet} ); 
    
    if ( $belongiid ) { return $belongiid; } 
     
    #==========================================================================================
    # 2. if $action{subnet} belongs to an Internal ZONE routed via a DMZ gateway of a certain ISP, return $dmzisp  
    #  2013-0611 Brian to correct it
    #my $ispid=maintainZone( action=>'GETWANIDOFBELONGNAT',subnet=>$action{subnet} );
    #my $ispid=maintainZone( action=>'GETISPIDOFBELONGNAT',subnet=>$action{subnet} );
    my $ispid="";
    #  2013-0604 Gary modify because not use
    #my $ispid=0;

    
    if ( $ispid ) 
    {   
        return $ispid;
    }
    else
    {
        return 0;
    }
}
#findMyISP


#========================================================================================
sub batchFindMyISP 
{
    my @sourcelist=@_;

    #========================================================================================
    # define source2isp hash , we will return this back to caller
    my %source2isp;

    #==========================================================================================
    # prepare  for Phase 1
    my %isp2subnet=maintainBasic( action=>'GETISPSUBNETHASH' );

    foreach my $source ( @sourcelist )
    {
        #==========================================================================================
        # step 1. if $source belongs to an ISP, save $belongiid into source2isp hash
        my $belongiid;
        foreach my $isp ( keys %isp2subnet )
        {
            my $result=subnet_belong_check( $source, $isp2subnet{$isp} );
            if ( $result == 1 || $result==3 ) { $belongiid=$isp; last; }
        }

        # if isp has been found, save it into hash source2isp
        if ( $belongiid ) {    $source2isp{$source}=$belongiid; } 
    }
    
    
    #==========================================================================================
    # prepare for Phase 2
    my %nat2isp=maintainZone( action=>'GETNAT2ISP' );
     
    foreach my $source ( @sourcelist )
    {
        # if isp of this source has been determinated in Phase 1, just do next source
        if ( exists( $source2isp{$source} ) ) { next; }

        #==========================================================================================
        # step 1. find isp of the  Internal Zone $source belongs to 
        my $ispid;
        foreach my $natsubnet ( keys %nat2isp )
        {
            my $result=subnet_belong_check( $source, $natsubnet );
            if ( $result == 1 || $result==3 ) 
            { 
                if ( $nat2isp{$natsubnet} )
                {
                    $source2isp{$source}=$nat2isp{$natsubnet}; 
                    last; 
                }
            }
        }
    }

    return %source2isp;
}
#batchFindMyISP


#========================================================================================
sub via2prt 
{
    #@dep
    viaroute_generate_advance_fwmark();  

    #@dep
    generate_all_fwmark_value();

    my $fwmark   = XMLread($gPATH.'fwmark.xml');
    my $viaroute = XMLread($gPATH.'viaroute.xml');
    my $proute   = XMLread($gPATH.'proute.xml');
    my $rtable   = XMLread($gPATH.'rtable.xml');
    my $hostref=XMLread($gPATH.'host.xml');
    my $hostlist=$hostref->{host};
    my $alltables=$rtable->{table};
    my %rtableHash;
    my %fwmarkvalue;
    my %reFwmarkHash;
    my %qosHash;
    
    # We will divide all the packets into 5 type  of containers 
    my ( @to, @subnet, @fwmark, @subadv, @fwadv);
    
    #Establishing the Hash of routing tables
    foreach my $table ( @$alltables ) { $rtableHash{$table->{table_num}}=$table; }
    
    # Establishing the Hash of flow marks
    # take attention !! nat must before 'from_service_to', 'from_to', 'from', 'to' 
    foreach my $group ( 'dmz', 'lvs', 'nat', 'from_service_to', 'from_to', 'from', 'to')
    {
        my $fwmarkarray=$fwmark->{$group}->[0]->{mark};
        foreach my $mark ( @$fwmarkarray )
        {
            if ( $mark->{service} eq 'system' ) { next; }
            #my $markkey=$mark->{source}.$mark->{service}.$mark->{direction}.$mark->{destination};
            #201012224 add schedule
            my $markkey=$mark->{source}.$mark->{service}.$mark->{direction}.$mark->{destination}.$mark->{schedule};
            $fwmarkvalue{$markkey}=$mark->{value};
        }
    }
    
    foreach my $view ( 'dmz', 'nat', 'lvs', 'app') 
    {
        my $viaclassarray=$viaroute->{$view}->[0]->{class};
    
        foreach my $class ( @$viaclassarray ) 
        {
            if ( $class->{service} eq 'system' ) { next; }
            my @src_array;
            my @dest_array;
            my $src_type;
            my $dest_type;
            if ( grep(/^host-/, $class->{source}))
            {
                foreach my $host ( @$hostlist )
                {
                    if ( $host->{hostname} eq $class->{source} )
                    {
                        $src_type = $host->{hosttype};
                        @src_array = split(/,/, $host->{hostaddress}); 
                        last;
                    }
                }
            }
            else
            {
                $src_type = 'normal';
                push(@src_array, $class->{source});
                #$newclass{sourcetype}='normal';
            }
            
            if ( grep(/^host-/, $class->{destination}) )
            {
                foreach my $host ( @$hostlist )
                {
                    if ( $host->{hostname} eq $class->{destination} )
                    {
                        $dest_type = $host->{hosttype};
                        @dest_array = split(/,/, $host->{hostaddress});
                        last;
                    }
                }
            }
            else
            {
                $dest_type = 'normal';
                push(@dest_array, $class->{destination});
            }
            foreach my $src ( @src_array )
            {
                foreach my $dest ( @dest_array )
                {
                    
                    #Prepare new rule class hash variable to collect all the information   
                    my (%newclass);
                    
                    #=================================================
                    # Make decision on what natmethod and sip is, according to $view type
                    if ( $view eq 'lvs' ) 
                    {
                        $newclass{natmethod}="";

                        $newclass{sip}="";
                    }
                    elsif ( $view ne 'lvs' ) 
                    {
                        $newclass{natmethod}=$class->{method};
                        
                        my $sipptr=$class->{sip}; 
                        my @siparray; foreach my $sip ( @$sipptr ) { my %newsip=%$sip; push(@siparray, \%newsip); } 
                        $newclass{sip}=\@siparray; 
                        if ( $view eq 'nat' ) 
                        {
                            $newclass{process_me}=$class->{process_me};
                            $newclass{enabled}=$class->{enabled};
                        }
                    }
                            
                    $newclass{subnettype}=$view;
=cut
#start
                    if ( grep(/^host-/, $class->{source}))
                    {
                        foreach my $host ( @$hostlist )
                        {
                            if ( $host->{hostname} eq $class->{source} )
                            {
                                $newclass{source}=$host->{hostaddress}; 
                                $newclass{sourcetype}=$host->{hosttype};
                                last;
                            }
                        }
                    }
                    else
                    {
                        $newclass{source}=$class->{source};
                        $newclass{sourcetype}='normal';
                    }
                    
                    if ( grep(/^host-/, $class->{destination}) )
                    {
                        foreach my $host ( @$hostlist )
                        {
                            if ( $host->{hostname} eq $class->{destination} )
                            {
                                $newclass{destination}=$host->{hostaddress};
                                $newclass{destinationtype}=$host->{hosttype};
                                last;
                            }
                        }
                    }
                    else
                    {
                        $newclass{destination}=$class->{destination};
                        $newclass{destinationtype}='normal';
                    }
#end
=cut
                    $newclass{service}=$class->{service};
                    $newclass{direction}=$class->{direction};
                    $newclass{route_table}=$class->{table};
                    
                    my $timearrayptr=$class->{time};
                    my @time=@$timearrayptr; $newclass{time}=\@time;
                    
                    my $qosptr=$class->{qos}; 
                    my @qosarray; foreach my $qos ( @$qosptr ) { my %newqos=%$qos; push(@qosarray, \%newqos); } 
                    $newclass{qos}=\@qosarray; 
                    
                    #my $markkey=$class->{source}.$class->{service}.$class->{direction}.$class->{destination}; 
                    #for host obj
                    #my $markkey=$newclass{source}.$class->{service}.$class->{direction}.$class->{destination}; 
                    #20101224 add schedule
                    #my $markkey=$newclass{source}.$class->{service}.$class->{direction}.$class->{destination}.$class->{schedule}; 
=cut
#start
                    my $srckey = $newclass{source};
                    my $dstkey = $newclass{destination};
                    #if ( $newclass{sourcetype} eq 'iplist' )
                    my @src_array;
                    my @dest_array;
                    if ( $newclass{sourcetype} eq 'iplist' || $newclass{sourcetype} eq 'networklist' )
                    {
                       #my @iparray = split(/,/, $newclass{source}); 
                       #$srckey = $iparray[0];
                       @src_array = split(/,/, $newclass{source});
                    }
                    else
                    {
                        push(@src_array, $newclass{source});
                    }
                    
                    if ( $newclass{destinationtype} eq 'iplist' || $newclass{destinationtype} eq 'networklist' || $newclass{destinationtype} eq 'fqdnlist' )
                    {
                       #my @iparray = split(/,/, $newclass{destination}); 
                       #$dstkey = $iparray[0];
                       @dest_array = split(/,/, $newclass{destination});
                    }
                    else
                    {
                        push(@dest_array, $newclass{destination});
                    }
#end
=cut
                    
                    $newclass{source}=$src;
                    # 20140214 looks wrong. Gary hide deatination
                    # $newclass{deatination}=$dest;
                    #my $markkey=$srckey.$class->{service}.$class->{direction}.$dstkey.$class->{schedule};
                    my $markkey=$src.$class->{service}.$class->{direction}.$dest.$class->{schedule};
                    my $markvalue=$fwmarkvalue{$markkey};
                    
                    # Re Flow Mark Section:  Judge if Re-FlowMark is needed
                    my $refwmarktable=$newclass{route_table};
                    my $refwmarkvalue=$markvalue;
                    

                    #=================================================================================
                    #  making decision for Re-flow mark value ==> very important Procedure

                    $refwmarkvalue=~s/0x//;                         # get rid of the "0x" hex header
                    $refwmarkvalue=hex($refwmarkvalue);             # hex to decimal translation
                    
                    
                    #=================================================================================
                    #0. set table byte
                    $refwmarkvalue |= ($refwmarktable << 16 );                 
                    
                    #1. set Cache refresh bit
                    $refwmarkvalue |= 0x01000000  if ( $rtableHash{$newclass{route_table}}->{aggregate} );                           

                    #2. set FAST Way routing mode 
                    $refwmarkvalue |= 0x02000000  if ( $rtableHash{$newclass{route_table}}->{mode}=~m/FAST/ );  
                    
                    #3. set SAFE route bit
                    $refwmarkvalue |= 0x04000000  if ( $newclass{route_table} eq  $gALLPATH );  
                    
                    #4. if NAT method is set to LS or FAST Way routing mode is selected, set this bit on
                    if ($newclass{route_table} ne $gDROP) 
                    {
                    $refwmarkvalue |= 0x08000000  if ( $newclass{natmethod} eq "ls" || $rtableHash{$newclass{route_table}}->{mode}=~m/FAST/ ); 
                    }
         
                    #5. set RRG route bit
                    $refwmarkvalue |= 0x10000000  if ( $newclass{route_table} eq $gRRG ); 

                    #6. set BSWT, WLC, FRTT route bit
                    #$refwmarkvalue |= 0x20000000  if ( $rtableHash{$newclass{route_table}}->{mode}=~m/^BSWLT$|^WLC$|^BTK$|^FRTT$/ );  
                    #20110411
                    $refwmarkvalue |= 0x20000000  if ( $rtableHash{$newclass{route_table}}->{mode}=~m/^BSWLT$|^USWLT$|^DSWLT$|^WLC$|^BTK$|^FRTT$|^BBL$|^BBLP$/ );  
                    
                    #shreFwmarkHash7. 0x40000000 is assigned to inbond QoS

                    #8. 0x80000000 is unused now
                    #=================================================================================

                    $refwmarkvalue='0x'.dec2hex($refwmarkvalue);    #decimal to hex translation
                    
                    #=================================================================================
                    # Reassign New fwmark value  
                    $newclass{fwmark}=$refwmarkvalue;
                    
                    #=================================================================================
                    # Prepare refwmark hash to  call  Re-FlowMark 
                    # In version 2.2.0.xxxx : we have the feature of time-based policy routing 
                    # So, after re-flowmarking , we might have more than one fwmark values concatenated by the character ':', and stored back to fwmark.xml
                
                    if ( !exists($reFwmarkHash{$markvalue}) ) 
                    { 
                        $reFwmarkHash{$markvalue}=$refwmarkvalue; 
                        $qosHash{$markvalue}=$class->{qos};
                        #for iplist
                        #if ( $newclass{sourcetype} eq 'iplist' || $newclass{sourcetype} eq 'networklist' )
                        #{
                            #my @iparray=split(/,/, $newclass{source});
                            #foreach my $ip ( @iparray )
                            #{
                            #    my @dstarray=split(/,/, $newclass{destination});
                            #    foreach my $dst ( @dstarray )
                            #    {
                                    my $key=$src.$class->{service}.$class->{direction}.$dest.$class->{schedule};
                                    my $tempvalue=$fwmarkvalue{$key};
                                    $reFwmarkHash{$tempvalue}=$refwmarkvalue;
                             	    $qosHash{$tempvalue}=$class->{qos};
                            # 	}
                            #}
                        #}
                    }
                    else 
                    {
                        $reFwmarkHash{$markvalue}=~s/$refwmarkvalue:*//;
                        $reFwmarkHash{$markvalue}.=( $reFwmarkHash{$markvalue} ) ? ( ':'.$refwmarkvalue ) : ( $refwmarkvalue ); 
                        $qosHash{$markvalue}=$class->{qos};
                    }
                    #===============================================================================
                    

                    #===============================================================================
                    # re-find SAFE table
                    if ( $newclass{route_table} eq $gALLPATH )
                    {   
                        $newclass{route_table}=reFindSafeTable(subnet=>$newclass{source});
                    }


                    #===============================================================================
                    #  Grouping ...
                    #===============================================================================
                    # 根據 service 及 advance 來決定要讀入 $newclass 中的值
                    #luke new schedule
                    my @allday=("0:1439"); 
                    $newclass{time}=\@allday;
                    $newclass{schedule}=$class->{schedule};
                    
                    
                    if ( $class->{source} eq "0.0.0.0/0" && $class->{advance}==1 ) 
                    {
                        #$newclass{destination}=$class->{destination};
                        $newclass{priority}=5000;
                        push ( @to, \%newclass );
                    }
                    elsif ( $class->{service}  ne "others" && $class->{advance}==1 ) 
                    {
                        #$newclass{destination}=$class->{destination};
                        $newclass{priority}=10000;
                        push ( @fwadv, \%newclass );
                    }
                    elsif ( $class->{service} eq "others" && $class->{advance}==1 ) 
                    {
                        #$newclass{destination}=$class->{destination};
                        $newclass{priority}=15000;
                        #runCommand(command=>'echo', params=>"$newclass{source} >>/tmp/jjj");
                        push ( @subadv, \%newclass );
                    }
                    elsif ( $class->{service}  ne "others" && $class->{advance}==0 ) 
                    {
                        $newclass{destination}="";
                        $newclass{priority}=20000;
                        push ( @fwmark, \%newclass );
                    }
                    elsif ( $class->{service} eq "others" && $class->{advance}==0 ) 
                    {
                        $newclass{destination}="";
                        if ( $class->{enabled} eq '0' ) {  $newclass{enabled}=$class->{enabled};  }
                        else                            {  $newclass{enabled}='1';		  }
                        #runCommand(command=>'echo', params=>"$newclass{source} >>/tmp/kkk");
                        $newclass{priority}=25000;
                        push ( @subnet, \%newclass );
                    }
                }
            }
        }
    }
    
    
    #========================================================================  
    # Save \@to, \@subnet, \@subadv, \@fwmark, \@fwadv into the XML Reference variable $prout 
    $proute->{to}->[0]->{class}=\@to;
    $proute->{sub}->[0]->{class}=\@subnet;
    $proute->{subadv}->[0]->{class}=\@subadv;
    $proute->{fw}->[0]->{class}=\@fwmark;
    $proute->{fwadv}->[0]->{class}=\@fwadv;
    
    #========================================================================
    # Do Re-flow Mark
    doReFlowMark( \%reFwmarkHash , \%qosHash );
    #doReFlowMark( %reFwmarkHash );

    XMLwrite($proute, $gPATH."proute.xml");

    # generat shell script for policy-based traffic control named /usr/local/apache/qb/ptcscript
    #writePtcShellScript();
    #
    write_qosscript();
}
#via2prt
#####################################################
# name: write_qosscript
# purpose: generate qos script
#####################################################
sub write_qosscript()
{
    #runCommand(command=>'/usr/local/apache/qbconf/delall', params=>'');
    my $qosref=XMLread($gPATH.'qos.xml');
    my $qoslist=$qosref->{qos};
    
    my $qoslanref=XMLread($gPATH.'qoslan.xml');
    my $qoslanlist=$qoslanref->{qos};
    
    
    my $natref=XMLread($gPATH.'zonecfg.xml');
    my $natarray=$natref->{nat};
    
    my $iniroute=XMLread($gPATH."iniroute.xml");
    my $classes=$iniroute->{nat}->[0]->{class};
    my $ispref=XMLread($gPATH."basic.xml");
    my $isplist=$ispref->{isp};
    my $fwmark=XMLread($gPATH."fwmark.xml");
    my $rtable=XMLread($gPATH.'rtable.xml');
    my $rtablelist=$rtable->{table};
    my $qossource;
    #my $tmpscript="/tmp/qos.sh";
    my %qossubnet;
    my @qosisp;
    my @alldev;
    
    #======================================================
    # QoS of LAN
    #======================================================
    my $imqnum = 0;
    my %LAN_IMQ;
    my %LAN_classid;
    foreach my $nat ( @$natarray ) 
    {
        my @nicarray = keys %LAN_IMQ;
        if ( $nat->{natid} eq 'system' ) { next; }
        if ( !grep(/^$nat->{nic}$/, @nicarray) )
        {
            $LAN_IMQ{$nat->{nic}} = $imqnum;
            $LAN_classid{$nat->{nic}} = 4;
            push(@alldev, $nat->{nic});
            push(@alldev, 'imq'.$LAN_IMQ{$nat->{nic}});
            $imqnum++;
        }
    }
    my $qoslan_script = "/usr/local/apache/qbconf/qoslan.sh";
    if ( !open(QOSLAN, ">$qoslan_script") )
    {
        print "open qoslan.sh fail!!\n";
        return;
    }
    
    foreach my $item ( keys %LAN_IMQ )
    {
        print QOSLAN qq "/sbin/tc qdisc del dev $item root handle 100: htb default 3\n";
        print QOSLAN qq "/sbin/tc qdisc add dev $item root handle 100: htb default 3\n";
        print QOSLAN qq "/sbin/tc qdisc del dev imq$LAN_IMQ{$item} root handle 100: htb default 3\n";
        print QOSLAN qq "/sbin/tc qdisc add dev imq$LAN_IMQ{$item} root handle 100: htb default 3\n";
        
        #################### IPv6 Qos - shane 20130426 ###############################
        foreach my $natt ( @$natarray )
        {
            if ( $nat->{natid} eq 'system' ) { next; }
            if ($item eq $natt->{nic} )
            {
                if (grep(/:/,$natt->{ip}))
                {
                    print QOSLAN qq "/sbin/ip6tables -t mangle -A PREROUTING -i $item -j IMQ --todev $LAN_IMQ{$item}\n";
                }else
                {
                    print QOSLAN qq "/sbin/iptables -t mangle -A PREROUTING -i $item -j IMQ --todev $LAN_IMQ{$item}\n";
                }
            }
        }
    }
    foreach my $item ( @$qoslanlist )
    {
        if ( $item->{source} eq '' ) { next; }
        my $nic = $item->{nic};
        my $imq = $LAN_IMQ{$nic};
        my @iplist;
                
        if ( $LAN_classid{$nic} == 4 )
        {
            print QOSLAN qq "\#set default class\n";
            print QOSLAN qq "/sbin/tc class add dev imq$imq parent 100: classid 100:3 htb rate 10240000kbit ceil 1024000kbit\n";
            print QOSLAN qq "/sbin/tc class add dev $nic parent 100: classid 100:3 htb rate 10240000kbit ceil 1024000kbit\n\n";
        }
        $qossource=$item->{source};        
        print QOSLAN qq "\#QoS of $item->{source}\n";
        if ( $item->{qostype} eq 'Share' )
        {
            
             my $classid = $LAN_classid{$nic};
            
             if ( grep(/-/, $item->{source}) )
             {
                  @iplist = get_allocated_ip($item->{source});
             }
             else
             {
                  push(@iplist, $item->{source});
             }
                        
             print QOSLAN qq "/sbin/tc class add dev imq$imq parent 100:3 classid 100:$classid htb "; 
             print QOSLAN qq "rate $item->{uploadmin}kbit ceil $item->{uploadmax}\kbit prio 0\n";
             print QOSLAN qq "/sbin/tc class add dev $nic parent 100:3 classid 100:$classid htb ";
             print QOSLAN qq "rate $item->{downloadmin}kbit ceil $item->{downloadmax}\kbit prio 0\n\n";
             print QOSLAN qq "/sbin/tc qdisc add dev imq$imq parent 100:$classid handle $classid: sfq perturb 10\n";
             print QOSLAN qq "/sbin/tc qdisc add dev $nic parent 100:$classid handle $classid: sfq perturb 10\n";
                    	        
             foreach my $ip ( @iplist )
             {
                  ###############IPv6 Qos - shane 20130426 ###########################
                  if (grep(/:/,$ip))
                  {
                      print QOSLAN qq "/sbin/tc filter add dev imq$imq parent 100: prio $item->{priority} protocol ipv6 u32\\\n";
                      print QOSLAN qq "\tmatch ip6 src $ip\\\n";
                      print QOSLAN qq "\tflowid 100:$classid\n\n";
                  
                      print QOSLAN qq "/sbin/tc filter add dev $nic parent 100: prio $item->{priority} protocol ipv6 u32\\\n";
                      print QOSLAN qq "\tmatch ip6 dst $ip\\\n";    
                      print QOSLAN qq "\tflowid 100:$classid\n\n";
                  }else
                  {
                      print QOSLAN qq "/sbin/tc filter add dev imq$imq parent 100: prio $item->{priority} protocol ip u32\\\n";
                      print QOSLAN qq "\tmatch ip src $ip\\\n";
                      print QOSLAN qq "\tflowid 100:$classid\n\n";
                    	        
                      print QOSLAN qq "/sbin/tc filter add dev $nic parent 100: prio $item->{priority} protocol ip u32\\\n";
                      print QOSLAN qq "\tmatch ip dst $ip\\\n";
                      print QOSLAN qq "\tflowid 100:$classid\n\n";
                  }
             }
             $LAN_classid{$nic}++;
         }
         else
         {
             if ( grep(/-/, $item->{source}) || grep(/\//, $item->{source}) )
             {
                 @iplist = get_allocated_ip($item->{source});
             }
             else
             {
                 push(@iplist, $item->{source});
             }
                	
             foreach my $ip ( @iplist )
             {
                 my $classid = $LAN_classid{$nic};
                 print QOSLAN qq "/sbin/tc class add dev imq$imq parent 100:3 classid 100:$classid htb "; 
                 print QOSLAN qq "rate $item->{uploadmin}kbit ceil $item->{uploadmax}\kbit prio 0\n";
                 print QOSLAN qq "/sbin/tc class add dev $nic parent 100:3 classid 100:$classid htb ";
                 print QOSLAN qq "rate $item->{downloadmin}kbit ceil $item->{downloadmax}\kbit prio 0\n";
                    	    
                 print QOSLAN qq "/sbin/tc qdisc add dev imq$imq parent 100:$classid handle $classid: sfq perturb 10\n";
                 print QOSLAN qq "/sbin/tc qdisc add dev $nic parent 100:$classid handle $classid: sfq perturb 10\n";
                                    
                 ############## IPv6 Qos - shane 20130426 #########################
                 if (grep(/:/,$ip))
                 {
                     print QOSLAN qq "/sbin/tc filter add dev imq$imq parent 100: prio $item->{priority} protocol ipv6 u32\\\n";
                     print QOSLAN qq "\tmatch ip6 src $ip\\\n";
                     print QOSLAN qq "\tflowid 100:$classid\n\n";
                     
                     print QOSLAN qq "/sbin/tc filter add dev $nic parent 100: prio $item->{priority} protocol ipv6 u32\\\n";
                     print QOSLAN qq "\tmatch ip6 dst $ip\\\n";
                     print QOSLAN qq "\tflowid 100:$classid\n\n";
                 }else
                 {
                     print QOSLAN qq "/sbin/tc filter add dev imq$imq parent 100: prio $item->{priority} protocol ip u32\\\n";
                     print QOSLAN qq "\tmatch ip src $ip\\\n";
                     print QOSLAN qq "\tflowid 100:$classid\n\n";
                    	        
                     print QOSLAN qq "/sbin/tc filter add dev $nic parent 100: prio $item->{priority} protocol ip u32\\\n";
                     print QOSLAN qq "\tmatch ip dst $ip\\\n";
                     print QOSLAN qq "\tflowid 100:$classid\n\n";
                 }
                 $LAN_classid{$nic}++;
              }
          }
    }
    close(QOSLAN);
    chmod(0777, $qoslan_script);
    
    my $qospolicy_script = "/usr/local/apache/qbconf/qos.sh";
    if ( !open(QOS, ">$qospolicy_script") )
    {
        print "open qospolicy.sh fail!!\n";
        return;
    }
    #======================================================
    # QoS of Policy
    #======================================================
    my $classid = 4;
    #my $imqnum = 0;
    my %ispimqin;
    my %ispimqout;
    my $bisubnet;
    my $brc;
    my $brn;
    my $oimq = 9;
    my $iimq = 10;
                                
    foreach my $group ( 'from', 'from_service_to', 'from_to' , 'dmz', 'lvs', 'nat', 'to' )
    {
        my $fwmarkarray=$fwmark->{$group}->[0]->{mark};

        foreach my $fw ( @$fwmarkarray )
        {
            my @iplist;
            #to check fwmark qos field
            if ( $fw->{qos} ne '' && $fw->{qos} ne 'None' )
            {
                #get table number
                my $table=substr($fw->{value}, -6, 2);
                $table=hex2dec($table);
                my $imqout;
                my $imqin;
                my $uploadmin;
                my $uploadmax;
                my $downloadmin;
                my $downloadmax;
                my $priority;
                my $qosname;
                my $uploadmark=$fw->{value};
                my $downloadmark= 0x40000000 | hex2dec($fw->{value});
                $downloadmark = '0x'.dec2hex($downloadmark);

                #get qos object
                foreach my $qos ( @$qoslist )
                {
                    if ( $qos->{qosname} eq $fw->{qos} )
                    {
                        $qosname = $qos->{qosname};
                        $qostype = $qos->{qostype};
                        $uploadmin = $qos->{uploadmin};
                        $uploadmax = $qos->{uploadmax};
                        $downloadmin = $qos->{downloadmin};
                        $downloadmax = $qos->{downloadmax};
                        $priority = $qos->{priority};
                        $type = $qos->{type};
                        $pool = $qos->{pool};
                        $qosisp = $qos->{isp};
                        $bisubnet = $fw->{source} ;
                        last;
                    }
                }
		#get table
		foreach my $rt ( @$rtablelist )
                {
                    if ( $rt->{table_num} eq $table )
                    {
                        my $pathlist=$rt->{path};
                        my $total_weight=0;
                        foreach my $item ( @$pathlist ) { $total_weight += $item->{weight}; }
                        print TEMP qq "\#Qos of fwmark $uploadmark \n";
                        my $matchqosisp = 1;
                        foreach my $item ( @$pathlist )
                        {
                            #my ($imqout, $imqin) = getimqnum($item->{isp});
                            #my ($imqout, $imqin);
                            if ( !$ispimqin{$item->{isp}} )
                            {
                                $ispimqout{$item->{isp}} = $imqnum++;
                                $ispimqin{$item->{isp}} = $imqnum++;
                            }
                            $imqout = $ispimqout{$item->{isp}}; 
                            $imqin = $ispimqin{$item->{isp}};
                            
                            
                            #push isp to qosisp array for iptables -j --todev $imqnum
                            if ( !grep(/^$item->{isp}$/, @qosisp) )
                            {
                                push(@qosisp, $item->{isp});
                                $qossubnet{$item->{isp}}=$item->{subnet};
                            }
                            my $ispref = maintainBasic( action=>"GETISPINFO", iid=>$item->{isp} );
                            my $gateway = $ispref->{gateway};

			    #find isp of Qos object match table path
			    
                            foreach my $isp ( @$qosisp )
                            {
                                my $iid = $isp->{iid};
                                $iid =~ s/\(.*.\)//g;
                                #if ( $isp->{iid} eq 'ISP'.$item->{isp} )
                                my $zone=XMLread($gPATH.'zonecfg.xml');
                                my $iisp=XMLread($gPATH.'basic.xml');
                                my $zonelist=$zone->{dmz};
                                my $iisplist=$iisp->{isp};
                                foreach my $isp1 ( @$iisplist )
                                {
                               	    
                               	    if ( $iid eq 'ISP'.$isp1->{iid} )     
                               	    {
                               	         foreach my $dmz (@$zonelist)
                               	         {
                               	             if ($dmz->{mode} ne 'BRIDGE' || $dmz->{interface} ne $isp1->{nic}){next;}
                               	             $brc='1';
                               	             $brn=$dmz->{name};
                               	         }
                                    } 
                                }
                                if ( $iid eq 'ISP'.$item->{isp} )
                                {
                                    $path_uploadmin =  $isp->{uploadmin};
                                    $path_uploadmax =  $isp->{uploadmax};
                                    $path_downloadmin = $isp->{downloadmin};
                                    $path_downloadmax = $isp->{downloadmax};
                                    $matchqosisp = 1;
                                    last;
                                }
                                $matchqosisp = 0;
                            }
			    #if fwmark qos is by pool qos object
                            #table path not match qos object to skip generate tc command
                            if ( !$matchqosisp ) { next; }
                            
			    if ($qostype eq 'Individual' && $brc eq '1')
			    {
			    	@iplist = get_allocated_ip($bisubnet);
			    	#my $oimq = 10 + $imqout;
			    	#my $iimq = 10 + $imqin;
			    	my $check=-2;
			    	my $tclass=0;
			    	 
			    	foreach my $ip ( @iplist )
			    	{
			    	   if ($ip ne '' )
			    	   {
			    	       $check++;
			    	       $tclass++;
			    	       if ($check > 660 || $check < 0)
			    	       {
			    	           $oimq+=2;
			    	           $iimq+=2;
			    	          
			    	           print QOS qq "/sbin/tc qdisc del dev imq$iimq root 2>/dev/null\n";
			    	           print QOS qq "/sbin/tc qdisc del dev imq$oimq root 2>/dev/null\n";
			    	           print QOS qq "/sbin/tc qdisc add dev imq$iimq root handle 100: htb default 3\n";
			    	           print QOS qq "/sbin/tc qdisc add dev imq$oimq root handle 100: htb default 3\n";
			    	           print QOS qq "/sbin/tc class add dev imq$oimq parent 100: classid 100:3 htb rate 40960Mbit\n";
			    	           print QOS qq "/sbin/tc class add dev imq$iimq parent 100: classid 100:3 htb rate 40960Mbit\n";
			    	           
			    	           print QOS qq "/sbin/iptables -t mangle -A PREROUTING -i $brn -m mark --mark $downloadmark -d $bisubnet -j IMQ --todev $iimq\n";
			    	           print QOS qq "/sbin/iptables -t mangle -A POSTROUTING -o $brn -m mark --mark $uploadmark -s $bisubnet -j IMQ --todev $oimq\n";
			    	           print QOS qq "/sbin/ip link set imq$iimq up\n";
			    	           print QOS qq "/sbin/ip link set imq$oimq up\n";
			    	      	   $check = 0;	     
			    	       }
			    	       
			    	       if ($tclass eq 3){$tclass++;} 
			    	   	print QOS qq "/sbin/tc class add dev imq$oimq parent 100:3 classid 100:$tclass htb ";
			    	   	print QOS qq "rate $path_uploadmin\kbit ceil $path_uploadmax\kbit prio $priority\n";
			    	   	print QOS qq "/sbin/tc class add dev imq$iimq parent 100:3 classid 100:$tclass htb "; 
			    	   	print QOS qq "rate $path_downloadmin\kbit ceil $path_downloadmax\kbit prio $priority\n";
			    	  	print QOS qq "/sbin/tc qdisc add dev imq$iimq parent 100:$tclass handle $tclass: sfq perturb 10\n";
			    	   	print QOS qq "/sbin/tc qdisc add dev imq$oimq parent 100:$tclass handle $tclass: sfq perturb 10\n";
			    	   
			    	  	print QOS qq "/sbin/tc filter add dev imq$oimq parent 100: prio $priority protocol ip u32 match ip src $ip flowid 100:$tclass\n"; 
			    	   
			    	   	print QOS qq "/sbin/tc filter add dev imq$iimq parent 100: prio $priority protocol ip u32 match ip dst $ip flowid 100:$tclass\n";
			    	        print QOS qq "/sbin/ip link set imq$iimq up\n";
			    	        print QOS qq "/sbin/ip link set imq$oimq up\n";
			    	}
			    }
			    }else				
			    {
                            		print QOS qq "/sbin/tc class add dev imq$imqout parent 100:3 classid 100:$classid htb ";
                            		print QOS qq "rate $path_uploadmin\kbit ceil $path_uploadmax\kbit prio $priority  \# $qosname upload\n";
                            		print QOS qq "/sbin/tc class add dev imq$imqin parent 100:3 classid 100:$classid htb ";
                            		print QOS qq "rate $path_downloadmin\kbit ceil $path_downloadmax\kbit prio $priority \# $qosname download\n\n";
                            		print QOS qq "/sbin/tc qdisc add dev imq$imqin parent 100:$classid handle $classid: sfq perturb 10\n";
                            		print QOS qq "/sbin/tc qdisc add dev imq$imqout parent 100:$classid handle $classid: sfq perturb 10\n";
                            
                            		###################IPv6 Qos - shane 20130426 #########################
                            		if (grep(/:/,$gateway))
                            		{
       			    	                print QOS qq "/sbin/ip link set imq$imqout up\n";
                                		print QOS qq "/sbin/tc filter add dev imq$imqout parent 100: prio $priority protocol ipv6 u32\\\n";     
                                		print QOS qq "\tmatch mark $uploadmark 0xffffffff \\\n";
                               	 		print QOS qq "\tflowid 100:$classid\n";
                                
       			    	                print QOS qq "/sbin/ip link set imq$imqin up\n";
                                		print QOS qq "/sbin/tc filter add dev imq$imqin parent 100: prio $priority protocol ipv6 u32\\\n";
                                		print QOS qq "\tmatch mark $downloadmark 0xffffffff \\\n";
                                		print QOS qq "\tflowid 100:$classid\n\n";
                            		}else
                            		{
       			    	                print QOS qq "/sbin/ip link set imq$imqout up\n";
                                		print QOS qq "/sbin/tc filter add dev imq$imqout parent 100: prio $priority protocol ip u32\\\n";
                                		print QOS qq "\tmatch mark $uploadmark 0xffffffff \\\n";
                                		print QOS qq "\tflowid 100:$classid\n";
                                
                                		#print QOS qq "iptables -t mangle -A POSTROUTING --match mark --mark $uploadmark -m gw --gw $gateway -j CLASSIFY --set-class 100:$classid\n";
                                
       			    	                print QOS qq "/sbin/ip link set imq$imqin up\n";
                                		print QOS qq "/sbin/tc filter add dev imq$imqin parent 100: prio $priority protocol ip u32\\\n";
                                		print QOS qq "\tmatch mark $downloadmark 0xffffffff \\\n";
                                		print QOS qq "\tflowid 100:$classid\n\n";
                            		}
                            		$classid++;
                            	  }
                        }
                    }
                }
                print QOS qq "\#End of fwmark $uploadmark \n\n";
            }
        }
    }
    close(QOS);
    chmod(0777, $qospolicy_script);
    
    my $qosinit = "/usr/local/apache/qbconf/qosinit";
    if ( !open(QOSINIT, ">$qosinit") )
    {
        print "open qosinit fail!!\n";
        return;
    }

    @qosisp = sort { $a <=> $b } @qosisp;

    foreach my $isp ( @qosisp )
    {
        my $ispref = maintainBasic( action=>"GETISPINFO", iid=>$isp );
        my $isptype = $ispref->{isptype};
        my $gateway = $ispref->{gateway};
        my $upload = $ispref->{upload};
        my $download = $ispref->{download};
        my $nic = $ispref->{nic};
        #my ($imqout, $imqin) = getimqnum($isp);
        
        my $imqout = $ispimqout{$isp};
        my $imqin = $ispimqin{$isp};
        
        push(@alldev, 'imq'.$imqin);
        push(@alldev, 'imq'.$imqout);
        $isptype = ( $isptype ne 'tunnel' ) ? ( '1' ) : ( '2' );
        
        my $zone=XMLread($gPATH.'zonecfg.xml');
        my $zonelist=$zone->{dmz};
        my $def = 3;
        my $bridge='0';
        my $brname;
        foreach my $dmz (@$zonelist)
        {
  	    if ($dmz->{mode} ne 'BRIDGE' || $dmz->{interface} ne $nic){next;}
  	    $isptype = '2';
  	    $bridge='1';
  	    $brname=$dmz->{name};
  	    last;
  	}
        print QOSINIT qq "/sbin/tc qdisc del dev imq$imqin root handle 100: htb default $def\n";
        print QOSINIT qq "/sbin/tc qdisc del dev imq$imqout root handle 100: htb default $def\n";
        print QOSINIT qq "/sbin/tc qdisc add dev imq$imqin root handle 100: htb default $def\n";
        print QOSINIT qq "/sbin/tc qdisc add dev imq$imqout root handle 100: htb default $def\n";
        print QOSINIT qq "/sbin/tc class add dev imq$imqout parent 100: classid 100:3 htb rate 10Mbit\n";
        print QOSINIT qq "/sbin/tc class add dev imq$imqin parent 100: classid 100:3 htb rate 10Mbit\n";
        
        #########################Bridge Qos - shane 20130514#########################
        my $brsubnet;
        
	foreach my $key (keys %qossubnet)
	{
	    if ($isp ne $key){next;}
	    $brsubnet = $qossubnet{$key};
	}
	##########################IPv6 Qos - shane 20130426 ##########################
	
        if (grep(/:/,$gateway))
        {
            if ( $isptype eq '2' )
            {
                if ($bridge eq '1')
                {
                    print QOSINIT qq "/sbin/ip6tables -t mangle -A PREROUTING -i $nic -d $brsubnet -j IMQ --todev $imqin\n";
                }else
                {
                    print QOSINIT qq "/sbin/ip6tables -t mangle -A PREROUTING -i $nic -j IMQ --todev $imqin\n";
                }
            }
            else
            {
                ####################
                print QOSINIT qq "/sbin/ip6tables -t mangle -A PREROUTING -m ingw --ispid $isp --isptype $isptype --ispgwip 0 -j IMQ --todev $imqin\n";
            }
            if ($bridge eq '1')
            {
                print QOSINIT qq "/sbin/ip6tables -t mangle -A POSTROUTING -o $brname -s $brsubnet -j IMQ --todev $imqout\n";
            }else
            {
                print QOSINIT qq "/sbin/ip6tables -t mangle -A POSTROUTING -o $nic -m gw --gw $gateway -j IMQ --todev $imqout\n";
            }
        }else
        {
            if ( $isptype eq '2' )
            {
                if ($bridge eq '1')
                {
                    print QOSINIT qq "/sbin/iptables -t mangle -A PREROUTING -i $brname -d $brsubnet -j IMQ --todev $imqin\n";
                }else
                {
                    print QOSINIT qq "/sbin/iptables -t mangle -A PREROUTING -i $nic -j IMQ --todev $imqin\n";
                }
            }
            else
            {
            	#Gary 20130619 Individual
#            	if ($qostype eq 'Individual')
#            	{
#            	    @iplist = get_allocated_ip($item->{source});
#            	    foreach my $ip ( @iplist )
#            	    {
#                        print QOSINIT qq "/sbin/iptables -t mangle -A PREROUTING -s $ip -m ingw --ispid $isp --isptype $isptype --ispgwip 0 -j IMQ --todev $imqin\n";
#            	    }
#            	}
#            	else
#            	{
                print QOSINIT qq "/sbin/iptables -t mangle -A PREROUTING -m ingw --ispid $isp --isptype $isptype --ispgwip 0 -j IMQ --todev $imqin\n";
#                }
            }
            if ($bridge eq '1')
            {
                print QOSINIT qq "/sbin/iptables -t mangle -A POSTROUTING -o $brname -s $brsubnet -j IMQ --todev $imqout\n";
            }
            else
            {
#            	if ($qostype eq 'Individual')
#            	{
#            	    foreach my $ip ( @iplist )
#            	    {
# 	                print QOSINIT qq "/sbin/iptables -t mangle -A POSTROUTING -s $ip -o $nic -m gw --gw $gateway -j IMQ --todev $imqout\n";
#            	    }
#            	}
#            	else
#            	{
                print QOSINIT qq "/sbin/iptables -t mangle -A POSTROUTING -o $nic -m gw --gw $gateway -j IMQ --todev $imqout\n";
#                }
            }
        }
    }
    close(QOSINIT);
    chmod(0777, $qosinit);
    #======================================================
    # QoS of ISP
    #======================================================
    my $qosisp = "/usr/local/apache/qbconf/qosisp.sh";
    if ( !open(QOSISP, ">$qosisp") )
    {
        print "open qosisp fail!!\n";
        return;
    }
    foreach my $isp ( @$isplist )
    {
        if ( $isp->{isptype} ne 'tunnel' ) { next; }
        if ( $isp->{qos} ne '' && $isp->{qos} ne '0' ) 
        {
            print QOSISP qq "/sbin/tc qdisc del dev $isp->{nic} root handle 100: htb default 3\n";
            print QOSISP qq "/sbin/tc qdisc add dev $isp->{nic} root handle 100: htb default 3\n";
            print QOSISP qq "/sbin/tc class add dev $isp->{nic} parent 100: classid 100:3 htb rate $isp->{qos}kbit\n";
            push(@alldev, $isp->{nic});
        }
    }
    close(QOSISP);
    chmod(0777, $qosisp);
     
    
    #======================================================
    # del qdisc 
    #======================================================
    my $delall = "/usr/local/apache/qbconf/delall";
    if ( !open(QOSDEL, ">$delall") )
    {
        print "open qosdel fail!!\n";
        return;
    }
    
    foreach my $dev ( @alldev )
    {
        print QOSDEL qq "/sbin/tc qdisc del dev $dev root handle 100: htb default 3\n";
    }
    close(QOSDEL);
    chmod(0777, $delall);
    
}
 
sub getimqnum
{
    my $isp = shift;
    my $imqout = $isp * 2 - 2;
    my $imqin = $isp * 2 - 1;

    return ($imqout, $imqin);
}

=cut
sub getimqnum
{
    my $natref=XMLread($gPATH.'zonecfg.xml');
    my $natarray=$natref->{nat};
    my $src = shift;
    my $imqin;
    my $imqout;
    
    foreach my $nat ( @$natarray )
    {
        if ( subnet_belong_check($src, $nat->{network}) )
        {
            #return ( $nat->{nic});
            $imqin = $nat->{nic};
            my $num = $imqin; 
            $num =~ s/eth//;
            $imqout = 'imq'.$num;
        }
    }
    
    return ($imqout, $imqin);
}
=cut

#==================================================================================================
# timeminsegs2hrminsegs( reference to the array of minutes-formed time segments ( from XML ) )
sub timeminsegs2hrminsegs()
{
    my $minsegs=shift;
    my %hrminseqhash;

    foreach my $seg ( @$minsegs )
    {
        my ( $start, $end )=split(/:/,$seg);
        
        my $starthour=floor($start/60); 
        $starthour='0'.$starthour if ( $starthour <=9 );
        
        my $startmin=$start%60; 
        $startmin='0'.$startmin if ( $startmin <=9 );
        
        my $endhour=floor($end/60); 
        $endhour='0'.$endhour if ( $endhour <=9 );
        
        my $endmin=$end%60; 
        $endmin='0'.$endmin if ( $endmin <=9 );
        
        my $segitem=$starthour.':'.$startmin.'-'.$endhour.':'.$endmin;

        $hrminseqhash{$segitem}=1;
    }

    return sort keys ( %hrminseqhash );
}
#timeminsegs2hrminsegs


#==================================================================================================
# timesegarray2seqarray(reference to an array of segments )
sub timesegarray2seqarray() 
{
    my $segments=shift;
    my %seqhash;

    foreach my $seg ( @$segments ) 
    {
        my ( $start, $end )=split(/:/,$seg);
        $start=($start/10)+1;
        $end=($end+1)/10;
        for ( my $segitem=$start; $segitem<=$end; $segitem++ )
        {
            $seqhash{$segitem}=1;
        }               
    }
    return sort keys ( %seqhash );
}
#timesegarray2seqarray


#==================================================================================================
# timeseqarray2segarray( reference to an array of sequences )
sub timeseqarray2segarray() 
{
    my $sequences=shift;
    my %seghash;
    my $segment;

    foreach my $seq ( @$sequences ) { $seqhash{$seq}=1; }
    for ( my $i=0,$j=1; $j<=145; $i++, $j++)
    {
        if ( !$seqhash{$i} && $seqhash{$j} )
        {    
            $segment.=($i*10).':';
        }
        elsif ( $seqhash{$i} && !$seqhash{$j} )
        {
            $segment.=$i*10-1;
            $seghash{$segment}=1;
            $segment='';
        }
    }
    
    return sort keys( %seghash );
}
#timeseqarray2seqarray


#==================================================================================================
sub timeseq2section() 
{
    my $seq=shift;
    my ( $minutes, $hours, $start, $end );
    if ( $seq!~m/\d{1,2}/ ) { return; }
    
    my $minutes=($seq-1)*10;
    $hours=floor($minutes/60); $hours='0'.$hours if ( $hours <= 9 );
    $minutes%=60; $minutes='0'.$minutes if ( $minutes <=9 );
    $start=$hours.':'.$minutes;
    $end=$hours.':'.($minutes+9);
    $end=$hours.':0'.($minutes+9) if ( $minutes == 0 );
    return $start.'-'.$end;
}
#timeseq2section


#================================================================================================
sub ini_class_sort_by_source 
{
    my @afields=split(/\.|\//,$a->{source});
    my @bfields=split(/\.|\//,$b->{source});
    foreach my $index ( 0..4 )
    {
         $avalue=int($afields[$index]); 
         $bvalue=int($bfields[$index]);
         if ( $avalue != $bvalue ) { last; }
    }

    if ( $avalue == $bvalue )
    {
        return $a->{service} cmp $b->{service}; 
    }
    else
    {
        $avalue <=> $bvalue;
    }
}
#ini_class_sort_by_source

sub ini_class_sort_by_hostobj
{
    if ( $a->{source} eq $b->{source} )
    {
        return $a->{service} cmp $b->{service};
    }
    return $a->{source} cmp $b->{source};
}
#ini_class_sort_by_hostobj


#================================================================================================
sub ini_class_sort_by_service 
{

    if ( $a->{service} ne $b->{service} )
    {
        return $a->{service} cmp $b->{service};
    }

    my ( $avalue, $bvalue );
    
    my @afields=split(/\.|\//,$a->{source});
    my @bfields=split(/\.|\//,$b->{source});
    foreach my $index ( 0..4 )
    {
        $avalue=int($afields[$index]); 
        $bvalue=int($bfields[$index]);
        if ( $avalue != $bvalue ) { last; }
    }

    return $avalue <=> $bvalue;
}
#ini_class_sort_by_service


#================================================================================================
sub proute_class_sort_by_source 
{
    my @afields=split(/\.|\//,$a->{source});
    my @bfields=split(/\.|\//,$b->{source});
    foreach my $index ( 0..4 )
    {
         $avalue=int($afields[$index]); 
         $bvalue=int($bfields[$index]);
         if ( $avalue != $bvalue ) { last; }
    }

    if ( $avalue == $bvalue )
    {
        return $a->{service} cmp $b->{service};
    }
    else
    {
        $avalue <=> $bvalue;
    }
}
#proute_class_sort_by_source 
#####################################################################
#####################################################################
#
# 2014-0211 prepros to check proute.xml -> <qb>  correct or not.   by Gary
#
#####################################################################
sub check_proute_qb
{
    my $prouteref=XMLin('/usr/local/apache/qbconf/proute.xml',forcearray=>1);
    my $proutelist=$prouteref->{qb}->[0]->{class};
    my $ispref=XMLin('/usr/local/apache/qbconf/basic.xml',forcearray=>1);
    my $isplist=$ispref->{isp};
    my @tmparray;
    my @priority4500iid; 
    my @priority5000iid; 
    
    foreach my $proute ( @$proutelist )
    {
	if ( $proute->{priority} eq '4500' )
    	{
		my $iid=$proute->{service};
		$iid=~s/ISP//g;
		push ( @priority4500iid , $iid );
    	}
    	if ( $proute->{priority} eq '5000' )
    	{
		my $iid=$proute->{route_table};
		$iid=$iid-100;
		push ( @priority5000iid , $iid );
    	}
        push(@tmparray, $proute);
    }
    foreach my $isp ( @$isplist )
    {
    	if ( $isp->{iid} eq 'system' ) {next;}
    	if ( !grep(/^$isp->{iid}$/,@priority4500iid) )
    	{
            my $serviceName='ISP'.$isp->{iid};
            my $fwmarkValue='0x'.dec2hex(1000+$isp->{iid});
            my $ispTable=100+$isp->{iid};
            my %newClass=(fwmark=>$fwmarkValue, service=>$serviceName, route_table=>$ispTable, time=>['0:1439'], natmethod=>'ls', priority=>"4500");
            push( @tmparray, \%newClass);
    	}
    	if ( !grep(/^$isp->{iid}$/,@priority5000iid) )
    	{
            my $ispTable=100+$isp->{iid};
            my %newClass=( source=>$isp->{systemip}.'/32', route_table=>$ispTable, time=>['0:1439'], priority=>"5000");
            push( @tmparray, \%newClass);
    	}
    }
    $prouteref->{qb}->[0]->{class} = \@tmparray;
    XMLwrite($prouteref, $gPATH."proute.xml");
}
############################################################################
#
#  Run iptables for layer7
#
############################################################################

sub edit_layer7_rules
{
    `/usr/local/apache/qb/setuid/run rm -rf /usr/local/apache/qbconf/iptables_layer7`;
    
    my $INIROUTEXML = XMLin('/usr/local/apache/qbconf/iniroute.xml',forcearray=>1);
    my $HOSTXML	    = XMLin('/usr/local/apache/qbconf/host.xml',forcearray=>1);
    my $SHEDULEXML  = XMLin('/usr/local/apache/qbconf/schedule.xml',forcearray=>1);
    
    my $overview=XMLread($gPATH.'overview.xml');
    $overview->{resolve}="8.8.8.8";
    XMLwrite($overview, $gPATH."overview.xml");
    
    my $app_class   = $INIROUTEXML->{app}->[0]->{class};
    my $hostlist    = $HOSTXML->{host};
    my $schedulelist  = $SHEDULEXML->{schedule};
    
    my @all_layer7=("GoogleBooks","GoogleAnalytics","GoogleCalendar","GoogleChrome","GooglePicasa","GooglePLAY","RSS","Evernote","Niconico","NextTV","Youtube","HiChannel","JustinTV","PPStream","Qvod","BaiduVideo","TeamViewer","GoToMeeting");
    
    foreach my $classes ( @$app_class )
    {
    	if ( $classes->{service} eq "system" ) { next; }
    	my $layer7_flag=0;
    	foreach my $target_layer7 ( @all_layer7 )
    	{
    	    if ( $classes->{service} eq $target_layer7 ) { $layer7_flag=1;}
    	}
    	if ( $layer7_flag eq "0" ) { next;}
    	
    	
    	my $Array_Reused;
    	my @Reused;
    	if ( -e "/usr/local/apache/qbconf/iptables_layer7" )
    	{
    	    #`/usr/local/apache/qb/setuid/run rm -rf /tmp/garytest`;
    	    $Array_Reused=`/usr/local/apache/qb/setuid/run grep -c $classes->{service} /usr/local/apache/qbconf/iptables_layer7`;
    	    @Reused=split(/\n/, $Array_Reused);
   	    #`/usr/local/apache/qb/setuid/run echo "GaryTest".$Reused[0] >> /tmp/garytest`;
    	}
   	
   	if ( $Reused[0] eq '0' | !$Reused[0] )
   	{
    	`echo "/sbin/iptables -N $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
    	`echo "/sbin/iptables -A $classes->{service} -j LOG --log-prefix \\"LAYER7_$classes->{service} : \\" --log-level 7" >> /usr/local/apache/qbconf/iptables_layer7`;
    	`echo "/sbin/iptables -A $classes->{service} -j DROP" >> /usr/local/apache/qbconf/iptables_layer7`;
    	}
    	
    	my @srcobj;
    	my @destobj;
    	my @scheduleobj;
    	
    	####################################################
    	# process source
    	####################################################
	if( grep(/^host-/, $classes->{source}) )
	{
	    foreach my $hostobj ( @$hostlist )
	    {
	    	if ( $classes->{source} eq $hostobj->{hostname} )
	    	{
	    	    my @tmparray=split ( /,/ , $hostobj->{hostaddress} );
	    	    foreach my $tmp ( @tmparray )
	    	    {
	    	    	push ( @srcobj , $tmp );
	    	    }
	    	}
	    }
	}
	else
	{
	    push ( @srcobj, $classes->{source} );
	}
	
=cut
    	####################################################
    	# process destination
    	####################################################
	if( grep(/^host-/, $classes->{destination}) )
	{
	    foreach my $hostobj ( @$hostlist )
	    {
	    	if ( $classes->{destination} eq $hostobj->{hostname} )
	    	{
	    	    my @tmparray=split ( /,/ , $hostobj->{hostaddress} );
	    	    foreach my $tmp ( @tmparray )
	    	    {
	    	    	push ( @destobj , $tmp );
	    	    }
	    	}
	    }
	}
	else
	{
	    push ( @destobj, $classes->{destination} );
	}
    	
=cut
    	
    	if ( $classes->{schedule} eq "All Week" )
    	{
    	    foreach my $srcIP ( @srcobj )
    	    {
    	    	my $iptables_src;    
    	    	if ( $srcIP eq "0.0.0.0/0" ) { $iptables_src=''; }
    	    	else { $iptables_src="-s ".$srcIP; }
    	        foreach my $Target_Chain ( "FORWARD", "INPUT" )
    	        {
    	    	    foreach my $httpsport ( 80,443 )
    	    	    {
    	    	        my $port_rule="-m tcp -p tcp --dport ".$httpsport;
    	    	        ## TODO doesn't had schedule time
    	    	        if ( $classes->{service} eq "GoogleBooks" )
    	    	        {
	    	            `echo "/sbin/iptables -I $Target_Chain $iptables_src -d books.google.com.tw $port_rule -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        }
    	    	        elsif ( $classes->{service} eq "GooglePicasa" )
    	    	        {
	    	            `echo "/sbin/iptables -I $Target_Chain $iptables_src -d picasa.google.com $port_rule -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        }
    	    	        elsif ( $classes->{service} eq "GoogleAnalytics" )
    	    	        {
	    	            `echo "/sbin/iptables -I $Target_Chain $iptables_src -d analytics.google.com.tw $port_rule -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        }
    	    	        elsif ( $classes->{service} eq "GoogleCalendar" )
    	    	        {
	    	            `echo "/sbin/iptables -I $Target_Chain $iptables_src -d calendar.google.com.tw $port_rule -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        }
    	    	        elsif ( $classes->{service} eq "GooglePLAY" )
    	    	        {
	    	            `echo "/sbin/iptables -I $Target_Chain $iptables_src -d play.google.com $port_rule -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        }
    	    	        elsif ( $classes->{service} eq "Evernote" )
    	    	        {
	    	            `echo "/sbin/iptables -I $Target_Chain $iptables_src -d evernote.com $port_rule -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        }
    	    	        elsif ( $classes->{service} eq "Youtube" )
    	    	        {
	    	            `echo "/sbin/iptables -I $Target_Chain $iptables_src -d www.youtube.com $port_rule -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        }
    	    	        elsif ( $classes->{service} eq "NextTV" )
    	    	        {
	    	            `echo "/sbin/iptables -I $Target_Chain $iptables_src -d www.nexttv.com.tw $port_rule -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        }
    	    	        elsif ( $classes->{service} eq "HiChannel" )
    	    	        {
	    	             `echo "/sbin/iptables -I $Target_Chain $iptables_src -d hichannel.hinet.net $port_rule -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        }
    	    	        elsif ( $classes->{service} eq "Niconico" )
    	    	        {
	    	            `echo "/sbin/iptables -I $Target_Chain $iptables_src -d www.nicovideo.jp $port_rule -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        }
	    	        elsif ( $classes->{service} eq "JustinTV" )
	    	        {
	    	            `echo "/sbin/iptables -I $Target_Chain $iptables_src -d zn-tw.justintv.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	            `echo "/sbin/iptables -I $Target_Chain $iptables_src -d www.justintv.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        }
	            }
    	    	    if ( $classes->{service} eq "TeamViewer" )
    	    	    {
	    	        `echo "/sbin/iptables -I $Target_Chain $iptables_src -d  master.teamviewer.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        `echo "/sbin/iptables -I $Target_Chain $iptables_src -d master1.teamviewer.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        `echo "/sbin/iptables -I $Target_Chain $iptables_src -d master2.teamviewer.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        `echo "/sbin/iptables -I $Target_Chain $iptables_src -d master3.teamviewer.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        `echo "/sbin/iptables -I $Target_Chain $iptables_src -d master4.teamviewer.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        `echo "/sbin/iptables -I $Target_Chain $iptables_src -d master5.teamviewer.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	        `echo "/sbin/iptables -I $Target_Chain $iptables_src -d master6.teamviewer.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    }
	    	    elsif ( $classes->{service} eq "PPStream" )
	    	    {
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d update.ppstream.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d stat.ppstream.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d static.dns.iqiyi.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d image1.webscache.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d msg.video.dns.iqiyi.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    }
	    	    elsif ( $classes->{service} eq "BaiduVideo" )
	    	    {
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d php.player.baidu.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d baoku.baidu.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d img04.taobaocdn.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    }
	    	    elsif ( $classes->{service} eq "Qvod" )
	    	    {
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d kuaibo.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d static.kuaibo.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d barr.kuaibo.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d prom.qbho.kuaibo.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d www.yunfan.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d w.cnzz.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -d is.img.yunfan.com -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    }
	    	    elsif ( $classes->{service} eq "RSS" )
	    	    {
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -m weburl --contains "$classes->{service}" -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    }
	    	    elsif ( $classes->{service} eq "GoogleChrome" )
	    	    {
	    	    `echo "/sbin/iptables -I $Target_Chain $iptables_src -m layer7 --l7proto "$classes->{service}" -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    }
	        }
    	    }
    	}
    	else
    	{
	    foreach my $schedule_list ( @$schedulelist )
	    {
	        if ( $classes->{schedule} eq $schedule_list->{schname} )
	        {
		    my $scheduledays=$schedule_list->{subsch};
		    foreach my $scheduleday ( @$scheduledays )
		    {
			$scheduletime='-m time --timestart '.$scheduleday->{timestart}.' --timestop '.$scheduleday->{timestop}.' --weekdays '.$scheduleday->{days};
    	    		foreach my $srcIP ( @srcobj )
    	    		{
    	    		    my $iptables_src;    
    	    		    if ( $srcIP eq "0.0.0.0/0" ) { $iptables_src=''; }
    	    		    else { $iptables_src="-s ".$srcIP; }
    	      		    foreach my $Target_Chain ( "FORWARD", "INPUT" )
    	      		    {
    	    			foreach my $httpsport ( 80,443 )
    	    			{
    	    	     		    my $port_rule="-m tcp -p tcp --dport ".$httpsport;
    	    	     		    ## TODO doesn't had schedule time
    	    	     		    if ( $classes->{service} eq "GoogleBooks" )
    	    	     		    {
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d books.google.com.tw $port_rule $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	     		    }
    	    	     		    elsif ( $classes->{service} eq "GooglePicasa" )
    	    	     		    {
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d picasa.google.com $port_rule $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	     		    }
    	    	     		    elsif ( $classes->{service} eq "GoogleAnalytics" )
    	    	     		    {
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d analytics.google.com.tw $port_rule $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	     		    }
    	    	     		    elsif ( $classes->{service} eq "GoogleCalendar" )
    	    	     		    {
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d calendar.google.com.tw $port_rule $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	     		    }
    	    	     		    elsif ( $classes->{service} eq "GooglePLAY" )
    	    	     		    {
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d play.google.com $port_rule $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	     		    }
    	    	     		    elsif ( $classes->{service} eq "Evernote" )
    	    	     		    {
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d evernote.com $port_rule $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	     		    }
    	    	     		    elsif ( $classes->{service} eq "Youtube" )
    	    	     		    {
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d www.youtube.com $port_rule $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	     		    }
    	    	     		    elsif ( $classes->{service} eq "NextTV" )
    	    	     		    {
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d www.nexttv.com.tw $port_rule $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	     		    }
    	    	    	 	    elsif ( $classes->{service} eq "HiChannel" )
    	    	     		    {
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d hichannel.hinet.net $port_rule $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	     		    }
    	    	     		    elsif ( $classes->{service} eq "Niconico" )
    	    	     		    {
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d www.nicovideo.jp $port_rule $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	     		    }
	    	     		    elsif ( $classes->{service} eq "JustinTV" )
	    	     		    {
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d zn-tw.justintv.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	         		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d www.justintv.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	     		    }
	        		}
    	    			if ( $classes->{service} eq "TeamViewer" )
    	    			{
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d  master.teamviewer.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d master1.teamviewer.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
			    	`echo "/sbin/iptables -I $Target_Chain $iptables_src -d master2.teamviewer.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    			`echo "/sbin/iptables -I $Target_Chain $iptables_src -d master3.teamviewer.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d master4.teamviewer.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d master5.teamviewer.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d master6.teamviewer.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    			}
	    			elsif ( $classes->{service} eq "PPStream" )
	    			{
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d update.ppstream.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d stat.ppstream.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d static.dns.iqiyi.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d image1.webscache.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d msg.video.dns.iqiyi.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    			}
	    			elsif ( $classes->{service} eq "BaiduVideo" )
	    			{
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d php.player.baidu.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d baoku.baidu.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d img04.taobaocdn.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    			}
	    			elsif ( $classes->{service} eq "Qvod" )
	    			{
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d kuaibo.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d static.kuaibo.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d barr.kuaibo.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d prom.qbho.kuaibo.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d www.yunfan.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d w.cnzz.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -d is.img.yunfan.com $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    			}
	    			elsif ( $classes->{service} eq "RSS" )
	    			{
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -m weburl --contains "$classes->{service}" $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    			}
	    			elsif ( $classes->{service} eq "Chrome" )
	    			{
	    	    		`echo "/sbin/iptables -I $Target_Chain $iptables_src -m layer7 --l7proto "$classes->{service}" $scheduletime -j $classes->{service}" >> /usr/local/apache/qbconf/iptables_layer7`;
	    			}
	      		    }
    	    		}
	      	    }
	    	}
	    }
    	}
    }
    
    `/usr/local/apache/qb/setuid/run touch /usr/local/apache/qbconf/iptables_layer7`;
    `/usr/local/apache/qb/setuid/run chmod 777 /usr/local/apache/qbconf/iptables_layer7`;
    `/usr/local/apache/qb/setuid/run chown root:root /usr/local/apache/qbconf/iptables_layer7`;
} 
#edit_layer7_rules

#
1
