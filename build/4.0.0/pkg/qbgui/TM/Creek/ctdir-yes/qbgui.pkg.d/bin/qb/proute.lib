############################################################################################################
#                    Policy Routing and Policy-based Filter for QoS Config
############################################################################################################

#########################   About  Policy Routing   ###################################
sub showPolicyTitle
{
    my (%action)=@_;
    my $viewpoint=$action{viewpoint};
    #my %titleWidth=(Source=>'135', Service=>'110', Destination=>'135', 'NAT Status'=>'80', Pool=>'120', Schedule=>'100', Status=>'50', Edit=>'40');
    #my @titleList=('Schedule', 'Pool', 'NAT Status', 'Status', 'Edit');
    my %titleWidth=(Source=>'150', Service=>'120', Destination=>'150', 'NAT Status'=>'90', Pool=>'100', Schedule=>'120', Status=>'50', QoS=>'80', Edit=>'30');
    #my %titleWidth=(Source=>'18%', Service=>'11%', Destination=>'13%', 'NAT Status'=>'10%', Pool=>'22%', Schedule=>'8%', Status=>'3%', QoS=>'5%', Edit=>'2%');
    my @titleList=('Schedule', 'Pool', 'NAT Status', 'Status', 'QoS', 'Edit');
    
    print qq (<div class="divframe">);
    print qq (<table width="100%" bgcolor="#332211" border="0" align="center"> );
    print qq (<tr>);
    print qq (<td align="center" width="$titleWidth{'Source'}" ><a href="javascript:sortPolicy('BYSOURCE')" title="Sort by Source" border="0">Source</a></td>);
    print qq (<td align="center" width="$titleWidth{'Destination'}" >Destination</td>);
    my $title = ( $action{viewpoint} eq 'app' ) ? ( 'Application' ) : ( 'Service' );
    print qq (<td align="center" width="$titleWidth{'Service'}" ><a href="javascript:sortPolicy('BYSERVICE')" title="Sort by Service" border="0">$title</a></td>);
    foreach my $title ( @titleList ) { print qq (<td  align="center" width="$titleWidth{$title}"><font color="#ffffff">$title</font></td>); }
    print qq (<td align="center" width="50" ><a href="javascript:delPolicy()"><image src="image/del.gif" title="Delete checked policies" border="0"></a>);
    print qq (<input type="checkbox" title="select or deselect all items" onClick="setAllCheckBoxValue('rule', this.checked)">);
    print qq (</td>);
    print qq (</tr>);
    print qq (</table>);
    print qq (</div>);
}
#showPolicyTitle


#===========================================================================================
sub list_ini_rule 
{
    my (%action)=@_;
    my $viewpoint=$action{viewpoint};
    my $iniroute=XMLread($gPATH."iniroute.xml");
    my $classes=$iniroute->{$viewpoint}->[0]->{class};
    my @sortedClasses;
    my %priority=(1=>'High', 3=>'Medium', 5=>'Low');
    my $sortingKEY=$action{sortingkey};
    #add qos
    #my %titleWidth;
    #my %titleWidth=(Source=>'130', Service=>'100', Destination=>'130', 'NAT Status'=>'80', Pool=>'100', Schedule=>'90', Qos=>'60', Status=>'50', Edit=>'40');
    #my %titleWidth=(Source=>'26%', Service=>'10%', Destination=>'15%', 'NAT Status'=>'10%', Pool=>'10%', Schedule=>'10%', Status=>'10%', QoS=>'10%', Edit=>'10%');
    my %titleWidth=(Source=>'150', Service=>'120', Destination=>'150', 'NAT Status'=>'90', Pool=>'100', Schedule=>'120', Status=>'50', QoS=>'80', Edit=>'30');
    #my %titleWidth=(Source=>'18%', Service=>'11%', Destination=>'13%', 'NAT Status'=>'10%', Pool=>'22%', Schedule=>'8%', Status=>'3%', QoS=>'5%', Edit=>'2%');
    
	my @titleList=('Schedule', 'Pool', 'NAT Status', 'Status', 'QoS', 'Edit');
    #host obj to sort
    my @hostobj;
    my @srcobj;
    foreach my $item ( @$classes )
    {
        if( grep(/^host-/, $item->{source}) )
        {
            push(@hostobj, $item);
        }
        else
        {
            push(@srcobj, $item); 
        }
    }
    @hostobj=sort ini_class_sort_by_hostobj @hostobj;
    
    if ( !$sortingKEY )                     { $sortingKEY='BYSOURCE';}
    #if ( $sortingKEY eq 'BYSOURCE' )        { @sortedClasses=sort ini_class_sort_by_source @$classes; }
    #elsif ( $sortingKEY eq 'BYSERVICE' )    { @sortedClasses=sort ini_class_sort_by_service @$classes;}
    if ( $sortingKEY eq 'BYSOURCE' )        { @sortedClasses=sort ini_class_sort_by_source @srcobj; }
    elsif ( $sortingKEY eq 'BYSERVICE' )    { @sortedClasses=sort ini_class_sort_by_service @srcobj;}
    
    push(@sortedClasses, @hostobj);
    
    #================================================================================================
    # we get all necessary info. here to avoid unacceptable loop-count times access to all this info.
    # data structure all the policy check will use
    
    #======================================================================================================
    # phase 1. prepare some necessary data structure before looping to use for speeding up valid checking ...
    
    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # prepare step 1. get isp id list
    my @ispidlist;
    @ispidlist=maintainBasic( action=>'GETIIDLIST' ); 
    
    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # prepare step 2.  
    # %isppubip is a data structure designed to be loaded on demand
    my %isppubip;
    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # prepare step 3.
    my @sourcelist;
    my %source2isp;
    if ( $viewpoint=~m/dmz|nat/ ) 
    { 
        foreach my $class ( @sortedClasses ) { if ($class->{source} ne 'system') { push(@sourcelist, $class->{source});}}    
    }
    %source2isp=batchFindMyISP( @sourcelist );
    
    #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    # prepare step 4.
    my %POLICY_USABLE_TABLES;
    if ( $viewpoint=~m/nat/ )
    {
        %POLICY_USABLE_TABLES=maintainRtable( action=>"GETPOLICYUSABLETABLEIDS", viewpoint=>"$viewpoint", source2isp=>\%source2isp );
    }
    else
    {
        %POLICY_USABLE_TABLES=maintainRtable( action=>"GETPOLICYUSABLETABLEIDS", viewpoint=>"$viewpoint" );
    }

    print qq (<div class="divframe" style="height:270">);
    print qq (<table class="body" id="ruleList" width="100%" border="0">);
    #print qq (<table id="ruleList" width="1000" class="body" border="0" align="center" >);
    
    my $lineCount=0;
    #my @tablelist;
    foreach my $class ( @sortedClasses ) { if ( $class->{table} eq 'system' ) {  next; } push(@tablelist, $class->{table});}
    my @showtable = presentTables(@tablelist);
    foreach my $class ( @sortedClasses ) 
    {
        #碰到系統保留的那一筆就免了
        if ( $class->{service} eq 'system' ) { next; }
        if ( $class->{enables} eq '1' ) {$lineCount++; next; }
        #Policy of Real Service remove Q-Balancer
        #if ( $class->{source} eq 'localhost') { next; }
        
        #===================================================================      
        # prepare key of Policy
        #my $rulekey=$class->{source}.$class->{service}.':'.$class->{direction}.$class->{destination}.':'.$class->{table};
        #luke 1008
        #20101224 add schedule
        #my $rulekey=$class->{source}.$class->{service}.':'.$class->{direction}.$class->{destination};
        my $rulekey=$class->{source}.$class->{service}.':'.$class->{direction}.$class->{destination}.$class->{schedule};
        my $checkrulekey=$class->{source}.':'.$class->{service}.':'.$class->{direction}.':'.$class->{destination}.':'.$class->{method}.':'.$class->{table};
        
        #===================================================================      
        # prepare display color
        my ( $originalColor, $bgcolor ); $originalColor=$bgcolor=($lineCount%2) ? ( '#556677' ) : ( '#334455' );
        if ( $class->{dirty} ) { $originalColor=$bgcolor='#bb6600' }; 

        print qq (<tr bgcolor="$bgcolor" originalColor="$originalColor" onmouseover="focusedColor(this)" onmouseout="blurColor(this)">);
        
        #===================================================================      
        if ( $viewpoint eq 'dmz' &&  $class->{source} ne 'system' && !exists($source2isp{$class->{source}}) ) 
        {
            print qq (<td align="center" bgcolor="#aa3311" style="width:$titleWidth{Source} !important">$class->{source} [OBS]</td>);
        }
        else
        {
            my $display=( $class->{source} eq 'system' ) ? ('*') : ( $class->{source} );
            $display=~s/localhost/Q-Balancer/g;
            $display=~s/host-//g;
            my $addresslist=maintainHost( action=>'GETADDRESSLIST', hostname=>$display);
            print qq (<td align="center" style="width:$titleWidth{Source} !important" onmousedown="showHostInfo('$display','$addresslist')" onmouseout="hideHostInfo()">$display</td>);
        }

        #===================================================================      
        my $display=( $class->{destination} eq 'system' ) ? ('Anywhere') : ( $class->{destination} );
        #20101228
        $display =~ s/host-//g;
        my $addresslist=maintainHost( action=>'GETADDRESSLIST', hostname=>$display);
        #print qq (<td class="body"  align="center" width="$titleWidth{Destination}">$display</td>);
        print qq (<td align="center" style="width:$titleWidth{Destination} !important" onmousedown="showHostInfo('$display','$addresslist')" onmouseout="hideHostInfo()">$display</td>);

        my $service=$class->{service};
        #$service=~s/sergobj-//g;
        #===================================================================      
        my $display=$class->{service};
        if ( $viewpoint eq 'nat' || $viewpoint eq 'lvs' )
        {
            #my $display=( $class->{service} eq 'system' ) ? ('*') : ( $class->{service} );
            $display=( $display eq 'others' ) ? ( 'ANY' ) : ( $display );
            $display.=':'.$class->{direction};
            $display=~s/:s$/(RPLY)/g; $display=~s/:d$/(RQST)/g;
        }
        print qq (<td align="center" style="width:$titleWidth{Service} !important" onmousedown="showServiceInfo('$service')" onmouseout="hideServiceInfo()">$display</td>);
     
        print qq (<td style="width:$titleWidth{Schedule} !important" align="center">);
        my $showschedule=( $class->{schedule} eq '' ) ? ( 'All Week' ) : $class->{schedule};
        #print qq (<span title="" style="width:$titleWidth{Schedule}">$showschedule</span>);
        print qq ($showschedule);
        print qq (</td>);

        #===================================================================
        #檢查原本走的 Routing Table 是否不能再走了
        my $usable_table_list=$POLICY_USABLE_TABLES{$checkrulekey};
        my $table_obs=1;

        $table_obs=!grep(/^$class->{table}$/, @$usable_table_list );
        
        #my  $showtable=presentTable($class->{table});
        
	#viewpoint app  
        if ( $table_obs && $action{viewpoint} eq 'nat' ) { $showtable.='[OBS]'};
        my $fontColor=( $table_obs && $action{viewpoint} eq 'nat' ) ? ( "#aaffff") : ( "#ffffff" ); 
        my $errColor=( $table_obs && $action{viewpoint} eq 'nat' ) ? ('#aa3311') : ('');
        print qq (<td align="center" bgcolor="$errColor" style="width:$titleWidth{Pool} !important" onmousedown="showTableInfo('$class->{table}')" onmouseout="hideTableInfo()">);
        #print qq (<font color="$fontColor">$showtable</font>);
        print qq (<font color="$fontColor">$showtable[$lineCount]</font>);
        print qq (</td>);
        
        #===================================================================
        my $siplist=$class->{sip};
        my $natinfo='';

        print qq (<td align="center" style="width:$titleWidth{'NAT Status'} !important">);
        
        if ( $action{viewpoint} eq 'lvs' )                  { print "No NAT"; }
        elsif( $class->{method} eq 'none' )                 { print "No NAT"; }
        elsif( $class->{method} eq 'ls' && @$siplist==0 )   { print "Smart NAT";  }
        else    
        {
            if      ( $class->{method} eq 'ss' )     { $natinfo.="--- Single Source ---"."\n";   }
            elsif   ( $class->{method} eq 'ms' )     { $natinfo.="--- Multi-Source ---"."\n";    }
            elsif   ( $class->{method} eq 'ls' )     { $natinfo.="--- Manual NAT ---"."\n";         }

            foreach my $sip ( @$siplist ) 
            { 
                my $ispexist=(grep(/^$sip->{isp}$/, @ispidlist )) ? 1:0;
                my @natip=split(/,/, $sip->{ip}); 
                foreach my $ip ( @natip )
                {
                    my $message='ISP'.$sip->{isp}."[ $ip ]";
                    if ( !$ispexist ) { $message.="OBS"; }
                    else
                    {
                        # %isppubip is a data structure designed to be loaded on demand
                        my $nownatips;
                        if ( !exists($isppubip{$sip->{isp}}) )
                        {
                            my @pubips=maintainIPBank(action=>'READPUBLICIP', isp=>$sip->{isp});
                            $isppubip{$sip->{isp}}=\@pubips;
                        }
                        
                        my $nownatips=$isppubip{$sip->{isp}};
                        my $ipobs=(!grep(/^$ip$/, @$nownatips))? 1:0;
                        $message.=($ipobs) ? ("OBS") : ('');
                    }
                    
                    $natinfo.=$message."\n";          
                }
            }
            
            if ( $class->{method} eq 'ss' )     { print qq (<span title="$natinfo">- Single Source -</span>);   }
            elsif ( $class->{method} eq 'ms' )  { print qq (<span title="$natinfo">- Multi-Source -</span>);    }
            elsif ( $class->{method} eq 'ls' )  { print qq (<span title="$natinfo">- Manual NAT -</span>);         }
        }
        print qq (</td>);


        #===================================================================      
        my $imgSrc=( $class->{dirty} ) ? ( '/image/alert.gif' ) : ( '/image/ok.gif' );
        print qq (<td align="center" style="width:$titleWidth{Status} !important"><image src="$imgSrc" border="0"></td>);
        
        my $showqos=($class->{qos} eq '') ? ( 'None' ) : ( $class->{qos} );
        print qq (<td align="center" bgcolor="$errColor" style="width:$titleWidth{QoS} !important" onmousedown="" onmouseout="">);
        print qq (<font color="$fontColor">$showqos</font>);
        print qq (</td>);
        
        #===================================================================      
        #my $key_for_shortcut=$viewpoint.'&'.$class->{isp}.'&'.$class->{source}.'&'. $class->{service}.':'.$class->{direction}.'&'.$class->{advance}.'&'.$class->{destination}.'&'.$class->{table};
        my $key_for_shortcut=$viewpoint.'&'.$class->{isp}.'&'.$class->{source}.'&'. $class->{service}.':'.$class->{direction}.'&'.$class->{advance}.'&'.$class->{destination}.'&'.$class->{table}.'&'.$class->{schedule};
        print qq (<td align="center" style="width:$titleWidth{Edit} !important">);
        #print qq (<a href="javascript:edit_this_rule('$key_for_shortcut','$rulekey');selectedColor(ruleList.rows[$lineCount])" ><image src="image/edit.gif" title="Edit rule properties" border="0"></a></td>);
        print qq (<a href="javascript:edit_this_rule('$key_for_shortcut','$rulekey');selectedColor(ruleList.rows[$lineCount])" ><image src="image/edit.gif" title="Edit rule properties" border="0"></a></td>);
        
        
        #===================================================================      
        #print checkbox and set its value
        print qq (<td style="width:50" align="center">);
        print qq (<input type="checkbox" name="rule" value="$rulekey">);
        print qq (</td>);

        print qq (</tr>\n);
     
        if ( $rulekey eq $action{keyofrule} ) { print qq (<script>initSelect(ruleList.rows[$lineCount]);</script>); }
        
        $lineCount++;
    }
    print qq (</table>);
    print qq (</div>);
}
#list_ini_rule


#==============================================================================================================
sub list_ini_rule_script 
{
    print << "LIST_INI_RULE_SCRIPT";
    
    <div id="ServiceDiv" class="infodiv"></div>
    <div id="TableDiv" class="infodiv"></div>
   
    <div id="HostDiv" class="infodiv"></div>

    <script type="text/javascript" src="grid.js"></script>
    
    <script language="javascript">
    
    var myform;
    function change()
    {
        var tmp = document.getElementById('source');
        var name =tmp.value;
        alert(name);
    
    }
    
    function cgi_dep_onload() 
    { 
        myform=window.document.forms[0];
        setTimeout("informProute()",500);
    }
    
    function sortPolicy(key)
    {
        myform.sortingkey.value=key;
        myform.submit();
    }    
    
    function delPolicy()
    {
        if (!myform.rule) return;
        var setDeleteOn=false;
        if ( !myform.rule.length ) setDeleteOn=myform.rule.checked;
        for(var i=0;i<myform.rule.length;i++) { if (myform.rule[i].checked) { setDeleteOn=true; break; } }
        if (!setDeleteOn) { alert("There is No Policy Rule Checked"); }
        if (setDeleteOn) { if ( qbConfirm(2, 'Confirm Deletion ?') == 1 )  { goSubmit('DELRULES');} }
    }
    
    function informProute()
    {
        var action=myform.action.value;
        if ( action=="DELRULES" )
        {
            window.top.mainFrame.iniroute.document.forms[0].action.value="UPDATEINTERFACE";        
            window.top.mainFrame.iniroute.document.forms[0].submit();
        }          
    }
    
    function edit_this_rule(rule_key_to_edit, focusedrule)
    {
        document.editpruleform.focusedrule.value=focusedrule;
        var from=document.editpruleform.viewpoint.value;
        var qstring='';
        var params=rule_key_to_edit.split('&'); 
        qstring+='iniroute.cgi?';
        qstring+='viewpoint'+'='+params[0]+'&';
        qstring+='isp'+'='+params[1]+'&';
        qstring+='source'+'='+params[2]+'&';
        qstring+='service'+'='+params[3]+'&';
        qstring+='advance'+'='+params[4]+'&';
        qstring+='dest'+'='+params[5]+'&';
        qstring+='table'+'='+params[6]+'&';
        //add schedule
        qstring+='schedule'+'='+params[7]+'&';
        window.top.mainFrame.iniroute.location.href=qstring;
    }
    
    function showHostInfo(name, addresslist)
    {
        //if(!name ) { return; }
        if ( addresslist == '' )
        {
            addresslist = (name == 'Anywhere') ? ('0.0.0.0/0') : (name);    
        }
        
        HostDiv.innerText="<table class=infodivtable><tr><td>"+"Host Name:" + name + "</td></tr>";
        HostDiv.innerText += "<tr><td>Address Detail:" + addresslist + "</td></tr>";
        
        with(HostDiv)
        {
            innerText+="</table>";
            innerHTML=innerText;
            style.pixelLeft = document.body.scrollLeft;
            style.pixelTop = document.body.scrollTop; 
			style.left= '30px';
			style.top= '20px';
            style.display="block";
        }
    }

    function showServiceInfo(service)
    {
        var pattern=/\\.|\\*|system|others|\\:d|\\:s|\\:/g; service=service.replace(pattern,'');
        if(!service) { return; }
        var service=eval(service);
        
        ServiceDiv.innerText="<table class=infodivtable><tr><td>"+"Service Name:"+service.info[1]+"</td><td>"+"Type:"+service.info[0]+"</td></tr>";
        
        //if ( service.info[0] != 'group' )    
        //{
        with(service)
        for(count=0;count<port.length;count++)
        {
            //Brian for layer7
            if(service.info[0]=="layer7")
            {
              ServiceDiv.innerText+="<tr><td>Protocol:"+port[count].protocol+"</td><td>Info:"+port[count].port+"</td></tr>";
            }
            else
            { 
	    ServiceDiv.innerText+="<tr><td>Protocol:"+port[count].protocol+"</td><td>Port:"+port[count].port+"</td></tr>";
            }
        }
        //}
        
        with(ServiceDiv)
        {
            innerText+="</table>";
            innerHTML=innerText;
            style.pixelLeft = document.body.scrollLeft;
            style.pixelTop = document.body.scrollTop; 
			style.left= '30px';
			style.top= '20px';
            style.display="block";
        }
    }
   
    function showTableInfo(Table)
    {
        if(Table=='$gDROP' || Table=='$gALLPATH' || Table=='$gRRG' || !Table ) { return; } 
        
        var table=eval('T'+Table); 
        
        with(TableDiv)
        {
            innerText="<table class=infodivtable><tr><td>"+"Pool ID:"+Table+"</td><td>";
            //20100223 Brian To show the note of the pool
            innerText+="<td>Pool Name:"+table.I[4]+"</td><td>";
            innerText+="<td>By Packet:"+table.I[0]+"</td><td>";
            innerText+="<td>Mode:"+table.I[1]+"</td><td>";
            innerText+="<td>Truely Aggregate:"+table.I[2]+"</td><td>";
            innerText+="<td>Redirect Host:"+table.I[3]+"</td></tr>";
        }
            
        with(eval('T'+Table))
        for(count=0;count<P.length;count++)
        {
	    TableDiv.innerText+="<tr><td>ISP ID:"+P[count].a+"</td><td>Name:"+P[count].b+"</td><td>Weight:"+P[count].c+"</td><td>DSIP:"+P[count].d+"</td></tr>";
        }
        
        with(TableDiv)
        {
            innerText+="</table>";
            innerHTML=innerText;
            style.pixelLeft = document.body.scrollLeft;
            style.pixelTop = document.body.scrollTop; 
			style.left= '30px';
			style.top= '20px';
            style.display="block";
        }
    }

    function hideTableInfo(){TableDiv.style.display="none";}
    function hideServiceInfo(){ServiceDiv.style.display="none";}
    function hideHostInfo(){HostDiv.style.display="none";}
    
  </script>
    
LIST_INI_RULE_SCRIPT
}
#list_ini_rule_script

#==============================================================================================================
sub show_iniroute 
{
    my (%action)=@_;
    my $fwmark=XMLread($gPATH."fwmark.xml");
    my $fwviewpoint=( $action{viewpoint} eq 'app') ? ( 'nat' ) : ( $action{viewpoint} );
    my $temp=$fwmark->{$fwviewpoint}->[0]->{mark};
    #my $temp=$fwmark->{$action{viewpoint}}->[0]->{mark};
    my $hostref=XMLread($gPATH."host.xml");
    my $hostlist=$hostref->{host};
    my $service=XMLread($gPATH.'service.xml');
    my $servicelist=$service->{service};
    my @hosobj;
    my @destarray;
    
    my $iniroute=XMLread( $gPATH.'iniroute.xml');
    if ( $action{viewpoint} eq 'app' )
    {
        my $temp=$iniroute->{app};
        if ( !$temp )
        {
            runCommand(command=>'/usr/local/apache/qb/setuid/do_qbaddapp.pl', params=>'');
        }
    }
    
    foreach my $host ( @$hostlist )
    {
        if ($host->{hostname} eq 'system' ) { next; }
    	if ($host->{hosttype} ne 'fqdnlist' )
    	{
            push(@hostobj, $host->{hostname});   
        }
        push(@destarray,  $host->{hostname});
    }
    
    #如果是變換視角，就清除介面傳下來的查詢條件參數
    if ( $action{action}=~m/^SWITCHVIEWPOINT$/ ) 
    {
        $action{isp}='';
        $action{source}='';
        $action{service}='';
        $action{advance}='0';
        $action{destination}='';
    }
    elsif ( $action{action}=~m/^SWITCHISP$/ ) 
    {
        $action{source}='';
        $action{service}='';
        $action{advance}='0';
        $action{destination}='';
    }
    elsif ( $action{action}=~m/^SWITCHSOURCE$/ )
    {
        $action{service}='';
        $action{advnace}='0';
        $action{destination}='';
    }
    
    print qq (<table border="0" width="100%" cellspacing="0" cellpadding="0">);
    
    #**************************************************************************************
    # 1. ViewPoint
    #**************************************************************************************
    print qq (<input name="viewpoint" type="hidden" value="$action{viewpoint}">);
    
    
    #**************************************************************************************
    # 2.1 lvs or nat -> source
    #**************************** list nat->source(s) or lvs->source(s) ****************************
    if ( $action{viewpoint}=~m/^nat$|^lvs$|^app$/ ) 
    {
        #**************************** list nat->source(s) ****************************
        my %source;

        foreach my $mark ( @$temp ) { if ( $mark->{source_type} eq '' ) { $source{ $mark->{source} }=1; } }
        #foreach my $mark ( @$temp ) 
        #{ 
        #    #Policy of Real Service remove Q-Balancer
        #    if ( $action{viewpoint} =~m/^lvs$/ && $mark->{source} eq "localhost" ) { next; }
        #    $source{ $mark->{source} }=1; 
        #}  
        if ( $action{viewpoint} eq "nat" || $action{viewpoint} eq 'app' ) { $source{'0.0.0.0/0'}=1; }

        my @allsources=sort subnet_sort keys %source;
        #show host object
        push(@allsources, @hostobj);
        
        if ( !$action{source} ) { $action{source}=$allsources[0]; }
        
        print qq (<td class="body" colspan="8" valign="top" align="center" >);
        print qq (<select class="qbopt" size="1" name="source"  style="WIDTH:130">);
        foreach my $sourceitem ( @allsources ) 
        { 
            if ( $sourceitem eq "system" ) { next; }
            my $status=( $action{source} eq $sourceitem ) ? ( 'selected' ):( '' ); 
            my $displaysource=( $sourceitem eq "localhost" ) ? ('Q-Balancer') : ($sourceitem) ;
            $displaysource=~s/host-//g;
            my $addresslist=maintainHost( action=>'GETADDRESSLIST', hostname=>$displaysource);
            print qq (<option value="$sourceitem" title="$addresslist" $status>$displaysource</option>); 
        }
        print qq (</select><br>Source</td>); 
    }

    #**************************************************************************************
    # 2.2 dmz->source
    #**************************************************************************************
    if ( $action{viewpoint}=~m/^dmz$/ ) 
    {
        #**************************** list isp id(s) ************************************
        my %isphash=maintainBasic( action=>'GETNORMALISPNAMEHASH' );
        my @iidlist=sort keys %isphash;
        if ( !$action{isp} ) { $action{isp}=$iidlist[0]; }
        
        print qq (<tr>);
        print qq (<td class="body"  colspan="8" valign="top" align="center" >);
        print qq (DMZ Zone:<select class="qbopt" size="1" name="isp" onChange="goSubmit('SWITCHISP');" style="WIDTH: 200">);
        foreach my $ispitem ( @iidlist ) 
        {
            my $status=( $action{isp} eq $ispitem ) ? ( 'selected' ):( '' ); 
            print qq (<option value="$ispitem" $status>$isphash{$ispitem} [ ISP $ispitem ]</option>); 
        }    
        print qq (</select><hr size="1"></td>);
        print qq (</tr>);
        
        
        print qq (<tr>);
        
        #**************************** list dmz(isp)->source(s) ****************************
        my %source;
        foreach my $mark ( @$temp ) 
        {
            if ( $mark->{dirty} ) { next; } 
            if ( $action{isp} ne maintainBasic( action=>'GETBELONGIID', subnet=>$mark->{source} ) ) { next; }
            $source{ $mark->{source} }=1; 
        }
        
        my @allsources=keys(%source);
        if ( !$action{source} ) { $action{source}=$allsources[0]; }
              
        print qq (<td class="body"  valign="top" align="center" >);
        print qq (<select class="qbopt" size="1" name="source" onChange="goSubmit('SWITCHSOURCE')" style="WIDTH:130">);
        foreach my $sourceitem ( sort subnet_sort @allsources ) 
        { 
            my $status=( $action{source} eq $sourceitem ) ? ( 'selected' ) : ( '' ); 
            print qq (<option $status value="$sourceitem" >$sourceitem</option>);
        }
        print qq (</select><br>Source</td>);
    }
=cut
    #****** judge if it is in advance mode *******************************  
    if ( !$action{advance} ) { $action{destination}='system'; }
    
    #*********************************************************************
    my @destarray=maintainOverview(action=>'GETDESTINATION');
    
    my $event=( @destarray > 0 ) ? ( 'onChange' ) : ( 'onClick' );
    
    my $status=( $action{advance} ) ? ('checked') : ('');

    print qq (<td class="body" valign="top" align="center">);
    print qq (<select class="qbopt" size="1" name="dest" disabled $event="dest_on_change()" style="width:120">);
    foreach my $dest ( sort @destarray ) 
    {
      
        my $status=( $action{destination} eq $dest ) ? ( 'selected' ):( '' ); 
        ( $dest eq 'edit' ) ? ( print qq (<option $status value="$dest">-- Edit --</option>) ) : ( print qq (<option $status value="$dest">$dest</option>) ); 
    }
    print qq (<option value="edit">-- Edit --</option>);
    print qq (</select><br>);
    print qq (<input type="checkbox" name="advance" $status onClick="advance_action()">);
    print qq (Destination);
    print qq (</td>);
=cut
    #*********************************************************************
    print qq (<td class="body" valign="top" align="center">);
    print qq (<select class="qbopt" size="1" name="dest"  style="width:120">);
    my $status=( $action{destination} eq $dest ) ? ( 'selected' ):( '' ); 
    print qq (<option $status value="system">0.0.0.0/0</option>);
    foreach my $dest ( sort @destarray ) 
    {
    	my $showdest = $dest; 
        my $status=( $action{destination} eq $dest ) ? ( 'selected' ):( '' ); 
        $showdest =~ s/host-//g;
        my $addresslist=maintainHost( action=>'GETADDRESSLIST', hostname=>$showdest);
        if ($addresslist =~ m/([a-fA-F0-9]{2}):([a-fA-F0-9]{2}):([a-fA-F0-9]{2}):([a-fA-F0-9]{2}):([a-fA-F0-9]{2}):([a-fA-F0-9]{2})/){next;}
        print qq (<option value="$dest" title="$addresslist" $status>$showdest</option>); 
        #print qq (<option $status value="$dest">$showdest</option>);
    }
    my @destarray=maintainOverview(action=>'GETDESTINATION');
    foreach my $dest ( sort @destarray )
    {
        my $status=( $action{destination} eq $dest ) ? ( 'selected' ):( '' );
        print qq (<option $status value="$dest">$dest</option>);
    }
    print qq (</select><br>);
    print qq (Destination);
    print qq (</td>);
    #20101228 
    $action{advance} = ( $action{destination} eq 'system' ) ? ( '0' ) : ( '1' );
    
    #**************************************************************************************
    # 3.1  dmz | nat | lvs -> service(s)
    #**************************************************************************************
    if ( $action{viewpoint}=~m/dmz|nat|lvs/ ) 
    { 
        #**************************** list *->source->service(s)  ****************************
        
        print qq (<td class="body"  valign="top" align="center" >);
        print qq (<select class="qbopt" size="1" name="service" onchange="" style="WIDTH:100;">);
        my $status=( $action{service} eq "others:d" ) ? ( 'selected' ) : ( '' ); 
        print qq (<option $status value="others:d">ANY(RQST)</option>); 
        my $status=( $action{service} eq "others:s") ? ( 'selected' ) : ( '' ); 
        print qq (<option $status value="others:s">ANY(RPLY)</option>); 
	
        foreach my $service (  @$servicelist ) 
        { 
            #if ( $service->{type} ne 'qb' && $service->{type} ne 'layer7' && $service->{type} ne 'system' )
            if ( $service->{type} eq 'known' || $service->{type} eq 'user' )
            {
                my $status=( $action{service}=~m/^$service->{title}:d$/) ? ( 'selected' ) : ( '' ); 
                print qq (<option $status value="$service->{title}:d">$service->{title}(RQST)</option>); 
                my $status=( $action{service}=~m/^$service->{title}:s$/) ? ( 'selected' ) : ( '' ); 
                print qq (<option $status value="$service->{title}:s">$service->{title}(RPLY)</option>); 
            }
        }
	my $serg=XMLread($gPATH.'sergroup.xml');
	my $serglist=$serg->{sergroup};
        foreach my $serg ( @$serglist )
        { 
            if ( $serg->{sergroup} eq 'system' ) { next; }
            my $status=( $action{service}=~m/^$serg->{sergroup}:d$/ ) ? ( 'selected' ) : ( '' ); 
            print qq (<option $status value="$serg->{sergroup}:d">$serg->{sergroup}(RQST)</option>); 
            my $status=( $action{service}=~m/^$serg->{sergroup}:s$/ ) ? ( 'selected' ) : ( '' ); 
            print qq (<option $status value="$serg->{sergroup}:s">$serg->{sergroup}(RPLY)</option>); 
        }
	
        print qq (</select><br><input type="button" class="qb" value="Service" title="Display detail Info. of selected Service" style="width:100" onmousedown="popUpServiceInfo()" onmouseout="hideServiceInfo()">);
        print qq (</td>);
    }
    elsif ( $action{viewpoint}=~m/app/ ) 
    {
        use File::Find;
        find( { wanted => sub { push(@FileList, $_) }, no_chdir => 1 },'/usr/local/apache/qbconf/l7-object/' );   
        print qq (<td class="body"  valign="top" align="center" >);
        print qq (<select class="qbopt" size="1" name="service" onchange="" style="WIDTH:100;">);
        $action{service}=~s/:d//g;
        $action{service}=~s/:s//g;
        foreach my $service (  @$servicelist ) 
        { 
            if ( $service->{type} eq 'layer7' )
            {
                my $status=( $action{service}=~m/^$service->{title}$/) ? ( 'selected' ) : ( '' ); 
                print qq (<option $status value="$service->{title}">$service->{title}</option>); 
            }
        }
        print qq (<option $status value="">---User_Definition---</option>);
        foreach my $service1 ( @FileList )
        {
            if (!grep(/\.pat/,$service1) || !grep(/UD/,$service1)){next;}
            $service1 =~ s/\/usr\/local\/apache\/qbconf\/l7-object\///g;
            $service1 =~ s/_UD\.pat//g;
            my $status=( $action{service}=~m/^$service1$/) ? ( 'selected' ) : ( '' );
            print qq (<option $status value="$service1">$service1</option>);
        }                
        print qq (</select><br><input type="button" class="qb" value="Application" title="Display detail Info. of selected Service" style="width:100" onmousedown="popUpServiceInfo()" onmouseout="hideServiceInfo()">);
        print qq (</td>);
    }
    
    #**************************************************************************************
    # 3.2 lvs -> belongisp(s)
    #**************************** list lvs->source->belongisp(s)****************************
    if ( $action{viewpoint}=~m/^lvs$/ ) 
    {
        my %ispname=maintainBasic(action=>'GETISPNAMEHASH');
        my @belong_isp_list=maintainVS( action=>"GETBELONGISPNUM", service=>$action{service}, rserver=>$action{source} );
        print qq (<span id="obj" class="prompt">);
        print qq (This Virtual Server belongs to:<br>);
        foreach my $belong_isp ( @belong_isp_list ) { print qq ($ispname{$belong_isp} [ ISP $belong_isp ]<br>); }
        print qq (</span>);
    }
    
    #*********************************************************************
    init_class_show(%action);
    
}
#show_iniroute

#=============================================================================
sub init_class_show 
{
    (%action)=@_;
    my $iniroute=XMLread( $gPATH.'iniroute.xml');
    my $schref=XMLread($gPATH.'schedule.xml');
    my $schlist=$schref->{schedule};
    my $qosref=XMLread($gPATH.'qos.xml');
    my $qoslist=$qosref->{qos};
    
    my $target;
    my %desthash;
    
    
    $temp=$iniroute->{$action{viewpoint}}->[0]->{class};
    #**************************** search key: ( source x service x direction x destination x table ) in iniroute in certern ViewPoint *****
    #比對介面傳達的搜尋條件，找出符合條件的 policy rule，若有，則將它show出來
    
    my $target_exist=0;

    if ( $action{viewpoint} eq 'app' )
    {
        $action{service}=~s/:d//g;
        $action{service}=~s/:s//g;
    	foreach my $item ( @$temp ) 
        { 
            #20101227 add schedule
            if ( $item->{source}.$item->{service}.$item->{destination}.':'.$item->{table}.$item->{schedule}  ne $action{source}.$action{service}.$action{destination}.':'.$action{table}.$action{schedule} ) { next; }
            $target_exist=1;
            $target=$item; 
            last; 
        }
    }
    else
    {
    	foreach my $item ( @$temp ) 
        { 
            if ( $item->{source}.$item->{service}.':'.$item->{direction}.$item->{destination}.':'.$item->{table}.$item->{schedule}  ne $action{source}.$action{service}.$action{destination}.':'.$action{table}.$action{schedule} ) { next; }
            $target_exist=1;
            $target=$item; 
            last; 
        }
    }

    #**************************** show schedule list ******************************************
    print qq (<td class="body"  valign="top" align="center" >);
    print qq (<select class="qbopt" size="1" name="schedule" style="width:80">);
    
    #my @seqarray=timesegarray2seqarray( $target->{time} );    
    
    #if ( @seqarray <= 0 ) { @seqarray=(1..144); }

    print qq (<option value="All Week" $status>All Week</option>); 
    foreach my $seq ( @$schlist ) 
    { 
        if ( $seq->{schname} eq "system" ) { next; }
        #my $status=( grep(/^$seq$/,@seqarray) ) ? ( 'selected' ) : ( '' );
        #my $section=timeseq2section( $seq );
        my $status=( $target->{schedule} eq $seq->{schname} ) ? ( 'selected' ) : ( '' );
        print qq (<option $status value="$seq->{schname}" $status>$seq->{schname}</option>); 
    }
    #foreach my $seq ( 1..144 ) 
    #{ 
    #    my $status=( grep(/^$seq$/,@seqarray) ) ? ( 'selected' ) : ( '' );
    #    my $section=timeseq2section( $seq );
    #    print qq (<option value="$seq" $status>$section</option>); 
    #}
    print qq (</select><br>);
    #print qq (<input type="button" name="ALLSCHEDULE" class="qb" value="A" title="Select All" onclick="allSchedule()"   style=" height:20 width:20">);
    #print qq (<input type="button" name="EXPANDSCHEDULE" class="qb" value="E" title="Expand Schedule" onclick="expandSchedule()"   style=" height:20 width:20">);
    print qq (Schedule);
    #print qq (<input type="button" name="SHRINKSCHEDULE" class="qb" value="C" title="Collapse Schedule" onclick="shrinkSchedule()" style="height:20 width:20">);
    #print qq (<input type="button" name="NONESCHEDULE" class="qb" value="N" title="Unselect All" onclick="noneSchedule()" style="height:20 width:20"><br>);
    print qq (</td>);

    #=====================================================================================    
    #  List applicable table(s) and indicate old used table 
    #  Reproduce the message hash %action to %getApplicableTableIDs, and mark the action key as 'GETAPPLICABLETABLEIDS'

    #======== keep sip list ==============================================================
    my $siplist;
    if ( $action{action} ne 'UPDATEINTERFACE' ) { $siplist=$target->{sip}; $action{sip}=$target->{sip}; }
    if ( $action{action} eq 'UPDATEINTERFACE' ) { $siplist=$action{sip}; }

    #==== keep method infomation  ========================================================
    if ( $action{action} ne 'UPDATEINTERFACE' ) { $action{method}=$target->{method}; }
    
    if      ( $action{viewpoint} eq "nat" && !$action{method} && $action{service}=~m/:s$/  )        { $action{method}='none'; }
    elsif   ( $action{viewpoint} eq "nat" && !$action{method} && $action{service}!~m/:s$/  )        { $action{method}='ls'; }
    elsif   ( $action{viewpoint} eq "app" && !$action{method} && $action{service}!~m/:s$/  )        { $action{method}='ls'; }
    elsif   ( $action{viewpoint} eq "dmz" && !$action{method} )                                     { $action{method}='none'; }
    #else { $action{method}='ls'; }
    
    if( $action{method} eq 'ls' && @$siplist > 0 )   { $action{method}="manual_ls"; }
    
    #========================================================================
    # make decision : disable or enable NAT
    my $enableNAT='';
    
    #**************** if View Point is NAT or DMZ, show System IP 
    my ( $source, $direction )=split( /:/,$action{service} );  
    if ( $action{viewpoint}=~m/^nat$|^dmz$|^app$/ )
    {
        my $ispid=findMyISP(subnet=>$action{source}); 
        if ( $ispid ) { $action{isp}=$ispid; }

        if ( $action{source} eq '0.0.0.0/0' ) 
        {
            $enableNAT='disabled';
        }
        elsif ( $action{viewpoint}=~m/^nat$/ && $action{service}=~m/:s$/ ) 
        { 
            # if this NAT source is within ISP public IP range , we should disable NAT, and deal with it as DMZ 
            $enableNAT='disabled';
        }
        elsif ( $action{viewpoint}=~m/^dmz$/ && $action{service}=~m/:s$/ ) 
        { 
            $enableNAT='disabled'; 
        }
    }

    my %getApplicableTableIDs=%action; 
    $getApplicableTableIDs{action}='GETAPPLICABLETABLEIDS';  
    my @tablelist;
    
    if ( $action{viewpoint} eq 'app' )
    {
        my $temp = $action{method};
       
        @tablelist=maintainRtable( %getApplicableTableIDs );
        #@tablelist=maintainIniroute( action=>'GETSRCTABLE', source=>$action{source}, destination=>$action{destination} );
        $action{viewpoint} = 'app';
        $action{method} = $temp;
    }
    else
    {
        @tablelist=maintainRtable( %getApplicableTableIDs ); 
    }
    
    my $original_obsolete;
    if ( $target_exist ) { $original_obsolete=1;}
    if ( grep(/^$target->{table}$/, @tablelist) ) { $original_obsolete=0; } 
    
    print qq (<td class="body"  valign="top" align="center">);
    #print qq (<select class="qbopt" size="1" name="table" style="width:100" onChange="onoffSchedule()">);
    print qq (<select class="qbopt" size="1" name="table" id="table" style="width:100" onChange="IsDrop()">);
     
    if ( $original_obsolete ) 
    {
        my  $showtable=presentTable($target->{table});
        print qq (<option selected value="$target->{table}">$showtable [OBS]</option>);
    }
    my @showtable = presentTables(@tablelist);
    my $index = 0;
    foreach my $tableitem ( @tablelist ) 
    {
        my  $status=( $tableitem eq $target->{table} ) ? ( 'selected' ) : ( '' ); 
 
        #my $showtable=presentTable($tableitem);

        #print qq (<option $status value="$tableitem">$showtable</option>);
        #if ($action{source}=~m/IPV6/ || $action{source}=~m/\d{1,4}:/ )
        print qq (<option $status value="$tableitem">$showtable[$index]</option>);
        $index++;
    }
 
    print qq (</select><br>);
    print qq (<input type="button" name="SHOWTABLEINFO" class="qb" value="Pool" title="Display detail Information of selected Routing Pool" onmousedown="popUpTableInfo()"  onmouseout="hideTableInfo()" style="width:100">);
    print qq (</td>);
    
    if ( $action{viewpoint}=~m/^nat$|^dmz$|^app$/ )
    {
        #==== sip infomation  ========================================================
        #my %ispname=maintainBasic(action=>'GETISPNAMEHASH');
        my @iidlist = maintainBasic(action=>'GETGOODIIDLIST');
        my @iidlist = sort { $a <=> $b } @iidlist;
        
        print qq (<td class="body"  valign="top" align="center" >);
        
        if ( !$action{sipstatus} ) { $action{sipstatus}=1; }
        
        print qq (<input type="hidden" name="sipstatus" value="$action{sipstatus}">);
        
        print qq (<select $enableNAT class="qbopt" multiple size="$action{sipstatus}" name="sip" id="sip" style="WIDTH:160"  onchange="filterTable()"> );
       
        my $ref=XMLread($gPATH.'ipbank.xml'); 
        #my $ipbanklist = $ref->{ip};
        #foreach my $ipbank ( @$ipbanklist )
        #{
        #    if ( grep(/*.dmz/, $ipbank->{name}) ) { next; }
        #}
        foreach my $iid ( @iidlist ) 
        {
            my $public=$ref->{ip}->{'isp'.$iid.'public'}->{opt};
            my $system=$ref->{ip}->{'isp'.$iid.'system'}->{opt}[0];
            my @tempip;
            foreach my $ipbank ( @$public ) 
            {
                if ( $ipbank eq $system || $ipbank eq 'system' ) { next; }
                push(@tempip, $ipbank);
            }
            push (@tempip, 'systemip');
            
            my $targetsip;
 
            foreach my $sip ( @$siplist ) { if ( $sip->{isp} eq $iid ) { $targetsip=$sip; } }

            foreach my $natip ( @tempip ) 
            { 
                my $sipip=$iid.'j'.$natip; 
                my $status=( grep(/^$natip$/, $targetsip->{ip}) ) ? ( 'selected' ) : ('');     
                print qq (<option $status value="$sipip">ISP $iid [ $natip ]</option>); 
            }
        }
=cut
        foreach my $iid ( @iidlist) 
        {
            #my @natips=maintainIPBank(action=>'READPUBLICIP', isp=>$iid);
            #my @natips=maintainIPBank(action=>'NEWREADPUBLICIP', isp=>$iid);

            my $targetsip;
 
            foreach my $sip ( @$siplist ) { if ( $sip->{isp} eq $iid ) { $targetsip=$sip; } }

            foreach my $natip ( @natips ) 
            { 
                my $sipip=$iid.'j'.$natip; 
                my $status=( grep(/^$natip$/, $targetsip->{ip}) ) ? ( 'selected' ) : ('');     
                print qq (<option $status value="$sipip">ISP $iid [ $natip ]</option>); 
            }

        }
=cut
        print qq (</select><br>);

        print qq (<input $enableNAT type="button" name="EXPANDNATIP" class="qb" value="E" title="Expand" onclick="expandNATIP()"  style=" height:20 width:20">);
        
        
        #my $byPathStatus=( $action{method} eq 'ls' ) ? ("checked") : ("");
        #print qq (<input $enableNAT type="checkbox" name="method" value="ls" $byPathStatus onClick="filterTable()">Smart NAT);
	
	if ( $gENABLETM )
	{
	    if ($action{source} =~ m/IPv6/ || $action{source} =~ m/\d{1,4}:/) {%methods=( "No NAT" => "none");}
            else{%methods=("No NAT" => "none");}
	}
	else
	{
	    if ($action{source} =~ m/IPv6/ || $action{source} =~ m/\d{1,4}:/) {%methods=( "No NAT" => "none");}
            else{%methods=("Smart NAT" => "ls", "Manual NAT" => "manual_ls", "No NAT" => "none");}
	}
        print qq (<select class="qbopt" size="1" name="method" id="method" style="WIDTH:130"  onchange="filterTable()">);
        foreach my $natkey ( sort keys %methods )
        {
            my $status=( $methods{$natkey} eq $action{method} ) ? ('selected') : ('');
            print qq ( <option $status value="$methods{$natkey}">$natkey</option>);
        }
        print qq (</select>);
        
        print qq (<input $enableNAT type="button" name="SHRINKNATIP" class="qb" value="C" title="Collapse" onclick="shrinkNATIP()"  style="height:20 width:20">);
    }
    print qq (<td class="body"  valign="top" align="center" >);
    print qq (<select class="qbopt" size="1" name="qos" id="qos" style="WIDTH:80"  onchange="">);
	$jsqosarray ="";$usdf = 0;
    my $status=( $target->{qos} eq 'None' ) ? ( 'selected') : ( '' );
    print qq (<option $status value="None">None</option>); 
    foreach my $qos ( @$qoslist )
    {
    	
		if ( $qos->{qosname} eq 'system' ) { next; }
		# if ( $qos->{pool} ne $target->{table} && $target->{table} ne "" ) { next; }
        my $status=( $qos->{qosname} eq $target->{qos} ) ? ( 'selected') : ( '' );
        print qq (<option $status value="$qos->{qosname}" id="qosid$qos->{qosname}">$qos->{qosname}</option>); 
		if($qos->{pool} >=1){
		$jsqosarray.="myqos[".$usdf."]=".'"'.$qos->{pool}.','.$qos->{qosname}.'";';
		$usdf = $usdf+1;
		}
    }
    print qq (</select><br>Qos);
    
    #**************************************************************************************
    print qq (<td class="body" align="right" valign="top">);
    #print qq (<td class="body" align="center" valign="top">);
    #print qq (<select class="qbopt" size="1" name="qos" style="WIDTH:100"  onchange="">);
    #print qq (</select>);
    #print qq (<br>QoS<br>);
    #print qq (<input type="button" class="qb" value="+"    title="Add Policy"    onClick="updatePolicy('ADD')" style="height:20 width:20">);
    #print qq (<input type="button" class="qb" value="U"    title="Save Changes"  onClick="updatePolicy('UPDATE')" style="height:20 width:20">);
    print qq (<input type="button" class="qb" value="Add"    title="Add Policy"    onClick="updatePolicy('ADD')" style="height:20 width:25">);
    print qq (<input type="button" class="qb" value="Update" title="Save Changes"  onClick="updatePolicy('UPDATE')" style="height:20 width:35">);
            
    if ( $action{viewpoint} ne "lvs" ) { print qq (<br>); }
    
    if ( $action{viewpoint} eq "lvs" )
    {
        #print qq (<input type="button" class="qb" value="B"  title="Go Back to Server Mapping"  onClick="goBackToServerMapping()" style="height:20 width:20"><br>);
        print qq (<input type="button" class="qb" value="Back"  title="Go Back to Server Mapping"  onClick="goBackToServerMapping()" style="height:20 width:20"><br>);
    }

    print qq (</td></tr>);
    print qq (</table>);
}
#init_class_show

#===============================================================================================
sub iniroute_script 
{
    print << "INIROUTE_SCRIPT";

    <div id="ServiceDiv" class="infodiv"></div>
    <div id="TableDiv" class="infodiv"></div>

  <script language="javascript">
      
    var dropTable=$gDROP;
    var myform=window.document.forms[0];  
  
    function cgi_dep_onload()
    {
    	//20101228 remove
        //onoffdest();
        //onoffSchedule();
        IsDrop();
        //20111117 Brian fix: after updating the lvs policy,the page can not return.
        //IsSip is used to check manual nat or not. lvs policy does not have nat method.
        var viewpoint=myform.viewpoint.value;
        if (viewpoint != 'lvs')
        {
        IsSip();
        }
        setTimeout("updateShow()",500);
    }
    
    function IsDrop()
    {
        var table=document.getElementById('table').value;
        var qos=document.getElementById('qos');
        var myqos = new Array();
		$jsqosarray
        //alert(table);
        if ( table == '255' ){
			qos.value = "None";
            qos.disabled = true;
			}
        else{
			
            qos.disabled = false;
			while(qos.firstChild){
				qos.removeChild(qos.firstChild);
			}
			qos.add(new Option("None","None"));
			for(var fjk=0;fjk<myqos.length;fjk++){
			var hhji =myqos[fjk].split(",");
				if(hhji[0]==table) {
					qos.add(new Option(hhji[1],hhji[1]));
				}
			}
			}
    }
    
    function IsSip()
    {
        var method = document.getElementById('method').value;
        var sip = document.getElementById('sip');
        
        if (method != 'manual_ls')
        {
            sip.disabled = true;
        }
        else
        {
            sip.disabled = false;
        }
    }

    function updateShow()
    {
        var action=myform.action.value;

        if ( action=='UPDATE' || action=='ADD' )
        {
            var viewpoint=myform.viewpoint.value;
            var keyofrule=myform.keyofrule.value;
            var qstring='';
            qstring+='editinirule.cgi'+'?'+'viewpoint='+viewpoint+'&';
            qstring+='keyofrule='+keyofrule;
	    window.top.mainFrame.editinirule.location.href=qstring;
        }
    }

    function onoffSchedule()
    {
        return; 

        var table=myform.table.value;
        
        if ( table==dropTable ) 
        { 
            myform.schedule.disabled=true; 
            myform.NONESCHEDULE.disabled=true;
            myform.ALLSCHEDULE.disabled=true;
            myform.EXPANDSCHEDULE.disabled=true;
            myform.SHRINKSCHEDULE.disabled=true;
        }
        else
        {
            myform.schedule.disabled=false; 
            myform.NONESCHEDULE.disabled=false;
            myform.ALLSCHEDULE.disabled=false;
            myform.EXPANDSCHEDULE.disabled=false;
            myform.SHRINKSCHEDULE.disabled=false;
        }


    }

    function filterTable()
    {
        goSubmit('UPDATEINTERFACE');
    }

    function onoffdest()
    {
        var myform=document.prouteform;
        //20101228 remove  
        //if(myform.advance.checked) { myform.dest.disabled=false; }
        //else { myform.dest.disabled=true; }
    }
    
    function advance_action()
    { 
        var myform=document.prouteform;
        //if(myform.advance.checked) { myform.dest.disabled=false; }
        //else { myform.dest.disabled=true; }
        goSubmit();  
    }

    function dest_on_change()   
    {
        if(document.prouteform.dest.value=='edit') { editdest=openWin('./editdest.cgi'); }
        else { goSubmit('CHANGEDEST'); }
    }

    function expandSchedule()   { myform.schedule.size="8"; }
    function shrinkSchedule()   { myform.schedule.size="1"; }
    function expandNATIP()      { myform.sipstatus.value=myform.sip.size="8"; }
    function shrinkNATIP()      { myform.sipstatus.value=myform.sip.size="1"; }
    
    function allSchedule()
    {
        var schedule=myform.schedule;
        for(var i=0; i<schedule.options.length; i++) { schedule.options[i].selected=true;}
    }
    
    function noneSchedule()
    {
        var schedule=myform.schedule;
        for(var i=0; i<schedule.options.length; i++) { schedule.options[i].selected=false;}
    }
    
    function updatePolicy(action)
    {
        var report="";
        var okToGo=true;

        if (action=='UPDATE') { myform.focusedrule.value=window.top.mainFrame.editinirule.document.forms[0].focusedrule.value; }
        
        //check source
        if ( !myform.source.value )  { report+="Source is Must"+"\\n"; okToGo=false; }
        
        //check service
        if ( !myform.service.value ) { report+="Service is Must"+"\\n"; okToGo=false; }
        
        //check advance //Brian Mark it for fqdn
        //if ( myform.advance.checked && !isValidIP(myform.dest.value) && !isValidSubnet(myform.dest.value) ) { report+="Destination is a Must in Advance Mode"+"\\n"; okToGo=false; }
        
        //check table
        if ( !myform.table.value ) { report+="Table is Must"+"\\n"; okToGo=false; }
    
        //check schedule
        var schedulePass=false;
        var schedule=myform.schedule;
        for(var i=0; i<schedule.options.length; i++) 
        { 
            schedulePass=schedule.options[i].selected;
            if ( schedulePass ) break;
        }
        
        var table=myform.table.value;
        if ( table==dropTable ) { schedulePass=true; }

        if ( !schedulePass ) { report+="Choose at least one time segment"+"\\n"; okToGo=false; }

        if ( !okToGo )  alert(report); 
        if ( okToGo )   goSubmit(action);
    }
    
    function popUpTableInfo()
    {
        var table=myform.table.value;
        showTableInfo(table);
    }

    function popUpServiceInfo()
    {
        var service=myform.service.value;
        showServiceInfo(service);
    }
    
    function showServiceInfo(service)
    {
        var pattern=/\\.|\\*|system|others|\\:d|\\:s|\\:/g; service=service.replace(pattern,'');
        if(!service) { return; }
        var service=eval(service);
        ServiceDiv.innerText="<table class=infodivtable><tr><td>"+"Service Name:"+service.info[1]+"</td><td>"+"Type:"+service.info[0]+"</td></tr>";
        
        
            
        with(service)
        for(count=0;count<port.length;count++)
        {
	    ServiceDiv.innerText+="<tr><td>Protocol:"+port[count].protocol+"</td><td>Port:"+port[count].port+"</td></tr>";
        }
        
        with(ServiceDiv)
        {
            innerText+="</table>";
            innerHTML=innerText;
            style.pixelLeft = document.body.scrollLeft;
            style.pixelTop = document.body.scrollTop; 
			style.left= '30px';
			style.top= '20px';
            style.display="block";
        }
    }
    
    function showTableInfo(Table)
    {
        if( !Table || Table=='$gDROP' || Table=='$gALLPATH' || Table=='$gRRG' ) 
        { 
            alert("no info !!");
            return; 
        } 

        var table=eval('T'+Table);

        with(TableDiv)
        {
            innerText="<table class=infodivtable><tr><td>"+"Pool ID:"+Table+"</td><td>";
            //20100223 Brian To show the note of the pool
            innerText+="<td>Pool Name:"+table.I[4]+"</td><td>";
            innerText+="<td>By Packet:"+table.I[0]+"</td><td>";
            innerText+="<td>Mode:"+table.I[1]+"</td><td>";
            innerText+="<td>Truely Aggregate:"+table.I[2]+"</td><td>";
            innerText+="<td>Redirect Host:"+table.I[3]+"</td></tr>";
        }
            
        with(eval('T'+Table))
        for(count=0;count<P.length;count++)
        {
	    TableDiv.innerText+="<tr><td>ISP ID:"+P[count].a+"</td><td>Name:"+P[count].b+"</td><td>Weight:"+P[count].c+"</td><td>DSIP:"+P[count].d+"</td></tr>";
        }
        
        with(TableDiv)
        {
            innerText+="</table>";
            innerHTML=innerText;
            style.pixelLeft = document.body.scrollLeft;
            style.pixelTop = document.body.scrollTop; 
			style.left= '30px';
			style.top= '20px';
            style.display="block";
        }
    }

    function goBackToServerMapping() { window.top.mainFrame.location.href="vs.cgi"; }

    function hideTableInfo(){TableDiv.style.display="none";}
    function hideServiceInfo(){ServiceDiv.style.display="none";}
    
  </script>
  
  
INIROUTE_SCRIPT
}
#iniroute_script

#===================================================================================================
#maintainIniroute(%action)
sub maintainIniroute 
{
    my (%action)=@_;
    if ( !$action{action} ) { return; }
    my $iniroute=XMLread($gPATH."iniroute.xml");
    my $fwmark=XMLread($gPATH."fwmark.xml");
    my $target;
    my $hostref=XMLread($gPATH.'host.xml');
    my $hostlist=$hostref->{host};
    
    #ex:( action=>'CHANGESOURCE', viewpoint=>'', source=>'', newsource=>'', newisp=>'')
    if ( $action{action}=~m/^CHANGESOURCE$/ ) 
    {
        if ( !$action{newisp} ) { $action{newisp}='*'; }
        my $classes=$iniroute->{$action{viewpoint}}->[0]->{class};
        foreach my $class ( @$classes ) 
        {
            if ( $class->{source} ne $action{source} ) { next; }
            $class->{isp}=$action{newisp};
            $class->{source}=$action{newsource};
        }
    }
    elsif ( $action{action}=~m/^AUTODOS$/ )
    {
        my $qosref=XMLread($gPATH.'qos.xml');
        my $qoslist = $qosref->{qos};
        my $inilist = $iniroute->{nat}->[0]->{class};
        foreach my $init (@$inilist)
        {
            if( $init->{table} > 100 || $init->{qos} ne 'None' || $init->{table} eq 30){next;}
            foreach my $qos (@$qoslist)
            {
                if ($init->{table} ne $qos->{pool}){next;}
                if ($qos->{qosname} eq ""){$init->{qos} = 'None';};
                $init->{qos} = $qos->{qosname};
            }
        }
        XMLwrite($iniroute, $gPATH."iniroute.xml");   
     }
     elsif ( $action{action}=~m/^REPEAT$/ )
    {
         my $rtable = XMLread($gPATH.'rtable.xml');
         my $rtables = $rtable->{table};
         my $ini = $iniroute->{nat}->[0]->{class};
         foreach my $tab (@$rtables)
         {
             my $y = '0';
             foreach my $iniref (@$ini)
             {
                 if($tab->{table_num} ne $iniref->{table}){next;}
                 $y = '1';
                 last;
             }
             if ($y eq '0')
             {
                 my $target = $tab;
                 my $list = $target->{path};
                 foreach my $ref (@$list)
                 {
                     if ($ref->{dsip} ne '' && $ref->{weight} ne '1' && $ref->{subnet} ne ''){next;}
                     my $isp = XMLread($gPATH.'basic.xml');
                     my $isplist = $isp->{isp};
                     foreach my $ispref (@$isplist)
                     {
                         if (!grep(/tunnel/,$ispref->{isptype})){next;}
                         if (grep(/^dtunnel$/,$ispref->{isptype}))
                         {
                             maintainTMV(action=>'SAVE',adp_com=>"$ispref->{adp_com}",alg=>"$ispref->{alg}",alive=>"$ispref->{alive}",allpool=>"$ispref->{allpool}",alltmv=>"$ispref->{alltmv}",download=>"$ispref->{download}",dport=>"$ispref->{dport}",enabled=>"$ispref->{enabled}",enc=>"$ispref->{enc}",gateway=>"$ispref->{gateway}",iid=>"$ispref->{iid}",ipcom=>"0",ispname=>"$ispref->{ispname}",ispnumber=>"$ispref->{ispnumber}",isptype=>"$ispref->{isptype}",local=>"$ispref->{local}",mpv_nat=>"$ispref->{mpv_nat}",mpv_nat_ip=>"$ispref->{mpv_nat_ip}",mss=>"$ispref->{mss}",mss_value=>"$ispref->{mss_value}",mtu=>"$ispref->{mtu}",mtu_value=>"$ispref->{mtu_value}",nic=>"$ispref->{nic}",pkchk=>"$ispref->{pkchk}",poolBuff=>"$ispref->{poolBuff}",poolComp=>"$ispref->{poolBuff}",poolDownUp=>"$ispref->{poolDownUp}",poolEnCmp=>"$ispref->{poolEnCmp}",poolEnc=>"$ispref->{poolEnc}",poolIp=>"$ispref->{poolIp}",poolMss=>"$ispref->{poolMss}",poolMtu=>"$ispref->{poolMtu}",poolPkChk=>"$ispref->{poolPkChk}",poolTxqueue=>"$ispref->{poolTxqueue}",poolnum=>"$ispref->{poolnum}",port=>"$ispref->{port}",remote=>"$ispref->{remote}",remotename=>"$ispref->{remotename}",state=>"$ispref->{state}",systemip=>"$ispref->{systemip}",target=>"$ispref->{target}",tmvbuf=>"$ispref->{tmvbuf}",traversal_port=>"$ispref->{traversal_port}",tunnel_role=>"$ispref->{tunnel_role}",txqueue=>"$ispref->{txqueue}",upload=>"$ispref->{upload}",tmp=>"1");
                         }
                     }
                 }
             }
         }
    }
    elsif ( $action{action}=~m/^CHECK$/ )
    {
        my $rtable = XMLread($gPATH.'rtable.xml');
        my $ini = $iniroute->{nat}->[0]->{class};
        my $rtables = $rtable->{table};
        foreach my $iniref (@$ini)
        {
            if ($iniref->{method} ne 'none' || $iniref->{table} > 99 || $iniref->{table} eq '30'){next;}
            foreach my $tab (@$rtables)
            {
                if($tab->{table_num} ne $iniref->{table} || ($tab->{mode1} ne 'TB' && $tab->{mode} eq 'WLC')){next;}
                my $target = $tab;
                my $list = $target->{path};
                my $x = '0';
                foreach my $ref (@$list)
                {
                    if ($ref->{dsip} ne '' && $ref->{weight} ne '1' && $ref->{subnet} ne ''){next;}
                    $x++;
                }
                if ( $x > 1 )
                {
                    foreach my $ref (@$list)
                    {
                        if ($ref->{dsip} ne '' && $ref->{weight} ne '1' && $ref->{subnet} ne ''){next;}
                        my $isp = XMLread($gPATH.'basic.xml');
                        my $isplist = $isp->{isp};
                        foreach my $ispref (@$isplist)
                        {
                            if (!grep(/tunnel/,$ispref->{isptype})){next;}
                            if ($ref->{isp} ne $ispref->{iid} || $ispref->{ipcom} eq '1'){next;}
                            if (grep(/^tunnel$/,$ispref->{isptype}))
                            {
                            }
                            if (grep(/^dtunnel$/,$ispref->{isptype}))
                            {
                                maintainTMV(action=>'SAVE',adp_com=>"$ispref->{adp_com}",alg=>"$ispref->{alg}",alive=>"$ispref->{alive}",allpool=>"$ispref->{allpool}",alltmv=>"$ispref->{alltmv}",download=>"$ispref->{download}",dport=>"$ispref->{dport}",enabled=>"$ispref->{enabled}",enc=>"$ispref->{enc}",gateway=>"$ispref->{gateway}",iid=>"$ispref->{iid}",ipcom=>"1",ispname=>"$ispref->{ispname}",ispnumber=>"$ispref->{ispnumber}",isptype=>"$ispref->{isptype}",local=>"$ispref->{local}",mpv_nat=>"$ispref->{mpv_nat}",mpv_nat_ip=>"$ispref->{mpv_nat_ip}",mss=>"$ispref->{mss}",mss_value=>"$ispref->{mss_value}",mtu=>"$ispref->{mtu}",mtu_value=>"$ispref->{mtu_value}",nic=>"$ispref->{nic}",pkchk=>"$ispref->{pkchk}",poolBuff=>"$ispref->{poolBuff}",poolComp=>"$ispref->{poolBuff}",poolDownUp=>"$ispref->{poolDownUp}",poolEnCmp=>"$ispref->{poolEnCmp}",poolEnc=>"$ispref->{poolEnc}",poolIp=>"$ispref->{poolIp}",poolMss=>"$ispref->{poolMss}",poolMtu=>"$ispref->{poolMtu}",poolPkChk=>"$ispref->{poolPkChk}",poolTxqueue=>"$ispref->{poolTxqueue}",poolnum=>"$ispref->{poolnum}",port=>"$ispref->{port}",remote=>"$ispref->{remote}",remotename=>"$ispref->{remotename}",state=>"$ispref->{state}",systemip=>"$ispref->{systemip}",target=>"$ispref->{target}",tmvbuf=>"$ispref->{tmvbuf}",traversal_port=>"$ispref->{traversal_port}",tunnel_role=>"$ispref->{tunnel_role}",txqueue=>"$ispref->{txqueue}",upload=>"$ispref->{upload}",tmp=>"1");
                            }
               		}
                    }
                }
            }
        }
    }
    elsif ( $action{action}=~m/^GETSRCTABLE$/ )
    {
        my @tablelist;
        my $addresslist;
        
        my $classes=$iniroute->{nat}->[0]->{class};
        push(@tablelist, '255');
        
        if ( $action{source} eq 'system' ) { $action{source} = '0.0.0.0/0'; }
        #if ( $action{destination} eq '' ) { $action{destiantion} = 'system'; }
        
        if ( grep(/^host-/, $action{source}) )
        {
            my $tmpsource = $action{source};
            $tmpsource =~ s/host-//g;
            $addresslist = maintainHost( action=>'GETADDRESSLIST', hostname=>$tmpsource);
            
        }
        else
        {
            $addresslist = $action{source};
        }
        
        
        foreach my $class ( @$classes )
        {
            #if ( $class->{destination} eq $action{destination} && 
            #   ( $class->{source} eq $action{source} || host_subnet_check($class->{source}, $addresslist) ) ) 
            if ( $class->{source} eq $action{source} || host_subnet_check($addresslist, $class->{source}) )  
            {
                if ( !grep(/^$class->{table}$/, @tablelist) )
                {
                    push(@tablelist, $class->{table});
                }
                
                if( $class->{table} < 100 )
                {
                    my @temptables=maintainRtable( action=>'GETPOOLTABLES', focused_rtable=>$class->{table});
                    foreach my $item ( @temptables )
                    {
                        if ( !grep(/^$item$/, @tablelist) )
                        {
                            push(@tablelist, $item);
                        }
                    }
                }
            }
        }
        #push(@tablelist, '255');
        @tablelist = sort { int($a) <=> int($b) } @tablelist;
        return @tablelist;
    }
    #ex:( action=>'WHENFWMARKUPDATED', viewpoint=>'' ) 
    elsif ( $action{action}=~m/^WHENFWMARKUPDATED$/ ) 
    {
        if ( $action{viewpoint} eq "lvslocalhost" ) { $action{viewpoint}='lvs'; }

        my @class_array_after_del;
        my $classes=$iniroute->{$action{viewpoint}}->[0]->{class};
        my $markarray=$fwmark->{$action{viewpoint}}->[0]->{mark};

        my %markhash;
        
        foreach my $mark ( @$markarray )
        {
            $markhash{$mark->{source}.'**'}=1;
            $markhash{$mark->{source}.'*d'}=1;
            $markhash{$mark->{source}.'*s'}=1;

            
            if ( $action{viewpoint} ne "lvs" ) 
            {
                $markhash{$mark->{source}.'others'.'d'}=1;
                $markhash{$mark->{source}.'others'.'s'}=1;
            }
            
            #$markhash{$mark->{source}.$mark->{service}.$mark->{direction}}=1;
            #add source_type
            $markhash{$mark->{source}.$mark->{service}.$mark->{direction}.$mark->{source_type}}=1;
            #$markhash{$mark->{source}.$mark->{service}.$mark->{direction}.$mark->{source_type}.$mark->{destination}}=1;
        }

        if ( $action{viewpoint} eq "nat" ) 
        { 
            $markhash{'0.0.0.0/0'.'others'.'d'}=1; 
            $markhash{'0.0.0.0/0'.'others'.'s'}=1; 
        }

        foreach my $class ( @$classes ) 
        {
            if( $class->{service} eq 'system' ) { push(@class_array_after_del, $class ); next; }
            my $to_be_deleted=1;
            my $source_type;
            
            # 重要: 對已 Obsolete 的 policy ，仍要保留
            # 重要: 哪些 policy 要保留，由這裡決定
            # 
            # hostobj key translate ( )
            my $sourcekey=$class->{source};
            if ( grep(/^host-/, $class->{source}))
            {
                foreach my $host ( @$hostlist )
                {
                    if ( $sourcekey eq $host->{hostname} ) 
                    {
                        $sourcekey=$host->{hostaddress};
                        $source_type=$host->{hosttype};
                        #if ( $host->{hosttype} eq 'iplist' )
                        if ( $host->{hosttype} eq 'iplist' || $host->{hosttype} eq 'networklist' )
                        {
                            my @iparray=split(/,/, $host->{hostaddress});
                            $sourcekey=$iparray[0];
                        }
                    }
                }
            }
            
	    #hostobj key
            my $inirulekey=$sourcekey.$class->{service}.$class->{direction}.$source_type;
            if ( $markhash{$inirulekey} ) { $to_be_deleted=0; }
            #check destination host object
            if ( grep(/^host-/, $class->{destination}) )
            {
                my $dest = $class->{destination};
                $dest =~ s/host-//g;
                my $address = maintainHost( action=>'GETADDRESSLIST', hostname=>$dest);
                
                if ( $address eq '' ) { $to_be_deleted=1; }
            }
            if ( !$to_be_deleted ) { push( @class_array_after_del, $class ); }
        }
            
        $iniroute->{$action{viewpoint}}->[0]->{class}=\@class_array_after_del;
    }
    elsif ( $action{action}=~m/^JUDGEDIRTYVALUEOFPOLICY$/ ) 
    {
        foreach my $viewpoint ( 'dmz', 'nat', 'lvs' ) 
        {
            my $classes=$iniroute->{$viewpoint}->[0]->{class};
            
            #若只有一筆 "system" 就不管了
            if ( @$classes <= 1 ) { next; }
            
            #======================================================================================================
            # phrase 1. prepare some necessary data structure before looping to use for speeding up valid checking ...
            
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # prepare step 1. get isp id list
            my @ispidlist;
            @ispidlist=maintainBasic( action=>'GETIIDLIST' ); 
            
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # prepare step 2. 
            # ! we will design this data structure to be loaded on demand
            my %isppubip;

            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # prepare step 3.
            my @sourcelist;
            my %source2isp;
            if ( $viewpoint=~m/dmz|nat/ ) 
            { 
                foreach my $class ( @$classes ) { if ($class->{source} ne 'system') { push(@sourcelist, $class->{source}); } }
            }
            %source2isp=batchFindMyISP( @sourcelist );
            
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # prepare step 4.
            my %dmzsrc2dirty;
            %dmzsrc2dirty=maintainDMZ(action=>'GETSUBNET2DIRTY');
            
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # prepare step 5.
            my %POLICY_USABLE_TABLES;
            if ( $viewpoint=~m/nat/ )
            {
                %POLICY_USABLE_TABLES=maintainRtable( action=>"GETPOLICYUSABLETABLEIDS", viewpoint=>"$viewpoint", source2isp=>\%source2isp );
            }
            else
            {
                %POLICY_USABLE_TABLES=maintainRtable( action=>"GETPOLICYUSABLETABLEIDS", viewpoint=>"$viewpoint" );
            }
         
            #+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            # here we start our judgement 
            foreach my $class ( @$classes ) 
            {
                #碰到系統保留的那一筆就跳過去
                if ( $class->{service} eq 'system' ) { next; }

                my $DIRTYSTATUS=0;

                #===========================================================================================================
                # Check Point 1. 檢查 dmz 的 source 是否已經過期了
                if ( $viewpoint eq 'dmz' && $dmzsrc2dirty{$class->{source}} ) 
                {
                    $DIRTYSTATUS=1        
                }

                if ( $DIRTYSTATUS )  { $class->{dirty}=1; next; }

                #=================================================================================================================
                # Check Point 2. Automatically correction for 2 conditions
                # 1. NAT source is of ISP public IP, and direction is set to "s", we should disable NAT, and then deal with it as DMZ
                # 2. DMZ source  and service is a reply one, we should disable NAT 

                if ( $viewpoint=~m/^nat$|^dmz$/ )
                {
                    my $ispid=findMyISP(subnet=>$class->{source}); 
                    if ( $viewpoint=~m/^nat$/ && $class->{direction} eq 's' && $ispid=~m/^\d+/ ) 
                    { 
                        #if this NAT source is within ISP public IP range and service is set to "*:s", we should disable NAT, and deal with it as DMZ 
                        if ( $ispid ) { $class->{isp}=$ispid; }
                        $class->{method}='none';
                        $class->{sip}=[];
                    }
                    elsif ( $viewpoint=~m/^dmz$/ &&  $class->{direction} eq 's') 
                    { 
                        $class->{method}='none';
                        $class->{sip}=[]; 
                    }
                }
                elsif ( $viewpoint=~m/^lvs$/ )
                {
                    $class->{method}='none';
                }


                #=================================================
                # Check Point 3 . 針對有 SIP 的 class，若任一 sip 過期，就設 dirty  
                my @ispidlist=maintainBasic( action=>'GETIIDLIST' );
                my $siplist=$class->{sip};
                foreach my $sip ( @$siplist ) 
                { 
                    my $ispexist=(grep(/^$sip->{isp}$/, @ispidlist )) ? 1 : 0;
                    if ( !$ispexist ) { $DIRTYSTATUS=1; last;}
                    
                    my @natip=split(/,/, $sip->{ip});
                    foreach my $ip ( @natip )
                    {
                        # %isppubip is a data structure designed to be loaded on demand
                        my $nownatips;
                        if ( !exists($isppubip{$sip->{isp}}) )
                        {
                            my @pubips=maintainIPBank(action=>'READPUBLICIP', isp=>$sip->{isp});
                            $isppubip{$sip->{isp}}=\@pubips;
                        }
                        
                        $nownatips=$isppubip{$sip->{isp}};
                        my $ipobs=(!grep(/^$ip$/, @$nownatips)) ? 1 : 0;
                        if ( $ipobs ) { $DIRTYSTATUS=1; last;}
                    }

                    if ( $DIRTYSTATUS ) { last; }
                }

                if ( $DIRTYSTATUS )  { $class->{dirty}=1; next; }
                
                #==================================================
                # Check Point 4. 檢查原本走的 Routing Table 是否不能再走了，不能走就設 dirty
                my $rulekey=$class->{source}.':'.$class->{service}.':'.$class->{direction}.':'.$class->{destination}.':'.$class->{method}.':'.$class->{table};
                my $usable_table_list=$POLICY_USABLE_TABLES{$rulekey};

                my $table_obs=( !grep(/^$class->{table}$/, @$usable_table_list) ) ? 1 : 0;

                if ( $table_obs ) { $DIRTYSTATUS=1; }
                
                $class->{dirty}=$DIRTYSTATUS;
            }
        }
    }
    #ex:( action=>'DELRULES', rule=>'array 的 reference') 
    elsif ( $action{action}=~m/^DELSUBNETRULES$/ ) 
    {
        my $subnet=$action{source};
        my @class_array_after_del;
        my $classes=$iniroute->{nat}->[0]->{class};
      
        foreach my $class ( @$classes ) 
        {
            if ( !grep(/^$class->{source}/, @$subnet) )
            { 
                push( @class_array_after_del, $class ); 
            }
        }
        $iniroute->{nat}->[0]->{class}=\@class_array_after_del;
    }
    elsif ( $action{action}=~m/^DELRULES$/ ) 
    {
        my $delrulelist=$action{rule};
        my $viewpoint=$action{viewpoint};
        my @class_array_after_del;
        my $classes=$iniroute->{$viewpoint}->[0]->{class};
        foreach my $class ( @$classes ) 
        {
            my $to_be_deleted=0;
            foreach my $delrule ( @$delrulelist )
            {
                if( $class->{source}.$class->{service}.':'.$class->{direction}.$class->{destination}.$class->{schedule}  ne $delrule) { next; }
                LogUserAction( action=>'DELPROUTE', source=>$class->{source}, service=>$class->{service}, destination=>$class->{destination}, schedule=>$class->{schedule}, table=>$class->{table}, type=>$viewpoint, direction=>$class->{direction});
		$to_be_deleted=1;
		last;
	    }
	    if ( !$to_be_deleted ) { push( @class_array_after_del, $class ); }
        }
    
        $iniroute->{$viewpoint}->[0]->{class}=\@class_array_after_del;
    }
    elsif ( $action{action}=~m/^DELTMVRULES$/ )
    {
        my $delrulelist=$action{rule};
        my $viewpoint=$action{viewpoint};
        my @class_array_after_del;
        my $classes=$iniroute->{$viewpoint}->[0]->{class};
        foreach my $class ( @$classes )
        {
            my $to_be_deleted=0;
            foreach my $delrule ( @$delrulelist )
            {
                if( $class->{source}.$class->{service}.':'.$class->{direction}.$class->{destination}.$class->{schedule}  ne $delrule) { next; }
                LogUserAction( action=>'DELPROUTE', source=>$class->{source}, service=>$class->{service}, destination=>$class->{destination}, schedule=>$class->{schedule}, table=>$class->{table}, type=>$viewpoint, direction=>$class->{direction});
                $to_be_deleted=1;
                last;
            }
            if ( !$to_be_deleted ) { push( @class_array_after_del, $class ); }
         }       
         $iniroute->{$viewpoint}->[0]->{class}=\@class_array_after_del;
    } #ex:( action=>'DELRULEOFDESTINATION' ) 
    elsif ( $action{action}=~m/^DELRULEOFDESTINATION$/ ) 
    {
        my @destarray=maintainOverview( action=>'GETDESTINATION' );
        
        foreach my $viewpoint ( 'dmz', 'nat', 'lvs' ) 
        {
            my @class_array_after_del;
            my $classes=$iniroute->{$viewpoint}->[0]->{class};
              
            foreach my $class ( @$classes ) 
            {
                  
                if ( $class->{service} eq 'system' ) { push( @class_array_after_del, $class ); next;}
                if ( $class->{destination} eq 'system' ) { push( @class_array_after_del, $class ); next;}
                  
                my $to_be_deleted=1;
                  
                foreach my $dest ( @destarray ) 
                { 
                    if ( $class->{destination} ne $dest ) { next; }
                    $to_be_deleted=0; 
                    last; 
                }
                                    
                if ( !$to_be_deleted ) { push( @class_array_after_del, $class ); }
            }
                
            $iniroute->{$viewpoint}->[0]->{class}=\@class_array_after_del;
        }
    }
    #ex:( action=>'DELRULEOFSERVICE', viewpoint=>'', key=>'source.service.direction') 
    elsif ( $action{action}=~m/^DELRULEOFSERVICE$/ ) 
    {
        my $classes=$iniroute->{$action{viewpoint}}->[0]->{class};
        
        my @class_array_after_del;
        
        foreach my $class ( @$classes ) 
        {
            if ( $class->{source}.$class->{service}.$class->{direction} ne $action{key} ) 
            { 
                  push ( @class_array_after_del, $class );  
            }
        }
            
        # write \@class_array_after_del back into 'iniroute' 
        $iniroute->{$action{viewpoint}}->[0]->{class}=\@class_array_after_del;
            
        #會產生 dep issue
    }
    elsif ( $action{action}=~m/^ADD$|^UPDATE$/ ) 
    {
        $action{advance} = ( $action{destination} eq 'system' ) ? ( '0' ) : ( '1' );
        my ( $service, $direction ); 
        my $classes=$iniroute->{$action{viewpoint}}->[0]->{class};
        #my $classes=$iniroute->{$action{viewpoint}}->{class};
        
        # 以下將介面上蒐集到的時間區段轉換成 XML 中要儲存的時間區段格式
        #luke mark 20100819
        #my @timesegments=timeseqarray2segarray( $action{time} );
        #my @timesegments=timeseqarray2segarray( @allday );
        

        # Check if every MUST field is available, if anyone fails, just return doing nothing
        
        # 1.********************************************************************************
        if ( !$action{source} ) 
        {
            $gMSGPROMPT.=qq ( Select a Source first\\n );
            return; 
        }
        
        # 2.********************************************************************************
        if ( $action{service} ) 
        {
            ( $service, $direction )=split( /:/, $action{service} ) ;
            #service direction always is 'd'
            if ( !$direction ) { $direction=( $action{viewpoint} eq 'lvs' ) ? ( 's' ) : ( 'd' ); }
        }    
        else 
        {
            $gMSGPROMPT.=qq ( Select a Service first\\n );
            return; 
        }
        
        if ( $action{enables} ne '1' && $action{enables} ne '2' )
        {
            $action{enables} = '0';
        }
        
        # 3.********************************************************************************
        #Brian Mark it for fqdn
        #if ( $action{advance} && !isValidIP($action{destination}) && !get_subnet($action{destination}) ) 
        #{ 
        #    $gMSGPROMPT.=qq ( In Advacne Mode, a Destination is a MUST \\n);
        #    return;
        #} 
        
#20101228 
=cut
        # 4.****** judge if it is in advanced mode *****************************************
        if ( !$action{advance} ) 
        { 
              $action{advance}=0;

              $action{destination}='system'; 
        }  
        else 
        { 
              $action{advance}=1; 
        }
=cut
        
        # 5.********************************************************************************
        if ( !$action{table} ) 
        { 
            $gMSGPROMPT.=qq ( Routing Table is necessary\\n);
            return;
        }    
     
        #****** 當沒有傳回 $action{isp} 的值時 *********************************************
        if ( !$action{isp} ) 
        {
             if ( $action{viewpoint} eq 'dmz' ) { return; }
             else {  $action{isp}='system'; } 
        }   

        #============================================================================================================
        # Check if new Policy exists already
        my $target_exist=0; 
        my $target;

        #===== search ( source x service x direction x destination x table ) in iniroute =========================
        if ( $action{viewpoint} eq 'app' )
        {
            $action{focusedrule}=~s/:d//;
            $action{focusedrule}=~s/:s//;
        }
        #my $ruleContentToAddOrUpdate=$action{source}.$action{service}.$action{destination};    
        my $sourcekey = $action{source};
        $sourcekey =~ s/host-//g;
        if (grep(/\./,$sourcekey))
        {
            $sourcekey = ( get_subnet($sourcekey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$sourcekey) ) : $sourcekey; 
            $sourcekey =~ /\d+.\d+.\d+.\d+\/(\d+)/;
        }
        if (grep(/\:/,$sourcekey))
        {
            $sourcekey = ( get_subnet_v6($sourcekey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$sourcekey) ) : $sourcekey;
            #$sourcekey =~ /\d+.\d+.\d+.\d+\/(\d+)/;    
        }
        my $mask = $1;
        #runCommand(command=>'echo', params=>"$mask >>/tmp/mask");
        if ( $mask ne '' && $action{qos} ne '' && $action{qos} ne 'None' && $mask < 24 )
        {
            my $qosref=XMLread($gPATH.'qos.xml');
            my $qoslist=$qosref->{qos};
            foreach my $qos ( @$qoslist )
            {
                if ( $action{qos} eq $qos->{qosname} )
                {
                    if( $qos->{type} eq 'individual' )
                    {
                        $gMSGPROMPT.=qq(Individual QoS Object Can't Apply Source Networkmask less than 24); 
                        return;
                    }
                    last;
                }
            }
        }
        
        my $destkey = $action{destination};
        $destkey =~ s/host-//g;
        $destkey = ( $action{destination} ne 'system' && get_subnet($destkey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$destkey) ) : $destkey; 
        
        my $ruleContentToAddOrUpdate=$sourcekey.$action{service}.$destkey.$action{schedule};    

        foreach my $item ( @$classes ) 
        { 
            my $rulekey;
            if ( $item->{service} eq 'system' ) { next; }
            my $direction=( $action{viewpoint} eq 'app' ) ? '' : ':'.$item->{direction};
            #20111117 Brian Fix policy can't be update
            #$rulekey=$item->{source}.$item->{service}.':'.$item->{direction}.$item->{destination}.$item->{schedule};
            $rulekey=$item->{source}.$item->{service}.$direction.$item->{destination}.$item->{schedule};

            #$rulekey=$item->{source}.$item->{service}.':'.$item->{direction}.$item->{destination};
            my $sourcekey = $item->{source};
            $sourcekey =~ s/host-//g;
            $sourcekey = ( get_subnet($sourcekey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$sourcekey) ) : $sourcekey; 
            my $destkey = $item->{destination};
            $destkey =~ s/host-//g;
            $destkey = ( $destkey ne 'system' && get_subnet($destkey) eq '' ) ? ( maintainHost( action=>'GETADDRESSLIST', hostname=>$destkey) ) : $destkey; 
            #$iprulekey=$sourcekey.$item->{service}.$direction.$item->{destination}.$item->{schedule};
            $iprulekey=$sourcekey.$item->{service}.$direction.$destkey.$item->{schedule};
            
            if ( $rulekey eq $action{focusedrule} ) { $target=$item; }
            #if ( $rulekey eq $ruleContentToAddOrUpdate ) { $target=$item; }

            #if ( $rulekey eq $ruleContentToAddOrUpdate ) { $target_exist=1; last; } 
            if ( $iprulekey eq $ruleContentToAddOrUpdate ) { $target_exist=1; last; } 
            #runCommand(command=>'echo', params=>"$iprulekey >>/tmp/aaa");
        }

        #============================================================================================================
        # if new Policy exists when ADDing rules, prompt message to user
        $ruleContentToAddOrUpdate=$action{source}.$action{service}.$action{destination}.$action{schedule};    
        if ( $action{action} eq 'ADD' && $target_exist && $action{enables} ne '1') {   $gMSGPROMPT.=qq(Policy Already Exists); return; }
        if ( $action{action} eq 'UPDATE' && $target_exist &&  $ruleContentToAddOrUpdate ne $action{focusedrule} && $action{enables} ne '1') { $gMSGPROMPT.=qq(Policy Already Exists); return; }
    
        my %newclass;
        #********************** if ViewPoint is DMZ || LVS
        if ( $action{viewpoint}=~m/^lvs$/ ) 
        {
            if ( !$action{table} ) { return; }

            #my %new_LVS_class=( 
            %newclass = (
                    source      =>  $action{source}, 
                    service     =>  $service, 
                    direction   =>  $direction, 
                    destination =>  $action{destination}, 
                    table       =>  $action{table}, 
                    #time        =>  \@timesegments,
                    priority    =>  $action{priority}, 
                    method      =>  'system', 
                    advance     =>  $action{advance}, 
                    isp         =>  $action{isp},
                    schedule    =>  $action{schedule},
                    enables     =>  $action{enables},
                    #luke add qos
                    qos         =>  $action{qos}
            ); 
         
            if ( $action{action} eq "UPDATE" ) 
            {
                #%$target=%new_LVS_class;
                %$target=%newclass;
            }
            elsif ( $action{action} eq "ADD" ) 
            {    
                #push( @$classes, \%new_LVS_class );
                push( @$classes, \%newclass );
            }
        }
        elsif ( $action{viewpoint}=~m/^nat$|^dmz$|^app$/ ) 
        {
            #Check if every MUST field is available, if anyone fails, just return doing nothing
            if ( !$action{table} || !$action{method} ) { return; }

            # in xml we save both manual_ls and ls as ls method
            $action{method}=~s/manual_ls/ls/g; 
            
            
            #%newDMZNATclass=( 
            %newclass=( 
                        source      =>  $action{source}, 
                        service     =>  $service, 
                        direction   =>  $direction, 
                        destination =>  $action{destination}, 
                        isp         =>  $action{isp}, 
                        advance     =>  $action{advance},     
                        method      =>  $action{method}, 
                        sip         =>  $action{sip}, 
                        #time        =>  \@timesegments,
                        table       =>  $action{table}, 
                        priority    =>  $action{priority}, 
                        #luke add schedule
                        schedule    =>  $action{schedule},
                        enables     =>  $action{enables},
                        #luke add qos
                        qos         =>  $action{qos}
            ); 
#            if ($action{viewpoint}=~m/^nat$/ && $action{enables} ne '1' &&  $action{enables} ne '2' && $direction ne 's')
#            {
#                $action{enables} = '2';
#            	%newclasss=(
#            		source      =>  $action{source},
#            		service     =>  $service,
#            		direction   =>  's',
#            		destination =>  $action{destination},
#            		isp         =>  $action{isp},
#            		advance     =>  $action{advance},
#            		method      =>  $action{method},
#            		sip         =>  $action{sip},
#            		table       =>  '100',
#            		priority    =>  $action{priority},
#            		schedule    =>  $action{schedule},
#            		enables     =>  $action{enables},
#            		qos         =>  $action{qos}
#            	);
#            }
            #According to the Spec. every sip set of any nat class must contain a 'system' element *********  
            if ( $action{action} eq "UPDATE" ) 
            {
                    #%$target=%newDMZNATclass;
                    %$target=%newclass;
                    LogUserAction( action=>'UPDATEPROUTE', source=>$action{source}, service=>$service, destination=>$action{destination}, schedule=>$action{schedule}, table=>$action{table}, type=>$action{method}, direction=>$direction);
            }
            elsif ( $action{action} eq "ADD" ) 
            {    
                    #push( @$classes, \%newDMZNATclass );
                    push( @$classes, \%newclass );
#                    if ( $action{enables} eq '2' && $direction ne 's' && $action{viewpoint}=~m/^nat$/){push( @$classes, \%newclasss );}
                    LogUserAction( action=>'ADDPROUTE', source=>$action{source}, service=>$service, destination=>$action{destination}, schedule=>$action{schedule}, table=>$action{table}, type=>$action{method}, direction=>$direction);
            }
            
        }
        #add new policy will re-generate fwmark.xml 
        #runCommand(command=>'echo', params=>"$service >>/tmp/kkk");
        if ( ($action{viewpoint} eq 'nat' && $service ne 'others' ) || $action{viewpoint} eq 'lvs' || $action{viewpoint} eq 'app' )
        #if ( ($action{viewpoint} eq 'nat' ) || $action{viewpoint} eq 'lvs' || $action{viewpoint} eq 'app' )
        {
            $newclass{type} = $action{viewpoint};
    	    my $fwviewpoint=( $action{viewpoint} eq 'app') ? ( 'nat' ) : ( $action{viewpoint} );
            # to generate fwmark for policy with service
            XMLwrite($iniroute, $gPATH."iniroute.xml");
            #maintainFwmark(type=>$fwviewpoint, action=>'update');
            maintainFwmark( %newclass );
        }
    }      
    #(viewpoint=>'',source=>'',service=>'', advance=>'0', destination=>'system', method=>'', sip=>'', time=>'', table=>'', priority=>'')
    elsif ( $action{action}=~m/^SMARTADD$/ ) 
    {
        my $classes=$iniroute->{$action{viewpoint}}->[0]->{class};
        
        # 1.****** 當沒有傳回 $action{isp} 的值時 *********************************************
        if ( !$action{isp} ) 
        {
             if ( $action{viewpoint} eq 'dmz' ) { return; }
             else {  $action{isp}='system'; } 
        }   
        

        #============================================================================================================
        # create a hash of rules for all the policies 
        my %rule_key_hash;
        foreach my $item ( @$classes) 
        { 
            my $rulekey=$item->{source}.$item->{service}.':'.$item->{direction}.$item->{destination};
            $rule_key_hash{$rulekey}=1;
        }

        #============================================================================================================
        # Check if new Policy existenct for NAT and DMZ 
        if ( $action{viewpoint}=~m/^nat$|^dmz$/ ) 
        {
            #===== search ( source x service x direction x destination ) in iniroute =========================
            my $ruleContentToAddOrUpdate=$action{source}.'others:d'.'system';   
 
            # if rule has already existed, just return without doing smart-adding
            if ( exists($rule_key_hash{$ruleContentToAddOrUpdate})  ) { return; } 
            if ( $action{source} =~ m/\d{1,3}\./){$bb="$gBALANCE"; $aa="ls";}
            else 
            {
                $aa="none";
                $bb=maintainBasic(action=>'GETIIDBYSUBNET', subnet=>$action{source});
                if($bb != 30 && $bb != 255 && $action{isp} ne 'system'){$bb="10".$action{isp};}
                else{$bb="$gBALANCE";}
            }
=cut
            my %newDMZNATclass=( 
                        source      =>  $action{source}, 
                        isp         =>  $action{isp}, 
                        service     =>  'others', 
                        direction   =>  'd', 
                        advance     =>  '0',     
                        destination =>  'system', 
                        method      =>  'ls', 
                        sip         =>  [], 
                        time        =>  ['0:1439'],
                        table       =>  $gBALANCE, 
                        priority    =>  1 
            ); 
=cut
            my %newDMZNATclass=( 
                        source      =>  $action{source}, 
                        service     =>  'others', 
                        direction   =>  'd', 
                        destination =>  'system', 
                        isp         =>  $action{isp}, 
                        advance     =>  '0',     
                        method      =>  $aa, 
                        sip         =>  [], 
                        table       =>  $bb,
                        priority    =>  1, 
                        #luke add schedule
                        schedule    =>  'All Week',
                        #luke add qos
                        qos         => 'None' 
            ); 
            
            push( @$classes, \%newDMZNATclass );
        }
        elsif ( $action{viewpoint}=~m/^lvs$/ ) 
        {
            my $defaultPool=$gALLPATH;
            my $rservers=$action{rservers};
            my $services=$action{service};
            
            foreach my $rserver ( @$rservers )
            {
                if ( $rserver=~m/system/ ) { next; }
                
                my $source=( $rserver=~m/localhost/ ) ? ('localhost') : ($rserver.'/32');
                foreach my $service ( @$services )
                {
                    #maintain policy rrg
            	    #my $defaultPool=( $service eq "maintain" ) ? ($gRRG) : ($gALLPATH);
            	    
                    #===== search ( source x service x direction x destination ) in iniroute =========================
                    my $ruleContentToAddOrUpdate=$source.$service.':s'.'system';   

                    if ( exists($rule_key_hash{$ruleContentToAddOrUpdate})  ) { next; } 
=cut
                    my %new_LVS_class=( 
                            source      =>  $source, 
                            isp         =>  $action{isp},
                            service     =>  $service, 
                            direction   =>  's', 
                            advance     =>  '0', 
                            destination =>  'system', 
                            method      =>  'system', 
                            time        =>  ['0:1439'],
                            table       =>  $defaultPool, 
                            priority    =>  1 
                    ); 
=cut
                    my %new_LVS_class=( 
                        source      =>  $source, 
                        service     =>  $service, 
                        direction   =>  's', 
                        destination =>  'system', 
                        isp         =>  $action{isp}, 
                        advance     =>  '0',     
                        method      =>  'system', 
                        table       =>  $defaultPool,
                        priority    =>  1, 
                        #luke add schedule
                        schedule    =>  'All Week',
                        #luke add qos
                        qos         => 'None' 
                    ); 

                    push( @$classes, \%new_LVS_class );
                }
            }
        }
    }      
    elsif ( $action{action} eq "REPORT" )
    {
        print qq (<fieldset><legend><font class="subtitle">Policy Routing Configuration</font></legend>);
        
        foreach my $view ('nat', 'dmz', 'lvs')
        {
            my $classes=$iniroute->{$view}->[0]->{class};
            print qq (<div class="reportdiv">);
            print qq ( | $view | <br>);
            foreach my $class ( @$classes )
            {
                if ( $class->{service} eq 'system' ) { next; }
                foreach my $key ( keys %$class ) { if ( $key=~m/time|sip/ ) { next; } print qq ( [ $key:$class->{$key} ] );  } 
                print qq (<br>);

                my $timeseg=$class->{time};
                foreach my $time ( @$timeseg ) { print qq ( [ $time ] ); }
                print qq (<br>);

                my $sip=$class->{sip};
                foreach my $ip ( @$sip ) { print qq ( [ $ip ] ); }
                print qq (<br>);
            }

            print qq (<hr size="1">);
        }
        print qq (</div>);
        print qq (</fieldset>);
    }
    

    #======== Update iniroute.xml =============================
    XMLwrite($iniroute, $gPATH."iniroute.xml");
}
#maintainIniroute


################################## Method for both Policy Routing and Policy TC ###################################################### 

#===================================================================================================
#maintainProute(%action)
sub maintainProute 
{
    my (%action)=@_;

    if ( !$action{action} ) { return; }
    
    my $proute=XMLread($gPATH."proute.xml");

    if ( $action{action}=~m/^UPDATEQBROUTE$/ ) 
    {
        my @isplist=maintainBasic(action=>'GETGOODIIDLIST');
        my %ispsubnethash=maintainBasic(action=>'GETISPSUBNETHASH');
        my %dmzstatus=maintainZone(action=>'GETALLDMZSTATUS');
        my @allQBRules;

        foreach my $isp ( @isplist )
        {
            my $serviceName='ISP'.$isp;
            my $fwmarkValue='0x'.dec2hex(1000+$isp);
            my $ispTable=100+$isp;
            my %newClass=(fwmark=>$fwmarkValue, service=>$serviceName, route_table=>$ispTable, time=>['0:1439'], natmethod=>'ls', priority=>"4500");
            push( @allQBRules, \%newClass);

            my @systemAndVIP=maintainIPBank(action=>'READSYSTEMANDPUBLICIP', isp=>$isp);
            # nancy 041110
            my @forbiddenip=maintainIPBank(from=>"isp${isp}dmz", action=>'read');
            my @suitableIP;
            get_union_set(\@suitableIP, \@systemAndVIP);
            get_diff_set(\@suitableIP, \@forbiddenip);
	    # foreach my $ip ( @suitableIP) {$gMSGPROMPT.=qq ( suitable $ip \\n); }
            # foreach my $ip ( @systemAndVIP )
            foreach my $ip ( @suitableIP )
            {
                
                my %newClass=( source=>$ip.'/32', route_table=>$ispTable, time=>['0:1439'], priority=>"5000");
                push( @allQBRules, \%newClass );
            }


            #if ( $dmzstatus{$isp} )
            if ( $dmzstatus{$isp} && $ispsubnethash{$isp} ) #20100622 Don't add route to GRE Bridge
            {
                my %newClass=( source=>$ispsubnethash{$isp}, route_table=>$ispTable, time=>['0:1439'], priority=>"30000");
                push( @allQBRules, \%newClass );
            }
        }

        my @internalZones=maintainZone(action=>'GETNATZONES');
        foreach my $izone ( @internalZones )
        {   
            my $ispid=findMyISP(subnet=>$izone);
            my $ispTable=100+$ispid;

            if ( $ispid )  # ??  or this if ( $ispid && $dmzstatus{$ispid} )
            {
                my %newClass=( source=>$izone, route_table=>$ispTable, time=>['0:1439'], priority=>"31000");
                push( @allQBRules, \%newClass );
            }
        }
        
        $proute->{qb}->[0]->{class}=\@allQBRules;
    }
    elsif ( $action{action}=~m/^ADDQBROUTE$/ ) 
    {
        my $isp = $action{isp};
        my $ip = $action{ip};
        #my %ispsubnethash=maintainBasic(action=>'GETISPSUBNETHASH');
        #my %dmzstatus=maintainZone(action=>'GETALLDMZSTATUS');
        #my @allQBRules;
        my $num = 0;
        my $allQBRules = $proute->{qb}->[0]->{class};
        foreach my $qb ( @$allQBRules ) { $num++; }
        
        if ( $action{type} eq 'ISP' )
        {
            my $exist = 0;
            my $table = 100 + $isp;
            foreach my $qbrule ( @$allQBRules )
            {
                if ( $qbrule->{priority} eq '5000' && $qbrule->{route_table} eq $table ) 
                { 
                    $exist = 1;
                    $qbrule->{source} = $ip;
                    last;
                }
            }
            if ( !$exist )
            {
                my @tmparray;
                my $serviceName='ISP'.$isp;
                my $fwmarkValue='0x'.dec2hex(1000+$isp);
                my $ispTable=100+$isp;
                my %newClass=(fwmark=>$fwmarkValue, service=>$serviceName, route_table=>$ispTable, time=>['0:1439'], natmethod=>'ls', priority=>"4500");
                if ( !$num )
                {
                    push( @tmparray, \%newClass);
                }
                else
                {
                    push( @$allQBRules, \%newClass);
                }
                my %newClass=( source=>$ip.'/32', route_table=>$ispTable, time=>['0:1439'], priority=>"5000");
                if ( !$num )
                {
                    push( @tmparray, \%newClass);
                }
                else
                {
                    push( @$allQBRules, \%newClass);
                }
                if ( !$num ) { $proute->{qb}->[0]->{class} = \@tmparray; }
            }
        }
        elsif ( $action{type} eq 'PUBLICIP' )
        {
            my $systemip = maintainBasic(action=>'GTEIPBYID', iid=>$isp);
            foreach my $item ( @$ip )
            {
                if ( $item ne $systemip )
                {
                    my $ispTable=100+$isp;
                    my %newClass=( source=>$item.'/32', route_table=>$ispTable, time=>['0:1439'], priority=>"5000");
                    push( @$allQBRules, \%newClass);
                }
            }
        }
    }
    elsif ( $action{action} =~ m/^DELQBROUTE$/ )
    {
        my $qbclass = $proute->{qb}->[0]->{class};
        my $isp = $action{isp};
        my $table = 100 + $isp;
        my @tmparray;
        
        foreach my $qb ( @$qbclass )
        {
            if ( $qb->{route_table} eq $table ) { next; }
            push(@tmparray, $qb);
        }
        $proute->{qb}->[0]->{class} = \@tmparray;
    }
    elsif ( $action{action} =~ m/^DELQBROUTEIP$/ )
    {
        my $qbclass = $proute->{qb}->[0]->{class};
        my $iip = $action{iip}.'/32';
        my $isp = $action{isp};
        my $table = 100 + $isp;
        my @tmparray;
        foreach my $qb ( @$qbclass )
        {
            if ( $qb->{route_table} eq $table && $qb->{source} eq $iip && $qb->{priority} eq "5000") { next; }
            push(@tmparray, $qb);
        }
        $proute->{qb}->[0]->{class} = \@tmparray;
    }
    elsif ( $action{action} =~ m/^ADDMPV$/)
    {
        my $qbclass = $proute->{qb}->[0]->{class};
        my $isp = $action{isp};
        my $ip = $action{ip};
        
        my $serviceName='ISP'.$isp;
        my $fwmarkValue='0x'.dec2hex(1000+$isp);
        my $ispTable=100+$isp;
        my %newClass=(fwmark=>$fwmarkValue, service=>$serviceName, route_table=>$ispTable, time=>['0:1439'], natmethod=>'ls', priority=>"4500");
        #push( @allQBRules, \%newClass);
        push( @$qbclass, \%newClass);
        my %newClass=( source=>$ip.'/32', route_table=>$ispTable, time=>['0:1439'], priority=>"5000");
        push( @$qbclass, \%newClass);
    }
    elsif ( $action{action} =~ m/^SAVEMPV$/ )
    {
        my $qbclass = $proute->{qb}->[0]->{class};
        my $isp = $action{isp};
        my $ip = $action{ip};
        my $table = 100 + $isp;
        foreach my $qb ( @$qbclass )
        {
            if ( $qb->{priority} ne '5000' ) { next; }
            if ( $qb->{route_table} eq $table )
            {
                $qb->{source} = $ip.'/32';
                last;
            }
        }
    }
    elsif ( $action{action} =~ m/^DELMPV$/ )
    {
        my $qbclass = $proute->{qb}->[0]->{class};
        my $isp = $action{isp};
        my $table = 100 + $isp;
        my @tmparray;
        
        foreach my $qb ( @$qbclass )
        {
            if ( $qb->{route_table} eq $table ) { next; }
            push(@tmparray, $qb);
        }
        $proute->{qb}->[0]->{class} = \@tmparray;
    }
    
    #======== Update proute.xml =============================
    XMLwrite($proute, $gPATH."proute.xml");
}
#maintainProute


#===================================================================================================
sub ini2via 
{
    my $fwmark=XMLread($gPATH."fwmark.xml");
    my $iniroute=XMLread($gPATH."iniroute.xml");
    my $viaroute=XMLread($gPATH."viaroute.xml");
    ############################################################################################
    # 將  subnet x *.*  的 class 展出來
    ############################################################################################
    #foreach my $view ( 'dmz', 'lvs', 'nat' ) 
    #add application 20101124
    foreach my $view ( 'dmz', 'lvs', 'nat', 'app' ) 
    {
        my @via_route_array_of_this_view;
        my $ini=$iniroute->{$view}->[0]->{class};
        my $markarray=$fwmark->{$view}->[0]->{mark};
        
        #先處理 service 不為 * 的
        foreach my $class ( @$ini ) 
        {
            if ( $class->{service} eq '*' ) { next; } 
            
            # ?? need to be confirmed  to forbidden or warn user not to have this policy
            if ( $class->{dirty} ) { next; }

            $class->{subnettype}=$view;
            push( @via_route_array_of_this_view, $class ); 
        }
            
        #再處理 service 為 * 的  
        foreach my $class ( @$ini ) 
        {
            if( $class->{service} ne '*' ) { next;}
    
            # ?? need to be confirmed  to forbidden or warn user not to have this policy
            if ( $class->{dirty} ) { next; }
            
            #========================================================================
            # collect services from fwmark.xml
            my %allservices; 
            foreach my $mark ( @$markarray ) 
            {
                if ( $mark->{dirty} ) {next;}
                if ( $mark->{service}=~m/^system|^others/ ) { next; }
                if ( $mark->{source} ne $class->{source} ) { next; }
                if ( $view=~m/dmz|nat/ && $mark->{direction} ne $class->{direction} && ($class->{direction} ne '*') ) { next; }
   
                $allservices{ $mark->{service}.':'.$mark->{direction} }=1;
            }
        
            foreach my $serviceitem ( keys(%allservices) ) 
            {
                #檢查這筆是否已經存在 @via_route_array_of_this_view 中
                my $target;
                my $target_exist=0;
                foreach my $item ( @via_route_array_of_this_view ) 
                {
                    if ( $item->{source}.$item->{service}.':'.$item->{direction}.$item->{destination} ne $class->{source}.$serviceitem.$class->{destination} ) { next; }
                    $target_exist=1;
                    $target=$item;
                    last;
                }                      
        
                if ( $target_exist)
                {
                    # 比較 priority --> 數字小的表示優先權較高 <-- 
                    if( $target->{priority} > $class->{priority} ) 
                    {
                        $target->{priority}=$class->{priority};
                        $target->{table}=$class->{table};

                        delete( $target->{sip} );
                        delete( $target->{time} );
                        delete( $target->{qos} );

                        if ( $view=~m/^nat$|^dmz$|^app$/ ) 
                        {
                            my $siparrayptr=$class->{sip}; 
                            my @siparray; foreach my $sip ( @$siparrayptr ) { my %newsip=%$sip; push(@siparray, \%newsip); } 
                            $target->{sip}=\@siparray;    
                        }
     
                        my $timearrayptr=$class->{time};
                        my @time=@$timearrayptr;
                        $target->{time}=\@time;

                        my $qosarrayptr=$class->{qos};
                        my @qosarray; foreach my $qos ( @$qosarrayptr ) { my %newqos=%$qos; push(@qosarray, \%newqos); }
                        $target->{qos}=\@qosarray;
                    }                    
                }
                else  #如果不存在，直接push進去，          
                {
                    my ( $service, $direction )=split(/:/, $serviceitem);
                    my %newClass;
                    $class->{service}=$service; 
                    $class->{direction}=$direction;
                    %newClass=%$class;
                    $newClass{subnettype}=$view;

                    delete( $newClass{sip} );
                    delete( $newClass{time} );
                    delete( $newClass{qos} );

                    if ( $view=~m/^nat$|^dmz$|^app$/ ) 
                    {
                        my $siparrayptr=$class->{sip}; 
                        my @siparray; foreach my $sip ( @$siparrayptr ) { my %newsip=%$sip; push(@siparray, \%newsip); } 
                        $newClass{sip}=\@siparray;
                    }

                    my $timearrayptr=$class->{time};
                    my @time=@$timearrayptr;
                    $newClass{time}=\@time;

                    my $qosarrayptr=$class->{qos};
                    my @qosarray; foreach my $qos ( @$qosarrayptr ) { my %newqos=%$qos; push(@qosarray, \%newqos); }
                    $newClass{qos}=\@qosarray;
              
                    push( @via_route_array_of_this_view, \%newClass );   
                }
            }
        }
        
        $viaroute->{$view}->[0]->{class}=\@via_route_array_of_this_view;
    }

    #===========================
    XMLwrite($viaroute, $gPATH."viaroute.xml");
}
#ini2via


#==============================================================================================
sub viaroute_generate_advance_fwmark
{
    maintainFwmark(type=>'from_service_to');
    maintainFwmark(type=>'from_to');
    maintainFwmark(type=>'from');
    maintainFwmark(type=>'to');
    maintainFwmark(type=>'nat');
    maintainFwmark(type=>'lvs');
}
#viaroute_generate_advance_fwmark


#=====================================================================================
sub generate_all_fwmark_value
{
    my $fwmark=XMLread($gPATH."fwmark.xml");
    
    #================================================
    # Fwmark value allocated before Re-fwmarking
    # reserved          => 0-9999
    # from              => 10000-14999
    # from_service_to   => 15000-19999
    # from_to           => 20000-24999
    # dmz               => 25000-29999
    # lvs               => 30000-34999
    # nat               => 40000-44999
    # to                => 45000-49999
    # unused            => 50000-65535
    #================================================

    my $value=$gFWMARKSTARTVALUE;
    foreach my $group ( 'from', 'from_service_to', 'from_to' , 'dmz', 'lvs', 'nat', 'to' )
    {
        my $fwmarkarray=$fwmark->{$group}->[0]->{mark};
        my $markvalue=$value;
        foreach my $mark ( @$fwmarkarray )
        {
            if ( $mark->{service} eq 'system' ) { next; }

            $mark->{value}="0x".dec2hex($markvalue);

            $markvalue+=5;
        }

        $value+=$gFWMARKINTERVAL;
    }
        
    #--------updating fwmark.xml------------------------ 
    XMLwrite($fwmark, $gPATH."fwmark.xml");
}
#generate_all_fwmark_value


#========================================================================================
sub doReFlowMark
{
    #my ( %reFwmarkHash )=@_;
    #add qos
    my ( %reFwmarkHash ) = %{$_[0]};
    my ( %qosHash ) = %{$_[1]};
    
    my $fwmark=XMLread($gPATH."fwmark.xml");
    
    foreach my $group ( 'from', 'from_service_to', 'from_to' , 'dmz', 'lvs', 'nat', 'to')
    {
        my $fwmarkarray=$fwmark->{$group}->[0]->{mark};
        foreach my $mark ( @$fwmarkarray )
        {
            if ( $mark->{service} eq 'system' ) { next; }
            my $newMark=$reFwmarkHash{$mark->{value}};
            $mark->{qos}=$qosHash{$mark->{value}};
            $mark->{value}=( $newMark ) ? ( $newMark ) : ( '' );
        }
    }
        
    #--------updating fwmark.xml------------------------ 
    XMLwrite($fwmark, $gPATH."fwmark.xml");
}
#doReFlowMark

#========================================================================================
sub reFindSafeTable 
{
    my (%action)=@_;
    my $safeTable=$gALLPATH;

    #========================================================================================
    # 1. if $action{subnet} belongs to an ISP, return $gALLPATH + $belongiid  
    my $belongiid=maintainBasic( action=>'GETBELONGIID', subnet=>$action{subnet} ); 

    if ( $belongiid )
    {
        $safeTable=$gALLPATH + $belongiid;
        
        return $safeTable;
    } 
        
    #========================================================================================
    # 2. if $action{subnet} belongs to an Internal ZONE routed via a DMZ gateway of a certain ISP, return $gALLPATH + $dmzisp  
    #  2013-0611 Brian to correct it
    #my $ispid=maintainZone( action=>'GETWANIDOFBELONGNAT',subnet=>$action{subnet} );
    #my $ispid=maintainZone( action=>'GETISPIDOFBELONGNAT',subnet=>$action{subnet} );
    my $ispid="";
    
    if ( $ispid ) 
    {   
        #=========================================================================================
        # 2.1 if $action{subnet} is in well-known private ip range
        my @ipfields=split(/\/|\./, $action{subnet});
        my $isPrivate=0;
        
        if ( $ipfields[0] == 10 ) { $isPrivate=1; }
        elsif ( $ipfields[0] == 172 && ($ipfields[1] >= 16 && $ipfields[1] <= 31) ) { $isPrivate=1; }
        elsif ( $ipfields[0] == 192 && $ipfields[1] == 168 ) { $ispPrivate=1; }

        if ( $isPrivate )
        {
            return $safeTable;
        }
        
        #=========================================================================================
        # 2.2 if $action{subnet} is NOT in well-known private ip range
        if ( $ispid ) 
        { 
            $safeTable=$gALLPATH + $ispid; 
            
            return $safeTable;
        }
    }

    return $safeTable;
}
#reFindSafeTable


#========================================================================================
sub findMyISP 
{
    my (%action)=@_;

    #==========================================================================================
    # 1. if $action{subnet} belongs to an ISP, return $belongiid  
    my $belongiid=maintainBasic( action=>'GETBELONGIID', subnet=>$action{subnet} ); 
    
    if ( $belongiid ) { return $belongiid; } 
     
    #==========================================================================================
    # 2. if $action{subnet} belongs to an Internal ZONE routed via a DMZ gateway of a certain ISP, return $dmzisp  
    #  2013-0611 Brian to correct it
    #my $ispid=maintainZone( action=>'GETWANIDOFBELONGNAT',subnet=>$action{subnet} );
    #my $ispid=maintainZone( action=>'GETISPIDOFBELONGNAT',subnet=>$action{subnet} );
    my $ispid="";
    #  2013-0604 Gary modify because not use
    #my $ispid=0;

    
    if ( $ispid ) 
    {   
        return $ispid;
    }
    else
    {
        return 0;
    }
}
#findMyISP


#========================================================================================
sub batchFindMyISP 
{
    my @sourcelist=@_;

    #========================================================================================
    # define source2isp hash , we will return this back to caller
    my %source2isp;

    #==========================================================================================
    # prepare  for Phase 1
    my %isp2subnet=maintainBasic( action=>'GETISPSUBNETHASH' );

    foreach my $source ( @sourcelist )
    {
        #==========================================================================================
        # step 1. if $source belongs to an ISP, save $belongiid into source2isp hash
        my $belongiid;
        foreach my $isp ( keys %isp2subnet )
        {
            my $result=subnet_belong_check( $source, $isp2subnet{$isp} );
            if ( $result == 1 || $result==3 ) { $belongiid=$isp; last; }
        }

        # if isp has been found, save it into hash source2isp
        if ( $belongiid ) {    $source2isp{$source}=$belongiid; } 
    }
    
    
    #==========================================================================================
    # prepare for Phase 2
    my %nat2isp=maintainZone( action=>'GETNAT2ISP' );
     
    foreach my $source ( @sourcelist )
    {
        # if isp of this source has been determinated in Phase 1, just do next source
        if ( exists( $source2isp{$source} ) ) { next; }

        #==========================================================================================
        # step 1. find isp of the  Internal Zone $source belongs to 
        my $ispid;
        foreach my $natsubnet ( keys %nat2isp )
        {
            my $result=subnet_belong_check( $source, $natsubnet );
            if ( $result == 1 || $result==3 ) 
            { 
                if ( $nat2isp{$natsubnet} )
                {
                    $source2isp{$source}=$nat2isp{$natsubnet}; 
                    last; 
                }
            }
        }
    }

    return %source2isp;
}
#batchFindMyISP


#========================================================================================
sub via2prt 
{
    #@dep
    viaroute_generate_advance_fwmark();  

    #@dep
    generate_all_fwmark_value();

    my $fwmark   = XMLread($gPATH.'fwmark.xml');
    my $viaroute = XMLread($gPATH.'viaroute.xml');
    my $proute   = XMLread($gPATH.'proute.xml');
    my $rtable   = XMLread($gPATH.'rtable.xml');
    my $hostref=XMLread($gPATH.'host.xml');
    my $hostlist=$hostref->{host};
    my $alltables=$rtable->{table};
    my %rtableHash;
    my %fwmarkvalue;
    my %reFwmarkHash;
    my %qosHash;
    
    # We will divide all the packets into 5 type  of containers 
    my ( @to, @subnet, @fwmark, @subadv, @fwadv);
    
    #Establishing the Hash of routing tables
    foreach my $table ( @$alltables ) { $rtableHash{$table->{table_num}}=$table; }
    
    # Establishing the Hash of flow marks
    # take attention !! nat must before 'from_service_to', 'from_to', 'from', 'to' 
    foreach my $group ( 'dmz', 'lvs', 'nat', 'from_service_to', 'from_to', 'from', 'to')
    {
        my $fwmarkarray=$fwmark->{$group}->[0]->{mark};
        foreach my $mark ( @$fwmarkarray )
        {
            if ( $mark->{service} eq 'system' ) { next; }
            #my $markkey=$mark->{source}.$mark->{service}.$mark->{direction}.$mark->{destination};
            #201012224 add schedule
            my $markkey=$mark->{source}.$mark->{service}.$mark->{direction}.$mark->{destination}.$mark->{schedule};
            $fwmarkvalue{$markkey}=$mark->{value};
        }
    }
    
    foreach my $view ( 'dmz', 'nat', 'lvs', 'app') 
    {
        my $viaclassarray=$viaroute->{$view}->[0]->{class};
    
        foreach my $class ( @$viaclassarray ) 
        {
            if ( $class->{service} eq 'system' ) { next; }
            my @src_array;
            my @dest_array;
            my $src_type;
            my $dest_type;
            if ( grep(/^host-/, $class->{source}))
            {
                foreach my $host ( @$hostlist )
                {
                    if ( $host->{hostname} eq $class->{source} )
                    {
                        $src_type = $host->{hosttype};
                        @src_array = split(/,/, $host->{hostaddress}); 
                        last;
                    }
                }
            }
            else
            {
                $src_type = 'normal';
                push(@src_array, $class->{source});
                #$newclass{sourcetype}='normal';
            }
            
            if ( grep(/^host-/, $class->{destination}) )
            {
                foreach my $host ( @$hostlist )
                {
                    if ( $host->{hostname} eq $class->{destination} )
                    {
                        $dest_type = $host->{hosttype};
                        @dest_array = split(/,/, $host->{hostaddress});
                        last;
                    }
                }
            }
            else
            {
                $dest_type = 'normal';
                push(@dest_array, $class->{destination});
            }
            foreach my $src ( @src_array )
            {
                foreach my $dest ( @dest_array )
                {
                    
                    #Prepare new rule class hash variable to collect all the information   
                    my (%newclass);
                    
                    #=================================================
                    # Make decision on what natmethod and sip is, according to $view type
                    if ( $view eq 'lvs' ) 
                    {
                        $newclass{natmethod}="";

                        $newclass{sip}="";
                    }
                    elsif ( $view ne 'lvs' ) 
                    {
                        $newclass{natmethod}=$class->{method};
                        
                        my $sipptr=$class->{sip}; 
                        my @siparray; foreach my $sip ( @$sipptr ) { my %newsip=%$sip; push(@siparray, \%newsip); } 
                        $newclass{sip}=\@siparray; 
                    }
                            
                    $newclass{subnettype}=$view;
=cut
                    if ( grep(/^host-/, $class->{source}))
                    {
                        foreach my $host ( @$hostlist )
                        {
                            if ( $host->{hostname} eq $class->{source} )
                            {
                                $newclass{source}=$host->{hostaddress}; 
                                $newclass{sourcetype}=$host->{hosttype};
                                last;
                            }
                        }
                    }
                    else
                    {
                        $newclass{source}=$class->{source};
                        $newclass{sourcetype}='normal';
                    }
                    
                    if ( grep(/^host-/, $class->{destination}) )
                    {
                        foreach my $host ( @$hostlist )
                        {
                            if ( $host->{hostname} eq $class->{destination} )
                            {
                                $newclass{destination}=$host->{hostaddress};
                                $newclass{destinationtype}=$host->{hosttype};
                                last;
                            }
                        }
                    }
                    else
                    {
                        $newclass{destination}=$class->{destination};
                        $newclass{destinationtype}='normal';
                    }
=cut
                    $newclass{service}=$class->{service};
                    $newclass{direction}=$class->{direction};
                    $newclass{route_table}=$class->{table};
                    
                    my $timearrayptr=$class->{time};
                    my @time=@$timearrayptr; $newclass{time}=\@time;
                    
                    my $qosptr=$class->{qos}; 
                    my @qosarray; foreach my $qos ( @$qosptr ) { my %newqos=%$qos; push(@qosarray, \%newqos); } 
                    $newclass{qos}=\@qosarray; 
                    
                    #my $markkey=$class->{source}.$class->{service}.$class->{direction}.$class->{destination}; 
                    #for host obj
                    #my $markkey=$newclass{source}.$class->{service}.$class->{direction}.$class->{destination}; 
                    #20101224 add schedule
                    #my $markkey=$newclass{source}.$class->{service}.$class->{direction}.$class->{destination}.$class->{schedule}; 
=cut
                    my $srckey = $newclass{source};
                    my $dstkey = $newclass{destination};
                    #if ( $newclass{sourcetype} eq 'iplist' )
                    my @src_array;
                    my @dest_array;
                    if ( $newclass{sourcetype} eq 'iplist' || $newclass{sourcetype} eq 'networklist' )
                    {
                       #my @iparray = split(/,/, $newclass{source}); 
                       #$srckey = $iparray[0];
                       @src_array = split(/,/, $newclass{source});
                    }
                    else
                    {
                        push(@src_array, $newclass{source});
                    }
                    
                    if ( $newclass{destinationtype} eq 'iplist' || $newclass{destinationtype} eq 'networklist' || $newclass{destinationtype} eq 'fqdnlist' )
                    {
                       #my @iparray = split(/,/, $newclass{destination}); 
                       #$dstkey = $iparray[0];
                       @dest_array = split(/,/, $newclass{destination});
                    }
                    else
                    {
                        push(@dest_array, $newclass{destination});
                    }
=cut
                    
                    $newclass{source}=$src;
                    $newclass{deatination}=$dest;
                    #my $markkey=$srckey.$class->{service}.$class->{direction}.$dstkey.$class->{schedule};
                    my $markkey=$src.$class->{service}.$class->{direction}.$dest.$class->{schedule};
                    my $markvalue=$fwmarkvalue{$markkey};
                    
                    # Re Flow Mark Section:  Judge if Re-FlowMark is needed
                    my $refwmarktable=$newclass{route_table};
                    my $refwmarkvalue=$markvalue;
                    

                    #=================================================================================
                    #  making decision for Re-flow mark value ==> very important Procedure

                    $refwmarkvalue=~s/0x//;                         # get rid of the "0x" hex header
                    $refwmarkvalue=hex($refwmarkvalue);             # hex to decimal translation
                    
                    
                    #=================================================================================
                    #0. set table byte
                    $refwmarkvalue |= ($refwmarktable << 16 );                 
                    
                    #1. set Cache refresh bit
                    $refwmarkvalue |= 0x01000000  if ( $rtableHash{$newclass{route_table}}->{aggregate} );                           

                    #2. set FAST Way routing mode 
                    $refwmarkvalue |= 0x02000000  if ( $rtableHash{$newclass{route_table}}->{mode}=~m/FAST/ );  
                    
                    #3. set SAFE route bit
                    $refwmarkvalue |= 0x04000000  if ( $newclass{route_table} eq  $gALLPATH );  
                    
                    #4. if NAT method is set to LS or FAST Way routing mode is selected, set this bit on
                    if ($newclass{route_table} ne $gDROP) 
                    {
                    $refwmarkvalue |= 0x08000000  if ( $newclass{natmethod} eq "ls" || $rtableHash{$newclass{route_table}}->{mode}=~m/FAST/ ); 
                    }
         
                    #5. set RRG route bit
                    $refwmarkvalue |= 0x10000000  if ( $newclass{route_table} eq $gRRG ); 

                    #6. set BSWT, WLC, FRTT route bit
                    #$refwmarkvalue |= 0x20000000  if ( $rtableHash{$newclass{route_table}}->{mode}=~m/^BSWLT$|^WLC$|^BTK$|^FRTT$/ );  
                    #20110411
                    $refwmarkvalue |= 0x20000000  if ( $rtableHash{$newclass{route_table}}->{mode}=~m/^BSWLT$|^WLC$|^BTK$|^FRTT$|^BBL$/ );  
                    
                    #shreFwmarkHash7. 0x40000000 is assigned to inbond QoS

                    #8. 0x80000000 is unused now
                    #=================================================================================

                    $refwmarkvalue='0x'.dec2hex($refwmarkvalue);    #decimal to hex translation
                    
                    #=================================================================================
                    # Reassign New fwmark value  
                    $newclass{fwmark}=$refwmarkvalue;
                    
                    #=================================================================================
                    # Prepare refwmark hash to  call  Re-FlowMark 
                    # In version 2.2.0.xxxx : we have the feature of time-based policy routing 
                    # So, after re-flowmarking , we might have more than one fwmark values concatenated by the character ':', and stored back to fwmark.xml
                
                    if ( !exists($reFwmarkHash{$markvalue}) ) 
                    { 
                        $reFwmarkHash{$markvalue}=$refwmarkvalue; 
                        $qosHash{$markvalue}=$class->{qos};
                        #for iplist
                        #if ( $newclass{sourcetype} eq 'iplist' || $newclass{sourcetype} eq 'networklist' )
                        #{
                            #my @iparray=split(/,/, $newclass{source});
                            #foreach my $ip ( @iparray )
                            #{
                            #    my @dstarray=split(/,/, $newclass{destination});
                            #    foreach my $dst ( @dstarray )
                            #    {
                                    my $key=$src.$class->{service}.$class->{direction}.$dest.$class->{schedule};
                                    my $tempvalue=$fwmarkvalue{$key};
                                    $reFwmarkHash{$tempvalue}=$refwmarkvalue;
                             	    $qosHash{$tempvalue}=$class->{qos};
                            # 	}
                            #}
                        #}
                    }
                    else 
                    {
                        $reFwmarkHash{$markvalue}=~s/$refwmarkvalue:*//;
                        $reFwmarkHash{$markvalue}.=( $reFwmarkHash{$markvalue} ) ? ( ':'.$refwmarkvalue ) : ( $refwmarkvalue ); 
                        $qosHash{$markvalue}=$class->{qos};
                    }
                    #===============================================================================
                    

                    #===============================================================================
                    # re-find SAFE table
                    if ( $newclass{route_table} eq $gALLPATH )
                    {   
                        $newclass{route_table}=reFindSafeTable(subnet=>$newclass{source});
                    }


                    #===============================================================================
                    #  Grouping ...
                    #===============================================================================
                    # 根據 service 及 advance 來決定要讀入 $newclass 中的值
                    #luke new schedule
                    my @allday=("0:1439"); 
                    $newclass{time}=\@allday;
                    $newclass{schedule}=$class->{schedule};
                    
                    
                    if ( $class->{source} eq "0.0.0.0/0" && $class->{advance}==1 ) 
                    {
                        #$newclass{destination}=$class->{destination};
                        $newclass{priority}=5000;
                        push ( @to, \%newclass );
                    }
                    elsif ( $class->{service}  ne "others" && $class->{advance}==1 ) 
                    {
                        #$newclass{destination}=$class->{destination};
                        $newclass{priority}=10000;
                        push ( @fwadv, \%newclass );
                    }
                    elsif ( $class->{service} eq "others" && $class->{advance}==1 ) 
                    {
                        #$newclass{destination}=$class->{destination};
                        $newclass{priority}=15000;
                        #runCommand(command=>'echo', params=>"$newclass{source} >>/tmp/jjj");
                        push ( @subadv, \%newclass );
                    }
                    elsif ( $class->{service}  ne "others" && $class->{advance}==0 ) 
                    {
                        $newclass{destination}="";
                        $newclass{priority}=20000;
                        push ( @fwmark, \%newclass );
                    }
                    elsif ( $class->{service} eq "others" && $class->{advance}==0 ) 
                    {
                        $newclass{destination}="";
                        #runCommand(command=>'echo', params=>"$newclass{source} >>/tmp/kkk");
                        $newclass{priority}=25000;
                        push ( @subnet, \%newclass );
                    }
                }
            }
        }
    }
    
    
    #========================================================================  
    # Save \@to, \@subnet, \@subadv, \@fwmark, \@fwadv into the XML Reference variable $prout 
    $proute->{to}->[0]->{class}=\@to;
    $proute->{sub}->[0]->{class}=\@subnet;
    $proute->{subadv}->[0]->{class}=\@subadv;
    $proute->{fw}->[0]->{class}=\@fwmark;
    $proute->{fwadv}->[0]->{class}=\@fwadv;
    
    #========================================================================
    # Do Re-flow Mark
    doReFlowMark( \%reFwmarkHash , \%qosHash );
    #doReFlowMark( %reFwmarkHash );

    XMLwrite($proute, $gPATH."proute.xml");

    # generat shell script for policy-based traffic control named /usr/local/apache/qb/ptcscript
    #writePtcShellScript();
    #
    write_qosscript();
}
#via2prt
#####################################################
# name: write_qosscript
# purpose: generate qos script
#####################################################
sub write_qosscript()
{
    #runCommand(command=>'/usr/local/apache/qbconf/delall', params=>'');
    my $qosref=XMLread($gPATH.'qos.xml');
    my $qoslist=$qosref->{qos};
    
    my $qoslanref=XMLread($gPATH.'qoslan.xml');
    my $qoslanlist=$qoslanref->{qos};
    
    
    my $natref=XMLread($gPATH.'zonecfg.xml');
    my $natarray=$natref->{nat};
    
    my $iniroute=XMLread($gPATH."iniroute.xml");
    my $classes=$iniroute->{nat}->[0]->{class};
    my $ispref=XMLread($gPATH."basic.xml");
    my $isplist=$ispref->{isp};
    my $fwmark=XMLread($gPATH."fwmark.xml");
    my $rtable=XMLread($gPATH.'rtable.xml');
    my $rtablelist=$rtable->{table};
    my $qossource;
    #my $tmpscript="/tmp/qos.sh";
    my %qossubnet;
    my @qosisp;
    my @alldev;
    
    #======================================================
    # QoS of LAN
    #======================================================
    my $imqnum = 0;
    my %LAN_IMQ;
    my %LAN_classid;
    foreach my $nat ( @$natarray ) 
    {
        my @nicarray = keys %LAN_IMQ;
        if ( $nat->{natid} eq 'system' ) { next; }
        if ( !grep(/^$nat->{nic}$/, @nicarray) )
        {
            $LAN_IMQ{$nat->{nic}} = $imqnum;
            $LAN_classid{$nat->{nic}} = 4;
            push(@alldev, $nat->{nic});
            push(@alldev, 'imq'.$LAN_IMQ{$nat->{nic}});
            $imqnum++;
        }
    }
    my $qoslan_script = "/usr/local/apache/qbconf/qoslan.sh";
    if ( !open(QOSLAN, ">$qoslan_script") )
    {
        print "open qoslan.sh fail!!\n";
        return;
    }
    
    foreach my $item ( keys %LAN_IMQ )
    {
        print QOSLAN qq "/usr/local/sbin/tc qdisc del dev $item root handle 100: htb default 3\n";
        print QOSLAN qq "/usr/local/sbin/tc qdisc add dev $item root handle 100: htb default 3\n";
        print QOSLAN qq "/usr/local/sbin/tc qdisc del dev imq$LAN_IMQ{$item} root handle 100: htb default 3\n";
        print QOSLAN qq "/usr/local/sbin/tc qdisc add dev imq$LAN_IMQ{$item} root handle 100: htb default 3\n";
        
        #################### IPv6 Qos - shane 20130426 ###############################
        foreach my $natt ( @$natarray )
        {
            if ( $nat->{natid} eq 'system' ) { next; }
            if ($item eq $natt->{nic} )
            {
                if (grep(/:/,$natt->{ip}))
                {
                    print QOSLAN qq "/sbin/ip6tables -t mangle -A PREROUTING -i $item -j IMQ --todev $LAN_IMQ{$item}\n";
                }else
                {
                    print QOSLAN qq "/sbin/iptables -t mangle -A PREROUTING -i $item -j IMQ --todev $LAN_IMQ{$item}\n";
                }
            }
        }
    }
    foreach my $item ( @$qoslanlist )
    {
        if ( $item->{source} eq '' ) { next; }
        my $nic = $item->{nic};
        my $imq = $LAN_IMQ{$nic};
        my @iplist;
                
        if ( $LAN_classid{$nic} == 4 )
        {
            print QOSLAN qq "\#set default class\n";
            print QOSLAN qq "/usr/local/sbin/tc class add dev imq$imq parent 100: classid 100:3 htb rate 10240000kbit ceil 1024000kbit\n";
            print QOSLAN qq "/usr/local/sbin/tc class add dev $nic parent 100: classid 100:3 htb rate 10240000kbit ceil 1024000kbit\n\n";
        }
        $qossource=$item->{source};        
        print QOSLAN qq "\#QoS of $item->{source}\n";
        if ( $item->{qostype} eq 'Share' )
        {
            
             my $classid = $LAN_classid{$nic};
            
             if ( grep(/-/, $item->{source}) )
             {
                  @iplist = get_allocated_ip($item->{source});
             }
             else
             {
                  push(@iplist, $item->{source});
             }
                        
             print QOSLAN qq "/usr/local/sbin/tc class add dev imq$imq parent 100:3 classid 100:$classid htb "; 
             print QOSLAN qq "rate $item->{uploadmin}kbit ceil $item->{uploadmax}\kbit prio 0\n";
             print QOSLAN qq "/usr/local/sbin/tc class add dev $nic parent 100:3 classid 100:$classid htb ";
             print QOSLAN qq "rate $item->{downloadmin}kbit ceil $item->{downloadmax}\kbit prio 0\n\n";
             print QOSLAN qq "/usr/local/sbin/tc qdisc add dev imq$imq parent 100:$classid handle $classid: sfq perturb 10\n";
             print QOSLAN qq "/usr/local/sbin/tc qdisc add dev $nic parent 100:$classid handle $classid: sfq perturb 10\n";
                    	        
             foreach my $ip ( @iplist )
             {
                  ###############IPv6 Qos - shane 20130426 ###########################
                  if (grep(/:/,$ip))
                  {
                      print QOSLAN qq "/usr/local/sbin/tc filter add dev imq$imq parent 100: prio $item->{priority} protocol ipv6 u32\\\n";
                      print QOSLAN qq "\tmatch ip6 src $ip\\\n";
                      print QOSLAN qq "\tflowid 100:$classid\n\n";
                  
                      print QOSLAN qq "/usr/local/sbin/tc filter add dev $nic parent 100: prio $item->{priority} protocol ipv6 u32\\\n";
                      print QOSLAN qq "\tmatch ip6 dst $ip\\\n";    
                      print QOSLAN qq "\tflowid 100:$classid\n\n";
                  }else
                  {
                      print QOSLAN qq "/usr/local/sbin/tc filter add dev imq$imq parent 100: prio $item->{priority} protocol ip u32\\\n";
                      print QOSLAN qq "\tmatch ip src $ip\\\n";
                      print QOSLAN qq "\tflowid 100:$classid\n\n";
                    	        
                      print QOSLAN qq "/usr/local/sbin/tc filter add dev $nic parent 100: prio $item->{priority} protocol ip u32\\\n";
                      print QOSLAN qq "\tmatch ip dst $ip\\\n";
                      print QOSLAN qq "\tflowid 100:$classid\n\n";
                  }
             }
             $LAN_classid{$nic}++;
         }
         else
         {
             if ( grep(/-/, $item->{source}) || grep(/\//, $item->{source}) )
             {
                 @iplist = get_allocated_ip($item->{source});
             }
             else
             {
                 push(@iplist, $item->{source});
             }
                	
             foreach my $ip ( @iplist )
             {
                 my $classid = $LAN_classid{$nic};
                 print QOSLAN qq "/usr/local/sbin/tc class add dev imq$imq parent 100:3 classid 100:$classid htb "; 
                 print QOSLAN qq "rate $item->{uploadmin}kbit ceil $item->{uploadmax}\kbit prio 0\n";
                 print QOSLAN qq "/usr/local/sbin/tc class add dev $nic parent 100:3 classid 100:$classid htb ";
                 print QOSLAN qq "rate $item->{downloadmin}kbit ceil $item->{downloadmax}\kbit prio 0\n";
                    	    
                 print QOSLAN qq "/usr/local/sbin/tc qdisc add dev imq$imq parent 100:$classid handle $classid: sfq perturb 10\n";
                 print QOSLAN qq "/usr/local/sbin/tc qdisc add dev $nic parent 100:$classid handle $classid: sfq perturb 10\n";
                                    
                 ############## IPv6 Qos - shane 20130426 #########################
                 if (grep(/:/,$ip))
                 {
                     print QOSLAN qq "/usr/local/sbin/tc filter add dev imq$imq parent 100: prio $item->{priority} protocol ipv6 u32\\\n";
                     print QOSLAN qq "\tmatch ip6 src $ip\\\n";
                     print QOSLAN qq "\tflowid 100:$classid\n\n";
                     
                     print QOSLAN qq "/usr/local/sbin/tc filter add dev $nic parent 100: prio $item->{priority} protocol ipv6 u32\\\n";
                     print QOSLAN qq "\tmatch ip6 dst $ip\\\n";
                     print QOSLAN qq "\tflowid 100:$classid\n\n";
                 }else
                 {
                     print QOSLAN qq "/usr/local/sbin/tc filter add dev imq$imq parent 100: prio $item->{priority} protocol ip u32\\\n";
                     print QOSLAN qq "\tmatch ip src $ip\\\n";
                     print QOSLAN qq "\tflowid 100:$classid\n\n";
                    	        
                     print QOSLAN qq "/usr/local/sbin/tc filter add dev $nic parent 100: prio $item->{priority} protocol ip u32\\\n";
                     print QOSLAN qq "\tmatch ip dst $ip\\\n";
                     print QOSLAN qq "\tflowid 100:$classid\n\n";
                 }
                 $LAN_classid{$nic}++;
              }
          }
    }
    close(QOSLAN);
    chmod(0777, $qoslan_script);
    
    my $qospolicy_script = "/usr/local/apache/qbconf/qos.sh";
    if ( !open(QOS, ">$qospolicy_script") )
    {
        print "open qospolicy.sh fail!!\n";
        return;
    }
    #======================================================
    # QoS of Policy
    #======================================================
    my $classid = 4;
    #my $imqnum = 0;
    my %ispimqin;
    my %ispimqout;
    my $bisubnet;
    my $brc;
    my $brn;
    my $oimq = 9;
    my $iimq = 10;
                                
    foreach my $group ( 'from', 'from_service_to', 'from_to' , 'dmz', 'lvs', 'nat', 'to' )
    {
        my $fwmarkarray=$fwmark->{$group}->[0]->{mark};

        foreach my $fw ( @$fwmarkarray )
        {
            my @iplist;
            #to check fwmark qos field
            if ( $fw->{qos} ne '' && $fw->{qos} ne 'None' )
            {
                #get table number
                my $table=substr($fw->{value}, -6, 2);
                $table=hex2dec($table);
                my $imqout;
                my $imqin;
                my $uploadmin;
                my $uploadmax;
                my $downloadmin;
                my $downloadmax;
                my $priority;
                my $qosname;
                my $uploadmark=$fw->{value};
                my $downloadmark= 0x40000000 | hex2dec($fw->{value});
                $downloadmark = '0x'.dec2hex($downloadmark);

                #get qos object
                foreach my $qos ( @$qoslist )
                {
                    if ( $qos->{qosname} eq $fw->{qos} )
                    {
                        $qosname = $qos->{qosname};
                        $qostype = $qos->{qostype};
                        $uploadmin = $qos->{uploadmin};
                        $uploadmax = $qos->{uploadmax};
                        $downloadmin = $qos->{downloadmin};
                        $downloadmax = $qos->{downloadmax};
                        $priority = $qos->{priority};
                        $type = $qos->{type};
                        $pool = $qos->{pool};
                        $qosisp = $qos->{isp};
                        $bisubnet = $fw->{source} ;
                        last;
                    }
                }
		#get table
		foreach my $rt ( @$rtablelist )
                {
                    if ( $rt->{table_num} eq $table )
                    {
                        my $pathlist=$rt->{path};
                        my $total_weight=0;
                        foreach my $item ( @$pathlist ) { $total_weight += $item->{weight}; }
                        print TEMP qq "\#Qos of fwmark $uploadmark \n";
                        my $matchqosisp = 1;
                        foreach my $item ( @$pathlist )
                        {
                            #my ($imqout, $imqin) = getimqnum($item->{isp});
                            #my ($imqout, $imqin);
                            if ( !$ispimqin{$item->{isp}} )
                            {
                                $ispimqout{$item->{isp}} = $imqnum++;
                                $ispimqin{$item->{isp}} = $imqnum++;
                            }
                            $imqout = $ispimqout{$item->{isp}}; 
                            $imqin = $ispimqin{$item->{isp}};
                            
                            
                            #push isp to qosisp array for iptables -j --todev $imqnum
                            if ( !grep(/^$item->{isp}$/, @qosisp) )
                            {
                                push(@qosisp, $item->{isp});
                                $qossubnet{$item->{isp}}=$item->{subnet};
                            }
                            my $ispref = maintainBasic( action=>"GETACTIVEISPINFO", iid=>$item->{isp} );
                            my $gateway = $ispref->{gateway};

			    #find isp of Qos object match table path
			    
                            foreach my $isp ( @$qosisp )
                            {
                                my $iid = $isp->{iid};
                                $iid =~ s/\(.*.\)//g;
                                #if ( $isp->{iid} eq 'ISP'.$item->{isp} )
                                my $zone=XMLread($gPATH.'zonecfg.xml');
                                my $iisp=XMLread($gPATH.'basic.xml');
                                my $zonelist=$zone->{dmz};
                                my $iisplist=$iisp->{isp};
                                foreach my $isp1 ( @$iisplist )
                                {
                               	    
                               	    if ( $iid eq 'ISP'.$isp1->{iid} )     
                               	    {
                               	         foreach my $dmz (@$zonelist)
                               	         {
                               	             if ($dmz->{mode} ne 'BRIDGE' || $dmz->{interface} ne $isp1->{nic}){next;}
                               	             $brc='1';
                               	             $brn=$dmz->{name};
                               	         }
                                    } 
                                }
                                if ( $iid eq 'ISP'.$item->{isp} )
                                {
                                    $path_uploadmin =  $isp->{uploadmin};
                                    $path_uploadmax =  $isp->{uploadmax};
                                    $path_downloadmin = $isp->{downloadmin};
                                    $path_downloadmax = $isp->{downloadmax};
                                    $matchqosisp = 1;
                                    last;
                                }
                                $matchqosisp = 0;
                            }
			    #if fwmark qos is by pool qos object
                            #table path not match qos object to skip generate tc command
                            if ( !$matchqosisp ) { next; }
                            
			    if ($qostype eq 'Individual' && $brc eq '1')
			    {
			    	@iplist = get_allocated_ip($bisubnet);
			    	#my $oimq = 10 + $imqout;
			    	#my $iimq = 10 + $imqin;
			    	my $check=-2;
			    	my $tclass=0;
			    	 
			    	foreach my $ip ( @iplist )
			    	{
			    	   if ($ip ne '' )
			    	   {
			    	       $check++;
			    	       $tclass++;
			    	       if ($check > 660 || $check < 0)
			    	       {
			    	           $oimq+=2;
			    	           $iimq+=2;
			    	          
			    	           print QOS qq "/usr/local/sbin/tc qdisc del dev imq$iimq root 2>/dev/null\n";
			    	           print QOS qq "/usr/local/sbin/tc qdisc del dev imq$oimq root 2>/dev/null\n";
			    	           print QOS qq "/usr/local/sbin/tc qdisc add dev imq$iimq root handle 100: htb default 3\n";
			    	           print QOS qq "/usr/local/sbin/tc qdisc add dev imq$oimq root handle 100: htb default 3\n";
			    	           print QOS qq "/usr/local/sbin/tc class add dev imq$oimq parent 100: classid 100:3 htb rate 40960Mbit\n";
			    	           print QOS qq "/usr/local/sbin/tc class add dev imq$iimq parent 100: classid 100:3 htb rate 40960Mbit\n";
			    	           
			    	           print QOS qq "/sbin/iptables -t mangle -A PREROUTING -i $brn -m mark --mark $downloadmark -d $bisubnet -j IMQ --todev $iimq\n";
			    	           print QOS qq "/sbin/iptables -t mangle -A POSTROUTING -o $brn -m mark --mark $uploadmark -s $bisubnet -j IMQ --todev $oimq\n";
			    	           print QOS qq "/usr/local/sbin/ip link set imq$iimq up\n";
			    	           print QOS qq "/usr/local/sbin/ip link set imq$oimq up\n";
			    	      	   $check = 0;	     
			    	       }
			    	       
			    	       if ($tclass eq 3){$tclass++;} 
			    	   	print QOS qq "/usr/local/sbin/tc class add dev imq$oimq parent 100:3 classid 100:$tclass htb ";
			    	   	print QOS qq "rate $path_uploadmin\kbit ceil $path_uploadmax\kbit prio $priority\n";
			    	   	print QOS qq "/usr/local/sbin/tc class add dev imq$iimq parent 100:3 classid 100:$tclass htb "; 
			    	   	print QOS qq "rate $path_downloadmin\kbit ceil $path_downloadmax\kbit prio $priority\n";
			    	  	print QOS qq "/usr/local/sbin/tc qdisc add dev imq$iimq parent 100:$tclass handle $tclass: sfq perturb 10\n";
			    	   	print QOS qq "/usr/local/sbin/tc qdisc add dev imq$oimq parent 100:$tclass handle $tclass: sfq perturb 10\n";
			    	   
			    	  	print QOS qq "/usr/local/sbin/tc filter add dev imq$oimq parent 100: prio $priority protocol ip u32 match ip src $ip flowid 100:$tclass\n"; 
			    	   
			    	   	print QOS qq "/usr/local/sbin/tc filter add dev imq$iimq parent 100: prio $priority protocol ip u32 match ip dst $ip flowid 100:$tclass\n";
			    	}
			    }
			    }else				
			    {
                            		print QOS qq "/usr/local/sbin/tc class add dev imq$imqout parent 100:3 classid 100:$classid htb ";
                            		print QOS qq "rate $path_uploadmin\kbit ceil $path_uploadmax\kbit prio $priority  \# $qosname upload\n";
                            		print QOS qq "/usr/local/sbin/tc class add dev imq$imqin parent 100:3 classid 100:$classid htb ";
                            		print QOS qq "rate $path_downloadmin\kbit ceil $path_downloadmax\kbit prio $priority \# $qosname download\n\n";
                            		print QOS qq "/usr/local/sbin/tc qdisc add dev imq$imqin parent 100:$classid handle $classid: sfq perturb 10\n";
                            		print QOS qq "/usr/local/sbin/tc qdisc add dev imq$imqout parent 100:$classid handle $classid: sfq perturb 10\n";
                            
                            		###################IPv6 Qos - shane 20130426 #########################
                            		if (grep(/:/,$gateway))
                            		{
                                		print QOS qq "/usr/local/sbin/tc filter add dev imq$imqout parent 100: prio $priority protocol ipv6 u32\\\n";     
                                		print QOS qq "\tmatch mark $uploadmark 0xffffffff \\\n";
                               	 		print QOS qq "\tflowid 100:$classid\n";
                                
                                		print QOS qq "/usr/local/sbin/tc filter add dev imq$imqin parent 100: prio $priority protocol ipv6 u32\\\n";
                                		print QOS qq "\tmatch mark $downloadmark 0xffffffff \\\n";
                                		print QOS qq "\tflowid 100:$classid\n\n";
                            		}else
                            		{
                                		print QOS qq "/usr/local/sbin/tc filter add dev imq$imqout parent 100: prio $priority protocol ip u32\\\n";
                                		print QOS qq "\tmatch mark $uploadmark 0xffffffff \\\n";
                                		print QOS qq "\tflowid 100:$classid\n";
                                
                                		#print QOS qq "iptables -t mangle -A POSTROUTING --match mark --mark $uploadmark -m gw --gw $gateway -j CLASSIFY --set-class 100:$classid\n";
                                
                                		print QOS qq "/usr/local/sbin/tc filter add dev imq$imqin parent 100: prio $priority protocol ip u32\\\n";
                                		print QOS qq "\tmatch mark $downloadmark 0xffffffff \\\n";
                                		print QOS qq "\tflowid 100:$classid\n\n";
                            		}
                            		$classid++;
                            	  }
                        }
                    }
                }
                print QOS qq "\#End of fwmark $uploadmark \n\n";
            }
        }
    }
    close(QOS);
    chmod(0777, $qospolicy_script);
    
    my $qosinit = "/usr/local/apache/qbconf/qosinit";
    if ( !open(QOSINIT, ">$qosinit") )
    {
        print "open qosinit fail!!\n";
        return;
    }

    @qosisp = sort { $a <=> $b } @qosisp;

    foreach my $isp ( @qosisp )
    {
        my $ispref = maintainBasic( action=>"GETACTIVEISPINFO", iid=>$isp );
        my $isptype = $ispref->{isptype};
        my $gateway = $ispref->{gateway};
        my $upload = $ispref->{upload};
        my $download = $ispref->{download};
        my $nic = $ispref->{nic};
        #my ($imqout, $imqin) = getimqnum($isp);
        
        my $imqout = $ispimqout{$isp};
        my $imqin = $ispimqin{$isp};
        
        push(@alldev, 'imq'.$imqin);
        push(@alldev, 'imq'.$imqout);
        $isptype = ( $isptype ne 'tunnel' ) ? ( '1' ) : ( '2' );
        
        my $zone=XMLread($gPATH.'zonecfg.xml');
        my $zonelist=$zone->{dmz};
        my $def = 3;
        my $bridge='0';
        my $brname;
        foreach my $dmz (@$zonelist)
        {
  	    if ($dmz->{mode} ne 'BRIDGE' || $dmz->{interface} ne $nic){next;}
  	    $isptype = '2';
  	    $bridge='1';
  	    $brname=$dmz->{name};
  	    last;
  	}
        print QOSINIT qq "/usr/local/sbin/tc qdisc del dev imq$imqin root handle 100: htb default $def\n";
        print QOSINIT qq "/usr/local/sbin/tc qdisc del dev imq$imqout root handle 100: htb default $def\n";
        print QOSINIT qq "/usr/local/sbin/tc qdisc add dev imq$imqin root handle 100: htb default $def\n";
        print QOSINIT qq "/usr/local/sbin/tc qdisc add dev imq$imqout root handle 100: htb default $def\n";
        print QOSINIT qq "/usr/local/sbin/tc class add dev imq$imqout parent 100: classid 100:3 htb rate 10Mbit\n";
        print QOSINIT qq "/usr/local/sbin/tc class add dev imq$imqin parent 100: classid 100:3 htb rate 10Mbit\n";
        
        #########################Bridge Qos - shane 20130514#########################
        my $brsubnet;
        
	foreach my $key (keys %qossubnet)
	{
	    if ($isp ne $key){next;}
	    $brsubnet = $qossubnet{$key};
	}
	##########################IPv6 Qos - shane 20130426 ##########################
	
        if (grep(/:/,$gateway))
        {
            if ( $isptype eq '2' )
            {
                if ($bridge eq '1')
                {
                    print QOSINIT qq "/sbin/ip6tables -t mangle -A PREROUTING -i $nic -d $brsubnet -j IMQ --todev $imqin\n";
                }else
                {
                    print QOSINIT qq "/sbin/ip6tables -t mangle -A PREROUTING -i $nic -j IMQ --todev $imqin\n";
                }
            }
            else
            {
                ####################
                print QOSINIT qq "/sbin/ip6tables -t mangle -A PREROUTING -m ingw --ispid $isp --isptype $isptype --ispgwip 0 -j IMQ --todev $imqin\n";
            }
            if ($bridge eq '1')
            {
                print QOSINIT qq "/sbin/ip6tables -t mangle -A POSTROUTING -o $brname -j IMQ --todev $imqout\n";
            }else
            {
                print QOSINIT qq "/sbin/ip6tables -t mangle -A POSTROUTING -o $nic -m gw --gw $gateway -j IMQ --todev $imqout\n";
            }
        }else
        {
            if ( $isptype eq '2' )
            {
                if ($bridge eq '1')
                {
                    print QOSINIT qq "/sbin/iptables -t mangle -A PREROUTING -i $brname -j IMQ --todev $imqin\n";
                }else
                {
                    print QOSINIT qq "/sbin/iptables -t mangle -A PREROUTING -i $nic -j IMQ --todev $imqin\n";
                }
            }
            else
            {
            
            	#Gary 20130619 Individual
            	if ($qostype eq 'Individual')
            	{
            	    @iplist = get_allocated_ip($item->{source});
            	    foreach my $ip ( @iplist )
            	    {
                        print QOSINIT qq "/sbin/iptables -t mangle -A PREROUTING -s $ip -m ingw --ispid $isp --isptype $isptype --ispgwip 0 -j IMQ --todev $imqin\n";
            	    }
            	}
            	else
            	{
                print QOSINIT qq "/sbin/iptables -t mangle -A PREROUTING -m ingw --ispid $isp --isptype $isptype --ispgwip 0 -j IMQ --todev $imqin\n";
                }
            }
            if ($bridge eq '1')
            {
                print QOSINIT qq "/sbin/iptables -t mangle -A POSTROUTING -o $brname -j IMQ --todev $imqout\n";
            }
            else
            {
            	if ($qostype eq 'Individual')
            	{
            	    foreach my $ip ( @iplist )
            	    {
 	                print QOSINIT qq "/sbin/iptables -t mangle -A POSTROUTING -s $ip -o $nic -m gw --gw $gateway -j IMQ --todev $imqout\n";
            	    }
            	}
            	else
            	{
                print QOSINIT qq "/sbin/iptables -t mangle -A POSTROUTING -o $nic -m gw --gw $gateway -j IMQ --todev $imqout\n";
                }
            }
        }
    }
    close(QOSINIT);
    chmod(0777, $qosinit);
    #======================================================
    # QoS of ISP
    #======================================================
    my $qosisp = "/usr/local/apache/qbconf/qosisp.sh";
    if ( !open(QOSISP, ">$qosisp") )
    {
        print "open qosisp fail!!\n";
        return;
    }
    foreach my $isp ( @$isplist )
    {
        if ( $isp->{isptype} ne 'tunnel' ) { next; }
        if ( $isp->{qos} ne '' && $isp->{qos} ne '0' ) 
        {
            print QOSISP qq "/usr/local/sbin/tc qdisc del dev $isp->{nic} root handle 100: htb default 3\n";
            print QOSISP qq "/usr/local/sbin/tc qdisc add dev $isp->{nic} root handle 100: htb default 3\n";
            print QOSISP qq "/usr/local/sbin/tc class add dev $isp->{nic} parent 100: classid 100:3 htb rate $isp->{qos}kbit\n";
            push(@alldev, $isp->{nic});
        }
    }
    close(QOSISP);
    chmod(0777, $qosisp);
     
    
    #======================================================
    # del qdisc 
    #======================================================
    my $delall = "/usr/local/apache/qbconf/delall";
    if ( !open(QOSDEL, ">$delall") )
    {
        print "open qosdel fail!!\n";
        return;
    }
    
    foreach my $dev ( @alldev )
    {
        print QOSDEL qq "/usr/local/sbin/tc qdisc del dev $dev root handle 100: htb default 3\n";
    }
    close(QOSDEL);
    chmod(0777, $delall);
    
}
 
sub getimqnum
{
    my $isp = shift;
    my $imqout = $isp * 2 - 2;
    my $imqin = $isp * 2 - 1;

    return ($imqout, $imqin);
}

=cut
sub getimqnum
{
    my $natref=XMLread($gPATH.'zonecfg.xml');
    my $natarray=$natref->{nat};
    my $src = shift;
    my $imqin;
    my $imqout;
    
    foreach my $nat ( @$natarray )
    {
        if ( subnet_belong_check($src, $nat->{network}) )
        {
            #return ( $nat->{nic});
            $imqin = $nat->{nic};
            my $num = $imqin; 
            $num =~ s/eth//;
            $imqout = 'imq'.$num;
        }
    }
    
    return ($imqout, $imqin);
}
=cut

#==================================================================================================
# timeminsegs2hrminsegs( reference to the array of minutes-formed time segments ( from XML ) )
sub timeminsegs2hrminsegs()
{
    my $minsegs=shift;
    my %hrminseqhash;

    foreach my $seg ( @$minsegs )
    {
        my ( $start, $end )=split(/:/,$seg);
        
        my $starthour=floor($start/60); 
        $starthour='0'.$starthour if ( $starthour <=9 );
        
        my $startmin=$start%60; 
        $startmin='0'.$startmin if ( $startmin <=9 );
        
        my $endhour=floor($end/60); 
        $endhour='0'.$endhour if ( $endhour <=9 );
        
        my $endmin=$end%60; 
        $endmin='0'.$endmin if ( $endmin <=9 );
        
        my $segitem=$starthour.':'.$startmin.'-'.$endhour.':'.$endmin;

        $hrminseqhash{$segitem}=1;
    }

    return sort keys ( %hrminseqhash );
}
#timeminsegs2hrminsegs


#==================================================================================================
# timesegarray2seqarray(reference to an array of segments )
sub timesegarray2seqarray() 
{
    my $segments=shift;
    my %seqhash;

    foreach my $seg ( @$segments ) 
    {
        my ( $start, $end )=split(/:/,$seg);
        $start=($start/10)+1;
        $end=($end+1)/10;
        for ( my $segitem=$start; $segitem<=$end; $segitem++ )
        {
            $seqhash{$segitem}=1;
        }               
    }
    return sort keys ( %seqhash );
}
#timesegarray2seqarray


#==================================================================================================
# timeseqarray2segarray( reference to an array of sequences )
sub timeseqarray2segarray() 
{
    my $sequences=shift;
    my %seghash;
    my $segment;

    foreach my $seq ( @$sequences ) { $seqhash{$seq}=1; }
    for ( my $i=0,$j=1; $j<=145; $i++, $j++)
    {
        if ( !$seqhash{$i} && $seqhash{$j} )
        {    
            $segment.=($i*10).':';
        }
        elsif ( $seqhash{$i} && !$seqhash{$j} )
        {
            $segment.=$i*10-1;
            $seghash{$segment}=1;
            $segment='';
        }
    }
    
    return sort keys( %seghash );
}
#timeseqarray2seqarray


#==================================================================================================
sub timeseq2section() 
{
    my $seq=shift;
    my ( $minutes, $hours, $start, $end );
    if ( $seq!~m/\d{1,2}/ ) { return; }
    
    my $minutes=($seq-1)*10;
    $hours=floor($minutes/60); $hours='0'.$hours if ( $hours <= 9 );
    $minutes%=60; $minutes='0'.$minutes if ( $minutes <=9 );
    $start=$hours.':'.$minutes;
    $end=$hours.':'.($minutes+9);
    $end=$hours.':0'.($minutes+9) if ( $minutes == 0 );
    return $start.'-'.$end;
}
#timeseq2section


#================================================================================================
sub ini_class_sort_by_source 
{
    my @afields=split(/\.|\//,$a->{source});
    my @bfields=split(/\.|\//,$b->{source});
    foreach my $index ( 0..4 )
    {
         $avalue=int($afields[$index]); 
         $bvalue=int($bfields[$index]);
         if ( $avalue != $bvalue ) { last; }
    }

    if ( $avalue == $bvalue )
    {
        return $a->{service} cmp $b->{service}; 
    }
    else
    {
        $avalue <=> $bvalue;
    }
}
#ini_class_sort_by_source

sub ini_class_sort_by_hostobj
{
    if ( $a->{source} eq $b->{source} )
    {
        return $a->{service} cmp $b->{service};
    }
    return $a->{source} cmp $b->{source};
}
#ini_class_sort_by_hostobj


#================================================================================================
sub ini_class_sort_by_service 
{

    if ( $a->{service} ne $b->{service} )
    {
        return $a->{service} cmp $b->{service};
    }

    my ( $avalue, $bvalue );
    
    my @afields=split(/\.|\//,$a->{source});
    my @bfields=split(/\.|\//,$b->{source});
    foreach my $index ( 0..4 )
    {
        $avalue=int($afields[$index]); 
        $bvalue=int($bfields[$index]);
        if ( $avalue != $bvalue ) { last; }
    }

    return $avalue <=> $bvalue;
}
#ini_class_sort_by_service


#================================================================================================
sub proute_class_sort_by_source 
{
    my @afields=split(/\.|\//,$a->{source});
    my @bfields=split(/\.|\//,$b->{source});
    foreach my $index ( 0..4 )
    {
         $avalue=int($afields[$index]); 
         $bvalue=int($bfields[$index]);
         if ( $avalue != $bvalue ) { last; }
    }

    if ( $avalue == $bvalue )
    {
        return $a->{service} cmp $b->{service};
    }
    else
    {
        $avalue <=> $bvalue;
    }
}
#proute_class_sort_by_source 
#####################################################################
1
